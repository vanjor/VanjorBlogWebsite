<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vanjor&#39;s Blog</title>
  
  <subtitle>notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.vanjor.com/"/>
  <updated>2019-12-27T14:30:00.000Z</updated>
  <id>https://blog.vanjor.com/</id>
  
  <author>
    <name>Vanjor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>告别2019</title>
    <link href="https://blog.vanjor.com/2019/12/fareware_2019/"/>
    <id>https://blog.vanjor.com/2019/12/fareware_2019/</id>
    <published>2019-12-27T14:30:00.000Z</published>
    <updated>2019-12-27T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得飞快，2019年马上就要过去，再有四天就要步入2020年了。</p><a id="more"></a><p>最近几年生活上变化比较大，在2019年悬而未决的进程-工作签证问题早在一月中旬欣然的落定了，一个非常好的开端，在二月中旬，举家迁徙来到西雅图，来到地球另一端的这个城市开启完全不一样的生活。</p><p>在这一年里生活上有几件大事，五月买了车，梦想中7座SUV, 八月买了房，梦想中的独立庭院的山间别墅，九月H1B抽中并顺利通过只等大使馆激活，小十一也健康的成长，并开始蹦蹦跳跳，翻箱倒柜了。</p><p>虽然相比之下，工作上的进展就缓慢平淡的许多，仍在调整适应。</p><p>2020年即将到来，有些期许，希望能在工作生活的达到一种良好的平衡，工作上能有说更大进展，生活上能多一些时间陪伴，多一起做些尝试，多留下一些美好的记忆。财务中慢慢更加清晰的规划和执行，身份问题顺利进展，政策稳定明朗。</p><p>附: </p><p>Christmas Eve当天即兴去Warmat买了彩灯并装饰房屋，算是入乡随俗，也尊重下邻里。<br><img src="https://asset.vanjor.com/imgs/home_exterior_santa_lantern.jpeg" alt="article-logo"></p><p>Christmas Eve Living Room的装饰<br><img src="https://asset.vanjor.com/imgs/home_santa_interior_deer.jpeg" alt="article-logo"></p><p>与小十一的15个月的合照<br><img src="https://asset.vanjor.com/imgs/vanjor_15_months.jpg" alt="article-logo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间过得飞快，2019年马上就要过去，再有四天就要步入2020年了。&lt;/p&gt;
    
    </summary>
    
      <category term="指尖舞蹈" scheme="https://blog.vanjor.com/categories/life/"/>
    
    
      <category term="Mood" scheme="https://blog.vanjor.com/tags/mood/"/>
    
  </entry>
  
  <entry>
    <title>Learn on AWS DynamoDB</title>
    <link href="https://blog.vanjor.com/2019/06/dynamo-db-learning-summary/"/>
    <id>https://blog.vanjor.com/2019/06/dynamo-db-learning-summary/</id>
    <published>2019-06-25T14:00:00.000Z</published>
    <updated>2020-01-02T17:12:36.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><ul><li>Tables: same with RDS</li><li>Items: similar as record/row in RDS</li><li>Attributes: similarcolumns in RDS</li></ul><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>A key-value and document database</li><li>Fully cloud host, auto scale </li><li>No connection pool, only concurrent concept to avoid break limit for Dynamodb API is based on web service.</li></ul><a id="more"></a><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul><li>Table: A table is a collection of data</li><li>Item: Similar to row in RDB, Each table contains zero or more items. An item is a group of attributes that is uniquely identifiable among all of the other items.</li><li>Attribute: Each item is composed of one or more attributes. An attribute is a fundamental data element. Similar to column in RDB, each item contains multiple attributes.</li></ul><h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><ul><li>Primary key (aka: Primary Index)</li><li>Secondary Index<ul><li>Local Secondary Indexes (LSI)</li><li>Global Secondary Indexe (GSI)</li></ul></li></ul><h3 id="Primary-key"><a href="#Primary-key" class="headerlink" title="Primary key"></a>Primary key</h3><p>Table must define the primary key, support two types:</p><ul><li>partition key:<ul><li>aka: hash attribute</li><li>should be unique</li><li>dynamo will run hash function on this to decide partition for physical storage.</li></ul></li><li>partition key and sort key:<ul><li>a composite key with two attributes</li><li>aka: hash attribute + range attribute</li><li>partition key + sort key should be unique, while partition key can be not unique.</li><li>All items with the same partition key value are stored together, in sorted order by sort key.</li></ul></li></ul><p>More introduction:</p><ul><li>The only data types allowed for primary key attributes are string, number, or binary</li></ul><h3 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h3><p>DynamoDB supports two kinds of indexes:</p><ul><li>Global secondary index – An index with a partition key and sort key that can be different from table primary key. support eventually consistent or strongly consistent reads.</li><li>Local secondary index – An index that has the same partition key with table primary key, but have a different sort key. only support eventually consistent reads.</li></ul><p>Each table in DynamoDB has a limit of 20 global secondary indexes (default limit) and 5 local secondary indexes per table.</p><h2 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h2><ul><li>Scalar Types: Number(int, long, double, float), String, Boolean, Bytes, Date.</li><li>Collection types: Set</li><li>Support any user defined type by using DynamoDBTypeConverter.</li></ul><h2 id="Retrieve-Operation"><a href="#Retrieve-Operation" class="headerlink" title="Retrieve Operation"></a>Retrieve Operation</h2><ul><li>Query: must specify a partition key value; the sort key is optional.</li><li>Scan: lower efficient.</li></ul><h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><ul><li>A Query operation always returns a result set. will be empty Set if not found.</li><li>Query results are always sorted by the sort key value. By default, the sort order is ascending. We can set the ScanIndexForward parameter to false to reverse order.</li><li>A single Query operation can retrieve a maximum of 1 MB of data. This limit applies before any FilterExpression is applied to the results. If LastEvaluatedKey is present in the response and is non-null, we will need to paginate the result set.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>AWS official document: <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html</a></li><li>AWS DDB data types: <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.DataTypes.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.DataTypes.html</a></li><li>DDB study notes:  <a href="https://rickhw.github.io/2016/08/17/AWS/Study-Notes-DynamoDB/" target="_blank" rel="noopener">https://rickhw.github.io/2016/08/17/AWS/Study-Notes-DynamoDB/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic-Concept&quot;&gt;&lt;a href=&quot;#Basic-Concept&quot; class=&quot;headerlink&quot; title=&quot;Basic Concept&quot;&gt;&lt;/a&gt;Basic Concept&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tables: same with RDS&lt;/li&gt;
&lt;li&gt;Items: similar as record/row in RDS&lt;/li&gt;
&lt;li&gt;Attributes: similarcolumns in RDS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Feature&quot;&gt;&lt;a href=&quot;#Feature&quot; class=&quot;headerlink&quot; title=&quot;Feature&quot;&gt;&lt;/a&gt;Feature&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A key-value and document database&lt;/li&gt;
&lt;li&gt;Fully cloud host, auto scale &lt;/li&gt;
&lt;li&gt;No connection pool, only concurrent concept to avoid break limit for Dynamodb API is based on web service.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="DynamoDB" scheme="https://blog.vanjor.com/tags/dynamodb/"/>
    
      <category term="AWS" scheme="https://blog.vanjor.com/tags/aws/"/>
    
  </entry>
  
  <entry>
    <title>告别2018</title>
    <link href="https://blog.vanjor.com/2018/12/fareware_2018/"/>
    <id>https://blog.vanjor.com/2018/12/fareware_2018/</id>
    <published>2018-12-31T15:30:00.000Z</published>
    <updated>2018-12-31T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>来不及回忆，来不及告别，2018马上就悄然而去了。</p><a id="more"></a><p>2018最大的收获，宝宝小十一降生了，过程比我想的要顺利，宝宝也我期望的也要更可爱。</p><p>2018也有许些遗憾，有戛然而止的期待，也有悬而未决进程。不过宝宝的到来，让我开始沉稳了些，因为遗憾的事不再是生活的全部，每天看着宝宝快乐的成长，前方的路总会是有的。</p><p>2018年的最后一周，重新捡起了博客，升级了程序代码，迁移下旧的博客内容，写了个小程序自动备份博客图片，让它变的更完整了，至此再也不担心丢失什么了。</p><p>最近多次触动到感悟: “人生很短, 活明白太迟”, 真切的感受到要重视并利用好时间，去做些有意义的事情，不苟且眼前的工作。不希望到老来回忆起来是太多虚度年华，留下太多遗憾。</p><p>当感受到眼前的剧烈起伏，跳出来，把目光放远，收获你的定力，坚定你的动力。</p><p>2019, 我来了，你呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来不及回忆，来不及告别，2018马上就悄然而去了。&lt;/p&gt;
    
    </summary>
    
      <category term="指尖舞蹈" scheme="https://blog.vanjor.com/categories/life/"/>
    
    
      <category term="Mood" scheme="https://blog.vanjor.com/tags/mood/"/>
    
  </entry>
  
  <entry>
    <title>基于Maven的Java包版本管理</title>
    <link href="https://blog.vanjor.com/2016/10/maven-version-control/"/>
    <id>https://blog.vanjor.com/2016/10/maven-version-control/</id>
    <published>2016-10-20T02:00:00.000Z</published>
    <updated>2016-10-20T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk9jm52b3j30zk085dfw.jpg" alt="maven logo"></p><p>Java打包与依赖奠定了软件包发布与版本管理的依赖的一个业界规范。</p><a id="more"></a><h1 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h1><p>Maven中版本号类似1.0,1.1,1.1.1,主题规则如下</p><blockquote><p>&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;</p></blockquote><p>其中:</p><ul><li>主版本: 重大架构变更，类似maven1和maven2，兼容性业不一定保证的，Gitlab项目以年为粒度迭代</li><li>次版本：功能模块级别的变更，Gitlab项目已月为粒度迭代</li><li>增量版本：补丁buffix级别，一般针对次版本的发布的功能等快速修复，Gitlab以天或周级别迭代</li></ul><h1 id="snapshot与release区别"><a href="#snapshot与release区别" class="headerlink" title="snapshot与release区别"></a>snapshot与release区别</h1><p>release是稳定版，但在开发中为了解决间依赖的项目间并行开发，可以基于snapshot快速迭代，而不需要频繁变更pom.xml中依赖的版本</p><ul><li>snapshot：用于保存开发过程中不稳定版本，一般允许redeploy</li><li>release：用于保存稳定发布的版本，一般不允许redeploy</li></ul><p>假设当前CodeOne，已发布1.0.0 release版本，现在开发新的功能。</p><ul><li>更新pom版本从1.0.0 到 1.1.0-SNAPSHOT</li><li>不断开发功能，持续发布1.1.0-SNAPSHOT版本, 开发完毕后需要正式发布</li><li>更新pom版本从1.1.0-SNAPSHOT 到 1.1.0，并项目打上tag 1.1.0,完成1.1.0 release正式版发布.</li></ul><p>注意: 一般发布是不分源代码项目分支的，如果多个分支需要各自迭代，可实现安排号发布版本号区别，比如 1.1.0-SNAPSHOT与1.2.0-SNAPSHOT</p><h1 id="maven发布规则"><a href="#maven发布规则" class="headerlink" title="maven发布规则"></a>maven发布规则</h1><h2 id="snapshot发布"><a href="#snapshot发布" class="headerlink" title="snapshot发布"></a>snapshot发布</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vanjor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>-SNAPSHOT(必须大写)，maven将自动判断为snapshot发布</p><p>如果发布到 <a href="http://central.maven.org/maven2/" target="_blank" rel="noopener">http://central.maven.org/maven2/</a> 中，则实际发布地址为：</p><blockquote><p><a href="http://central.maven.org/maven2/com/vanjor/demo/0.1-SNAPSHOT/demo-0.1-20161020.091255-1.jar" target="_blank" rel="noopener">http://central.maven.org/maven2/com/vanjor/demo/0.1-SNAPSHOT/demo-0.1-20161020.091255-1.jar</a></p></blockquote><p>其中demo-0.1-20161020.091255-1.jar, snapshot将自动被转换为 日期-时间-迭代次数</p><h2 id="release发布"><a href="#release发布" class="headerlink" title="release发布"></a>release发布</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vanjor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果发布到 <a href="http://central.maven.org/maven2/" target="_blank" rel="noopener">http://central.maven.org/maven2/</a> 中，则实际发布地址为：</p><blockquote><p><a href="http://central.maven.org/maven2/com/vanjor/demo/0.1/demo-0.1.jar" target="_blank" rel="noopener">http://central.maven.org/maven2/com/vanjor/demo/0.1/demo-0.1.jar</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://juvenshun.iteye.com/blog/376422" target="_blank" rel="noopener">http://juvenshun.iteye.com/blog/376422</a></li><li><a href="http://liyixing1.iteye.com/blog/2171254" target="_blank" rel="noopener">http://liyixing1.iteye.com/blog/2171254</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyk9jm52b3j30zk085dfw.jpg&quot; alt=&quot;maven logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java打包与依赖奠定了软件包发布与版本管理的依赖的一个业界规范。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Java" scheme="https://blog.vanjor.com/tags/java/"/>
    
      <category term="Maven" scheme="https://blog.vanjor.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Git学习指南</title>
    <link href="https://blog.vanjor.com/2016/05/git-complete-user-guide/"/>
    <id>https://blog.vanjor.com/2016/05/git-complete-user-guide/</id>
    <published>2016-05-06T09:15:00.000Z</published>
    <updated>2016-05-06T09:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk93b0u54j30xc0hi759.jpg" alt="article-logo"></p><a id="more"></a><h1 id="Git-工作原理"><a href="#Git-工作原理" class="headerlink" title="Git 工作原理"></a>Git 工作原理</h1><p>Git作为一种分布式代码仓库，便在设计上区别与SVN</p><h2 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h2><h3 id="simplest"><a href="#simplest" class="headerlink" title="simplest"></a>simplest</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk93ufs6oj30uy0k5757.jpg" alt="git workflow basic"></p><h3 id="detailer"><a href="#detailer" class="headerlink" title="detailer"></a>detailer</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk94abf3wj30dm0b0dft.jpg" alt="git workflow complex"></p><h3 id="comprehension"><a href="#comprehension" class="headerlink" title="comprehension"></a>comprehension</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyl9gxi6mhj30sg0ift9c.jpg" alt="complex workflow"></p><h3 id="multiple-remote-repos"><a href="#multiple-remote-repos" class="headerlink" title="multiple remote repos"></a>multiple remote repos</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk963sdybj30sg0r4tak.jpg" alt="multiple remote repos"></p><h3 id="扩展参考"><a href="#扩展参考" class="headerlink" title="扩展参考"></a>扩展参考</h3><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git - 简明指南</a></li><li><a href="https://www.sonassi.com/blog/knowledge-base/our-magento-git-guide-and-work-flow" target="_blank" rel="noopener">Our Magento Git Guide and Work Flow</a></li><li><a href="https://www.quora.com/What-is-the-best-Git-cheat-sheet" target="_blank" rel="noopener">What is the best Git cheat sheet?</a></li></ul><h1 id="Git-常用命令清单"><a href="#Git-常用命令清单" class="headerlink" title="Git 常用命令清单"></a>Git 常用命令清单</h1><p>重度参考 <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a> ，有增删改纠。 以下为常用的20几个命令分类介绍</p><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 新建一个目录，并初始化为本地Git代码库</span><br><span class="line"><span class="meta">$</span> git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下载一个远程Git项目代码库到指定目录</span><br><span class="line"><span class="meta">$</span> git clone &lt;repository_uri&gt; [directory]</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前git配置</span><br><span class="line"><span class="meta">$</span> git config --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编辑git配置, global为用户全局配置</span><br><span class="line"><span class="meta">$</span> git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置当前用户信息，提交代码需要</span><br><span class="line"><span class="meta">$</span> git config [--global] user.name "[name]"</span><br><span class="line"><span class="meta">$</span> git config [--global] user.email "[email address]"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置项目git忽略文件/夹列表, 项目根目录创建.gitignore文件</span><br><span class="line"><span class="meta">$</span> echo ".project" &gt;&gt; .gitigore</span><br></pre></td></tr></table></figure><h2 id="增删文件"><a href="#增删文件" class="headerlink" title="增删文件"></a>增删文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加文件/目录到暂存区(stage/index)</span><br><span class="line"><span class="meta">$</span> git add [file1] [file2]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加当前目录所有文件到暂存区</span><br><span class="line"><span class="meta">$</span> git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加当前项目所有文件到暂存区</span><br><span class="line"><span class="meta">$</span> git add --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除[递归]指定workspace文件或目录</span><br><span class="line"><span class="meta">$</span> git rm [-r] [file1] [file2]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 停止追踪指定文件，git add的反向操作</span><br><span class="line"><span class="meta">$</span> git rm --cached [file]</span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将变更从暂存区提交到本地仓库</span><br><span class="line"><span class="meta">$</span> git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动stage哪些已经被修改或删除的文件（新增文件无效）, 一并提交到本地仓库</span><br><span class="line"><span class="meta">$</span> git commit -am [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用一次新的commit，替代上一次提交，并包含当前stage的变更</span><br><span class="line"><span class="meta">$</span> git commit --amend -m [message]</span><br></pre></td></tr></table></figure><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列举所有本地分支, -a 包含远程分支</span><br><span class="line"><span class="meta">$</span> git branch [-a]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 对当前分支新建一个分支，仍停留在当前分支</span><br><span class="line"><span class="meta">$</span>  git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 对当前分支新建一个分支，切换工作区间到新分支</span><br><span class="line"><span class="meta">$</span> git checkout -b [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 合并指定分支到当前分支</span><br><span class="line"><span class="meta">$</span> git merge [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 选择一个commit，仅合并改commit到当前分支</span><br><span class="line"><span class="meta">$</span> git cherry-pick [commit-hashcode]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除分支</span><br><span class="line"><span class="meta">$</span> git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除远程分支</span><br><span class="line"><span class="meta">$</span> git branch -dr [branch-name]</span><br><span class="line"><span class="meta">$</span> git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 显示变更文件</span><br><span class="line"><span class="meta">$</span> git status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示当前仓库中所有版本历史, stat显示变更文件</span><br><span class="line"><span class="meta">$</span> git log [--stat]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示某个文件的历史版本，包括改名</span><br><span class="line"><span class="meta">$</span> git log --follow [file]</span><br><span class="line"><span class="meta">$</span> git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示指定文件每一行是什么人在什么时间修改过</span><br><span class="line"><span class="meta">$</span> git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示暂存区和工作区的差异</span><br><span class="line"><span class="meta">$</span> git diff</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示暂存区和本地仓库(最后一次commit)的差异</span><br><span class="line"><span class="meta">$</span> git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示工作区和本地仓库(最后一次commit)的差异</span><br><span class="line"><span class="meta">$</span> git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示某次提交的具体变动内容</span><br><span class="line"><span class="meta">$</span> git show [commit-hashcode]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示本地仓库最近几次提交 (当前分支)</span><br><span class="line"><span class="meta">$</span> git reflog [branch]</span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 取回远程仓库所有变动</span><br><span class="line"><span class="meta">$</span> git fetch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 取回远程仓库所有变动到本地仓库，并与本地分支合并</span><br><span class="line"><span class="meta">#</span> 相当于 git fetch &amp; git merge</span><br><span class="line"><span class="meta">$</span> git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line"><span class="meta">$</span> git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 推送所有分支到远程仓库</span><br><span class="line"><span class="meta">$</span> git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 恢复暂存区的指定文件(最后一次添加到暂存区的版本)到工作区，清除工作区改文件的修改</span><br><span class="line"><span class="meta">$</span> git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 恢复暂存区的所有文件到工作区</span><br><span class="line"><span class="meta">$</span> git checkout .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变， git add 逆向操作</span><br><span class="line"><span class="meta">$</span> git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line"><span class="meta">$</span> git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line"><span class="meta">$</span> git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 暂时将未提交的变化移除，稍后再移入</span><br><span class="line"><span class="meta">$</span> git stash</span><br><span class="line"><span class="meta">$</span> git stash pop</span><br></pre></td></tr></table></figure><h1 id="Git-的特点"><a href="#Git-的特点" class="headerlink" title="Git 的特点"></a>Git 的特点</h1><h2 id="Git与SVN常用命令对比"><a href="#Git与SVN常用命令对比" class="headerlink" title="Git与SVN常用命令对比"></a>Git与SVN常用命令对比</h2><table><thead><tr><th>操作</th><th>svn</th><th>git</th></tr></thead><tbody><tr><td>创建</td><td>svnadmin create</td><td>git init</td></tr><tr><td>签出</td><td>svn checkout</td><td>git clone</td></tr><tr><td>更新</td><td>svn update</td><td>git pull</td></tr><tr><td>添加</td><td>svn add</td><td>git add</td></tr><tr><td>提交</td><td>svn commit</td><td>git commit</td></tr><tr><td>查看状态</td><td>svn status</td><td>git status</td></tr><tr><td>合并</td><td>svn merge</td><td>git merge</td></tr><tr><td>回滚</td><td>svn revert</td><td>git checkout</td></tr><tr><td>diff</td><td>svn diff</td><td>git diff</td></tr><tr><td>创建分支</td><td>svn copy</td><td>git branch</td></tr><tr><td>切换分支</td><td>git checkout</td><td>svn switch</td></tr></tbody></table><h2 id="Git-特点"><a href="#Git-特点" class="headerlink" title="Git 特点"></a>Git 特点</h2><ul><li>分布式代码版本控制</li><li>基于清点引用的方式进行变更追踪</li></ul><h1 id="Git-完整命令清单"><a href="#Git-完整命令清单" class="headerlink" title="Git 完整命令清单"></a>Git 完整命令清单</h1><h2 id="Git-官方最常用命令"><a href="#Git-官方最常用命令" class="headerlink" title="Git 官方最常用命令"></a>Git 官方最常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git help</span><br><span class="line">The most commonly used git commands are:</span><br><span class="line"> add        Add file contents to the index</span><br><span class="line"> bisect     Find by binary search the change that introduced a bug</span><br><span class="line"> branch     List, create, or delete branches</span><br><span class="line"> checkout   Checkout a branch or paths to the working tree</span><br><span class="line"> clone      Clone a repository into a new directory</span><br><span class="line"> commit     Record changes to the repository</span><br><span class="line"> diff       Show changes between commits, commit and working tree, etc</span><br><span class="line"> fetch      Download objects and refs from another repository</span><br><span class="line"> grep       Print lines matching a pattern</span><br><span class="line"> init       Create an empty Git repository or reinitialize an existing one</span><br><span class="line"> log        Show commit logs</span><br><span class="line"> merge      Join two or more development histories together</span><br><span class="line"> mv         Move or rename a file, a directory, or a symlink</span><br><span class="line"> pull       Fetch from and integrate with another repository or a local branch</span><br><span class="line"> push       Update remote refs along with associated objects</span><br><span class="line"> rebase     Forward-port local commits to the updated upstream head</span><br><span class="line"> reset      Reset current HEAD to the specified state</span><br><span class="line"> rm         Remove files from the working tree and from the index</span><br><span class="line"> show       Show various types of objects</span><br><span class="line"> status     Show the working tree status</span><br><span class="line"> tag        Create, list, delete or verify a tag object signed with GPG</span><br></pre></td></tr></table></figure><h2 id="Git-全部命令清单"><a href="#Git-全部命令清单" class="headerlink" title="Git 全部命令清单"></a>Git 全部命令清单</h2><p>全部命令共155个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git help</span><br><span class="line">  add                       fsck                      receive-pack</span><br><span class="line">  add--interactive          fsck-objects              reflog</span><br><span class="line">  am                        gc                        relink</span><br><span class="line">  annotate                  get-tar-commit-id         remote</span><br><span class="line">  apply                     grep                      remote-ext</span><br><span class="line">  archimport                gui                       remote-fd</span><br><span class="line">  archive                   gui--askpass              remote-ftp</span><br><span class="line">  bisect                    hash-object               remote-ftps</span><br><span class="line">  bisect--helper            help                      remote-http</span><br><span class="line">  blame                     http-backend              remote-https</span><br><span class="line">  branch                    http-fetch                remote-testsvn</span><br><span class="line">  bundle                    http-push                 repack</span><br><span class="line">  cat-file                  index-pack                replace</span><br><span class="line">  check-attr                init                      request-pull</span><br><span class="line">  check-ignore              init-db                   rerere</span><br><span class="line">  check-mailmap             instaweb                  reset</span><br><span class="line">  check-ref-format          interpret-trailers        rev-list</span><br><span class="line">  checkout                  log                       rev-parse</span><br><span class="line">  checkout-index            ls-files                  revert</span><br><span class="line">  cherry                    ls-remote                 rm</span><br><span class="line">  cherry-pick               ls-tree                   send-email</span><br><span class="line">  citool                    mailinfo                  send-pack</span><br><span class="line">  clean                     mailsplit                 sh-i18n--envsubst</span><br><span class="line">  clone                     merge                     shell</span><br><span class="line">  column                    merge-base                shortlog</span><br><span class="line">  commit                    merge-file                show</span><br><span class="line">  commit-tree               merge-index               show-branch</span><br><span class="line">  config                    merge-octopus             show-index</span><br><span class="line">  count-objects             merge-one-file            show-ref</span><br><span class="line">  credential                merge-ours                stage</span><br><span class="line">  credential-cache          merge-recursive           stash</span><br><span class="line">  credential-cache--daemon  merge-resolve             status</span><br><span class="line">  credential-store          merge-subtree             stripspace</span><br><span class="line">  cvsexportcommit           merge-tree                submodule</span><br><span class="line">  cvsimport                 mergetool                 svn</span><br><span class="line">  cvsserver                 mktag                     symbolic-ref</span><br><span class="line">  daemon                    mktree                    tag</span><br><span class="line">  describe                  mv                        unpack-file</span><br><span class="line">  diff                      name-rev                  unpack-objects</span><br><span class="line">  diff-files                notes                     update-index</span><br><span class="line">  diff-index                p4                        update-ref</span><br><span class="line">  diff-tree                 pack-objects              update-server-info</span><br><span class="line">  difftool                  pack-redundant            upload-archive</span><br><span class="line">  difftool--helper          pack-refs                 upload-pack</span><br><span class="line">  fast-export               patch-id                  var</span><br><span class="line">  fast-import               prune                     verify-commit</span><br><span class="line">  fetch                     prune-packed              verify-pack</span><br><span class="line">  fetch-pack                pull                      verify-tag</span><br><span class="line">  filter-branch             push                      web--browse</span><br><span class="line">  fmt-merge-msg             quiltimport               whatchanged</span><br><span class="line">  for-each-ref              read-tree                 write-tree</span><br><span class="line">  format-patch              rebase</span><br></pre></td></tr></table></figure><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git 官方中文手册</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a></li><li><a href="http://gitref.org/zh/index.html" target="_blank" rel="noopener">Git 参考手册-命令详解</a></li></ul><h2 id="Git-cheat-sheet"><a href="#Git-cheat-sheet" class="headerlink" title="Git cheat sheet"></a>Git cheat sheet</h2><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk97sbhsxj30sg0kddij.jpg" alt="git-cheatsheet"></p><h1 id="Git-深入学习"><a href="#Git-深入学习" class="headerlink" title="Git 深入学习"></a>Git 深入学习</h1><h2 id="git-reset-git-checkout-git-revert-区别"><a href="#git-reset-git-checkout-git-revert-区别" class="headerlink" title="git reset, git checkout, git revert 区别"></a>git reset, git checkout, git revert 区别</h2><p>svn主要有revert，而git有三个，</p><p> git reset用于撤销未被提交到远端的改动。除了可以移动当前分支的HEAD，你可以通过不同的标记选择修改 staged snapshot 或者 working directory</p><ul><li>–soft： staged snapshot 和 working directory 都未被改变 (建议在命令行执行后，再输入 git status 查看状态)</li><li>–mixed： staged snapshot 被更新， working directory 未被更改。【这是默认选项】（建议同上)</li><li>–hard： staged snapshot 和 working directory 都将回退。</li></ul><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting" target="_blank" rel="noopener">Reset, Checkout, and Revert</a>, <a href="http://blog.mexiqq.com/index.php/archives/3/" target="_blank" rel="noopener">中文翻译</a></p><h2 id="Merging-vs-Rebasing"><a href="#Merging-vs-Rebasing" class="headerlink" title="Merging vs. Rebasing"></a>Merging vs. Rebasing</h2><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">Merging vs. Rebasing</a></p><h2 id="Refs-and-the-Reflog"><a href="#Refs-and-the-Reflog" class="headerlink" title="Refs and the Reflog"></a>Refs and the Reflog</h2><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/refs-and-the-reflog" target="_blank" rel="noopener">Refs and the Reflogg</a></p><h2 id="Git-log-高级使用方法"><a href="#Git-log-高级使用方法" class="headerlink" title="Git log 高级使用方法"></a>Git log 高级使用方法</h2><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/git-log" target="_blank" rel="noopener">Advanced Git log</a></p><h2 id="Git-hacks"><a href="#Git-hacks" class="headerlink" title="Git hacks"></a>Git hacks</h2><h3 id="避免每次迁入迁出输入密码"><a href="#避免每次迁入迁出输入密码" class="headerlink" title="避免每次迁入迁出输入密码"></a>避免每次迁入迁出输入密码</h3><p><a href="https://blog.sleeplessbeastie.eu/2012/08/12/git-how-to-avoid-typing-your-password-repeatedly/" target="_blank" rel="noopener">Git - How to avoid typing your password repeatedly</a></p><h1 id="Git-Ops"><a href="#Git-Ops" class="headerlink" title="Git Ops"></a>Git Ops</h1><h2 id="如何搭建私有Git代码仓库"><a href="#如何搭建私有Git代码仓库" class="headerlink" title="如何搭建私有Git代码仓库"></a>如何搭建私有Git代码仓库</h2><p>git本身是一种去中心化的设计，可以无需中心代码仓库而工作，大家协同工作可以基于各自私有的repos进行互相track开发。但企业难免需要有一个中心代码仓库，方便统一管理、权限控制、24小时服务。</p><p>严格来说任意一台联网机器至少装了git客户端就可以作为中心服务器，但不支持多种协议签出代码，没有权限控制等一系列功能。</p><p>目前最好的方式就是直接搭建<a href="https://about.gitlab.com/features/" target="_blank" rel="noopener">Gitlab</a>（开源免费）一站式服务，包含有全面的代码管理，权限，issue，wiki等功能，与github功能十分类似。</p><p>不基于Gitlab可以自己通过<a href="http://gitolite.com/gitolite/index.html" target="_blank" rel="noopener">Gitolite</a>(权限控制层模块)，<a href="http://nginx.org" target="_blank" rel="noopener">nginx</a>(提供http协议)，等自己组装实现。</p><ul><li><a href="http://stackoverflow.com/questions/17167414/which-is-the-best-git-hosting-sw-gitolite-vs-gitlab-vs-gitorius" target="_blank" rel="noopener">Which is the best git hosting sw? - Gitolite vs. Gitlab vs.<br>Gitorius</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">搭建Git服务器</a></li><li><a href="http://zodiacg.net/2014/05/gitolite_gitweb_nginx/" target="_blank" rel="noopener">配置Gitolite+Gitweb+Nginx</a></li></ul><h1 id="Git-开发流程与规范"><a href="#Git-开发流程与规范" class="headerlink" title="Git 开发流程与规范"></a>Git 开发流程与规范</h1><p><img src="https://asset.vanjor.com/images/006tNbRwly1fylpkjyx4uj30u013rwhl.jpg" alt="A successful Git branching model"></p><ul><li><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git 分支管理策略</a></li></ul><h1 id="Git-commit-message-编写规范"><a href="#Git-commit-message-编写规范" class="headerlink" title="Git commit message 编写规范"></a>Git commit message 编写规范</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyk93b0u54j30xc0hi759.jpg&quot; alt=&quot;article-logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="最佳实践" scheme="https://blog.vanjor.com/categories/best-practice/"/>
    
    
      <category term="Git" scheme="https://blog.vanjor.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo在Github上搭建技术博客</title>
    <link href="https://blog.vanjor.com/2016/05/hexo-github-blog-install/"/>
    <id>https://blog.vanjor.com/2016/05/hexo-github-blog-install/</id>
    <published>2016-05-04T07:15:00.000Z</published>
    <updated>2018-12-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyjdb5974cj30hs07sdgp.jpg" alt="Github托管Hexo博客"></p><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>选型配置如下:</p><ul><li>博客语言: <a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown</a> 可移植跨平台</li><li>博客程序: <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a></li><li>博客主题: <a href="https://theme-next.org" target="_blank" rel="noopener">NexT</a></li><li>静态博客托管: <a href="https://github.com" target="_blank" rel="noopener">Github</a> + <a href="https://coding.net" target="_blank" rel="noopener">Coding.net</a> 双线托管</li><li>域名DNS: <a href="https://www.aliyun.cn/" target="_blank" rel="noopener">Aliyun</a> 双线解析</li><li>自动部署: <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci</a> 持续集成自动部署</li><li>写作编辑: <a href="https://code.visualstudio.com" target="_blank" rel="noopener">vscode</a> + <a href="https://prose.io" target="_blank" rel="noopener">prose</a> 离线&amp;在线写作</li><li>图片工具: <a href="https://itunes.apple.com/cn/app/ipic-markdown-图床-文件上传工具/id1101244278" target="_blank" rel="noopener">iPic</a> 图床管理</li><li>评论&amp;阅读数统计: <a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a> 基于 next 的valine 插件实现</li></ul><a id="more"></a><p>为什么要从自建worldpress迁移过来，原因可参考阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">文章</a>，相比之下wordpress各种不省心并复杂繁琐，而现在方案每篇文章就是一个markdown文档，满足随心DIY。</p><blockquote><p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p></blockquote><h1 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h1><p>Hexo搭建教简单，参考<a href="https://hexo.io/docs/setup.html" target="_blank" rel="noopener">官方教程</a> 10分钟能出hello world。</p><p>个人大致总结Hexo特点:</p><ul><li>极易上手，几部命令完成</li><li>单一配置文件_config.yml 易懂扩展性强</li><li>Hexo支持较好的部署功能，支持多种部署方式与多目标部署</li><li>模板与插件丰富，安装方便。 官方网站已经有多达百种供选择</li></ul><p>其他可见: <a href="https://www.zhihu.com/question/21981094" target="_blank" rel="noopener">开源博客横向评测</a></p><h1 id="国内国外双线加速"><a href="#国内国外双线加速" class="headerlink" title="国内国外双线加速"></a>国内国外双线加速</h1><p>国内访问gitlub不太稳定，通过Hexo方便的支持双线同时发布，并通过dnspod的智能路由解析功能实现，国内访问到是coding.net托管的，国外访问的是github托管的。</p><p>详细教程参考: <a href="https://segmentfault.com/a/1190000004548638" target="_blank" rel="noopener">hexo同时托管到coding.net与github</a></p><p>附我的hexo的<a href="https://github.com/vanjor/VanjorBlogWebsite/blob/source/_config.yml" target="_blank" rel="noopener">_config.yml</a></p><h1 id="自动部署发布文章"><a href="#自动部署发布文章" class="headerlink" title="自动部署发布文章"></a>自动部署发布文章</h1><p>Github支持Webhook可以自动触发自己主机上的发布脚本，但仍需要自己维护主机，利用travis-ci可以消除这一依赖。</p><p>完整教程参考: <a href="http://blog.acwong.org/2016/03/20/auto-deploy-hexo-with-travis-CI/" target="_blank" rel="noopener">用 Travis CI 自动部署 hexo</a><br>注: ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ -t id_rsa 通过-t命令指定保存为当前目录的id_rsa文件。</p><p>附本博客:</p><ul><li>源码系统项目: <a href="https://github.com/vanjor/VanjorBlogWebsite" target="_blank" rel="noopener">https://github.com/vanjor/VanjorBlogWebsite</a><ul><li>branch: source as default branch is the source code</li><li>branch: master retain the compiled website code serve as Github Page service</li></ul></li><li>travis-ci自动编译部署历史: <a href="https://travis-ci.org/vanjor/VanjorBlogWebsite" target="_blank" rel="noopener">https://travis-ci.org/vanjor/VanjorBlogWebsite</a></li></ul><h1 id="博客的详细配置变更"><a href="#博客的详细配置变更" class="headerlink" title="博客的详细配置变更"></a>博客的详细配置变更</h1><p>对 hexo 定制化过的文件</p><ul><li>source 文档及一些图片资源</li><li>_config.yml hexo 的配置</li><li>package.json hexo 依赖</li><li>themes/next/source/lib 扩展包安装</li><li>themes/next/_config.yml 主体配置</li><li>.travis.yml travis CI 配置</li><li>.travis travis 所需 ssh key token 配置</li><li>.gitignore git 所需</li><li>README.md 文档</li></ul><p>开启的的功能列表:</p><ul><li>valine + leancloud_visitors基于 leancloud 的评论与阅读数统计 [依赖三方网络服务]</li><li>RSS</li><li>local_search 搜索</li><li>math公式支持</li><li>han + pangu 文章编排美化</li><li>百度+谷歌统计分析  [依赖三方网络服务]</li><li>fancybox 图片相册支持</li><li>pace 加载进度条</li><li>post_edit 显示文章源码link</li><li>symbols_count_time 字数与阅读时长显示</li><li>icon 更新页底copyright信息</li><li>增加 tags, categories, archieves, about 四个子页面</li><li>开启social 社交网站链接</li><li>Hexo 特有的 Tags Settings (开启，但暂没使用需要进一步评估)</li><li>增加了 robots 协议</li><li>增加 sitemap 提交百度+谷歌+微软站长管理平台</li><li>强制 tags 链接全小写 filename_case=1</li><li>Add license and copy right by using creative_commons config</li><li>Enable full English URL by enable category_map</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyjdb5974cj30hs07sdgp.jpg&quot; alt=&quot;Github托管Hexo博客&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;选型配置如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;博客语言: &lt;a href=&quot;http://wowubuntu.com/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt; 可移植跨平台&lt;/li&gt;
&lt;li&gt;博客程序: &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博客主题: &lt;a href=&quot;https://theme-next.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NexT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;静态博客托管: &lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt; + &lt;a href=&quot;https://coding.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding.net&lt;/a&gt; 双线托管&lt;/li&gt;
&lt;li&gt;域名DNS: &lt;a href=&quot;https://www.aliyun.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Aliyun&lt;/a&gt; 双线解析&lt;/li&gt;
&lt;li&gt;自动部署: &lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;travis-ci&lt;/a&gt; 持续集成自动部署&lt;/li&gt;
&lt;li&gt;写作编辑: &lt;a href=&quot;https://code.visualstudio.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vscode&lt;/a&gt; + &lt;a href=&quot;https://prose.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;prose&lt;/a&gt; 离线&amp;amp;在线写作&lt;/li&gt;
&lt;li&gt;图片工具: &lt;a href=&quot;https://itunes.apple.com/cn/app/ipic-markdown-图床-文件上传工具/id1101244278&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iPic&lt;/a&gt; 图床管理&lt;/li&gt;
&lt;li&gt;评论&amp;amp;阅读数统计: &lt;a href=&quot;https://leancloud.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leancloud&lt;/a&gt; 基于 next 的valine 插件实现&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="最佳实践" scheme="https://blog.vanjor.com/categories/best-practice/"/>
    
    
      <category term="Hexo" scheme="https://blog.vanjor.com/tags/hexo/"/>
    
      <category term="Github" scheme="https://blog.vanjor.com/tags/github/"/>
    
      <category term="Markdown" scheme="https://blog.vanjor.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>情感计算-基于规则分类</title>
    <link href="https://blog.vanjor.com/2010/12/rule-based-classification/"/>
    <id>https://blog.vanjor.com/2010/12/rule-based-classification/</id>
    <published>2010-12-27T08:58:00.000Z</published>
    <updated>2010-12-27T08:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo064xl7ij308g03ca9y.jpg" alt="sentiment analysis"></p><p>情感计算中，很重要的一个问题就是为目标情感数据进行分类，先行的很多文本分类技术与文本聚类技术SVM，K-means等，背后都是利用一些先决的条件，比如SVM的先决条件是建立文本向量空间VSM上。而这些文本分类技术都很少涉及到语义语法分析，或者建立十分微弱的语义语法分析基础上，比如上篇文章《<a href="/2010/12/latent-aspect-rating-analysis/">评论潜在方面观点计算</a>》。</p><p>本文为学习论文《<a href="http://linkinghub.elsevier.com/retrieve/pii/S1751157709000108" target="_blank" rel="noopener">Sentiment Analysis: A Combined Approach</a>》，提取其中主要的方法-基于规则分类。 着重为基于规则分类RBC与基于统计分类SBC。</p><a id="more"></a><h1 id="基于规则分类基础分析"><a href="#基于规则分类基础分析" class="headerlink" title="基于规则分类基础分析"></a>基于规则分类基础分析</h1><p>一个规则包含一个先行词（antecedent）和关联的后项（consequent），并有着“如果-那么”的关联：</p><blockquote><p>先行词 =》 后项</p></blockquote><p>一个先行词定义一个条件（condition），并且由一个标记（token）或一组由^连接的标记序列。</p><p>一个标记可以是一个单词，“？”表示一个专有名词，“#”表示一个目标术语。一个目标术语是一个表示文档集中出现的内容，例如一个政客的名字，一个政策主张，一个公司名称，一个产品平台或者电影标题。一个连续术语表示一个情感是术语积极或者消极的一种，并且条件最后的结果由先行词定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;token1 ^ token2 ^ . . . ^ tokenn&#125; =) &#123;+|−&#125;</span><br></pre></td></tr></table></figure><p>如下这两个简单的规则取决于两个情感支撑词，每个代表一个先行词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;excellent&#125; =) &#123;+&#125;  </span><br><span class="line">&#123;absurd&#125; =) &#123;−&#125;</span><br></pre></td></tr></table></figure><p>假设我们有两个句子.</p><ol><li>Laptop-A is more expensive than Laptop-B.</li><li>Laptop-A is more expensive than Laptop-C.</li></ol><p>并且这些句子的目标词为Laptop-A ，有这些句子推导出的规则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;# ^ more ^ expensive ^ than^?&#125; =) &#123;−&#125;</span><br></pre></td></tr></table></figure><p>这个规则可以解释为：目标词：Laptop-A相对另两个laptops在价格方面相对更少受喜爱的，由以上规则表达，这里，聚焦在Laptop-A的价格特性上。</p><p>最为比对，假设目标此为Laptop-B和Laptop-C，有以上句子推导出的规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;? ^ more ^ expensive ^ than ^ #&#125; =) &#123;+&#125;</span><br></pre></td></tr></table></figure><p>这个规则可以解释为：两个目标词，Laptop-B和Laptop-C相对价格方面比LaptopA更受欢迎。由以上规则表达。这里，聚焦在Laptop-B和Laptop-C的价格特性上。</p><p>很明显，一个目标词是一个决定情感中的先行词的一个重要因素。在这个程度上，我们可以关注在获取和定义先行词和后项集来形成一组规则集，反应一组代表文档集内容的目标词，评估4个不同的分类器，不同的都应用了一套规则。我们同样考虑否定在内，’not’, ‘neither nor’和‘no’,相对来说，我们扫描文档中的每一个句子，也就是，基于句子层级。每个先行词由句子推导出来。</p><h1 id="通用基于获取分类器（General-Inquirer-Based-Classifier-GIBC-）"><a href="#通用基于获取分类器（General-Inquirer-Based-Classifier-GIBC-）" class="headerlink" title="通用基于获取分类器（General Inquirer Based Classifier (GIBC)）"></a>通用基于获取分类器（General Inquirer Based Classifier (GIBC)）</h1><p>首先，简单的规则集是基于在General Inquirer Lexicon(Stone et al. 1966)中的3672个预先分类好的词，其中1598个预先归类为积极，另2074个预先归类为消极。这里，每个规则唯一取决于代表每个先行词的情感支撑词。我们应用General Inquirer Based Classifier (GIBC)到规则集，来分类文档集。</p><p>通用基于获取分类器其实也就是一些自动分类机的概念，大致为假定对应的文档中出现情感词的频率可以反映概括为文档总体情感。</p><h1 id="基于规则分类器（Rule-Based-Classifier-RBC-）"><a href="#基于规则分类器（Rule-Based-Classifier-RBC-）" class="headerlink" title="基于规则分类器（Rule-Based Classifier (RBC)）"></a>基于规则分类器（Rule-Based Classifier (RBC)）</h1><p>给定一个预先分类好的文档集，第二个规则集由将每个专有名词取代为“？”或“#”来形成一组先行词，并且为每个先行词赋予情感（规则的形成）。这样，基本的假设是为每一个先行词赋予的情感等同于为对应文档赋予情感。这样我们基于RBC实现第二种规则来对文档分类。</p><p>有争议的一点是，先行词表达的情感可能与文档的情感不同。因此，我们采用一个情感计算工具（Sentiment Analysis Tool (SAT)），可以以半自动方式来矫正情感。</p><p>如下步骤用来生成先行词集。</p><p>The Montylingua (Liu 2004) chunker用来解析文档集中句子，给定这些解析后的句子，一组专有名词，也就是，所有标有NNP和NNPS的术语，被自动鉴别出，并替换“？”，为了减少解析的错误率，我们自动的扫描，并测试所有由Montylingua识别出的专有名词，比对在WordNet 2.0 (Miller 1995)中的所有名词（NN，NNS），当Montylingua中的专有名词在WordNet中为标准名词，这个专有名词将被视为不正确的标注，将不会被“？”所替代。另外，所有目标词都被替代为“#”，这样，一组先行词由此生成。一个后缀数组(Manber &amp; Myers 1990)用来加速先行词匹配。</p><h1 id="基于统计分类器（SBC）"><a href="#基于统计分类器（SBC）" class="headerlink" title="基于统计分类器（SBC）"></a>基于统计分类器（SBC）</h1><p>基于统计分类机（SBC）使用一组规则集，基于如下假设：糟糕的表达式与词“poor”具有更高的<strong>共现率（co-occur frequency）</strong>，并且好的表达式与词语“excellent”具有更好个共现率(Turney 2002).</p><ol><li>我们计算一个由先行词组成的表达与情感支撑词集见的紧密度，如下步骤用来定义先行词的结果：</li><li>从General Inquirer Lexicon中挑选120个积极的词语，比如amazing, awesome, beautiful，以及120个消极词语，比如absurd, angry, anguish</li><li>为每一个先行词，分别与这240个词语组合一个查询，提交给搜索引擎，每个查询包含有一个先行词与情感支撑词。</li><li>收集所有提交给Google与Yahoo搜索引擎的查询结果中的命中数，两个搜索引擎用来分析命中数是或由搜索引擎各自的覆盖性与精确性所决定。对于每个查询，我们预期搜索引擎返回同时包含有先行词与情感支撑词的网页文档数目。这里，紧密程度计算是基于网页级别。一个更好的精确计算可能从基于句子级别获得。目前来说比较困难，我们需要从搜索引擎下载并存储每一篇网页以备分析。</li><li>为每个情感支撑词与先行词收集命中数</li><li>使用四种测量度来测量每个先行词分别于120个积极词（S+）以及消极词（S-）间的紧密度。</li></ol><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo07n4lp7j3072030wec.jpg" alt="sentiment analysis"></p><p>如果先行词共现率S+ > S- ,那么，以为这先行词为积极的，反之S+ &lt; S-则判定先行词为消极的，而S+ = S-则判定为中性，</p><p>紧密测量度涉及到如下概念：</p><h2 id="文档频率（Document-Frequency-DF-）"><a href="#文档频率（Document-Frequency-DF-）" class="headerlink" title="文档频率（Document Frequency (DF)）"></a>文档频率（Document Frequency (DF)）</h2><p>包含目标词的文档占总共文档的比率：如下：</p><p>一个包含N个文档的文档集集的共现矩阵</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0bovdxlj30cm03c3yf.jpg" alt="rbc"></p><h2 id="互信息（Mutual-Information-MI-）"><a href="#互信息（Mutual-Information-MI-）" class="headerlink" title="互信息（Mutual Information (MI)）"></a>互信息（Mutual Information (MI)）</h2><p>一个先行词与对应情感支撑词的互信息MI表示如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0c4h6lsj30cm01mjra.jpg" alt="mi"></p><p>更大的MI值，代表先行词与word见更高强度的关联，并且MI(antecedent,word)必须大于</p><p>0，意味着联合概率，P(antecedent,word)必须大于P(antecedent)与P(word)概率组合。在Conrad &amp; Utt(1994) 和Church &amp; Hanks (1989)两篇论文中均运用到MI测量术语间的关联度。</p><h2 id="卡方分布（Chi-square-χ2-）"><a href="#卡方分布（Chi-square-χ2-）" class="headerlink" title="卡方分布（Chi-square (χ2)）"></a>卡方分布（Chi-square (χ2)）</h2><p>给定2*2列联表，一个表包含观察到的频率，另一包含预期的频率，那么词语对应先行词的卡方值计算如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0cb9po8j304a01m742.jpg" alt="chi"></p><p>其中 i = {a . . . d} 表示2*2列联表中的每个方格值。<a href="http://www.nciku.cn/search/zh/detail/%E8%80%B6%E8%8C%A8%E8%BF%9E%E7%BB%AD%E6%80%A7%E6%A0%A1%E6%AD%A3/645089" target="_blank" rel="noopener">耶茨连续性校正</a>（The Yates continuity correction）被应用到每个开放计算中，并且自由度为1。更大的卡方值，意味着更有利证明来剔除虚假设，并排除之，意味着词语和先行词之间互相独立，对于卡方测试，为了可信接受或拒绝H0，预期的值应该大于5，否则，趋向于低于小概率可能性，将不正确的结果纳入H1(Cochran 1954).</p><h2 id="对数似然比（Log-Likelihood-Ratio）-−2-·-log"><a href="#对数似然比（Log-Likelihood-Ratio）-−2-·-log" class="headerlink" title="对数似然比（Log Likelihood Ratio）(−2 · log)"></a>对数似然比（Log Likelihood Ratio）(−2 · log)</h2><p>对数似然比计算如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0cnfay4j309u03jt8l.jpg" alt="log"></p><p>其中i = {a, b, c, d}并且 j = {c1, c2, r1, r2}. 对数似然比(Dunning 1993)与卡方假设类似，也就是，更大的对数似然比，意味着更有利证明来剔除虚假设。不同于卡方，对数似然比是比卡方更为精确的处理稀有事件。</p><p>举例说明，对于如下具体的数据：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0ctbv2ej308g02pjr9.jpg" alt="rbc"></p><ul><li>DF=40，也就是文档中同时出现先行词与词语的文档数。<img src="https://asset.vanjor.com/images/006tNbRwly1fyo0d31i1oj309h011dfn.jpg" alt="rbc"></li><li>为了计算卡方，预期的频率，E计算出如下: <img src="https://asset.vanjor.com/images/006tNbRwly1fyo0dbphmhj308g02rmx0.jpg" alt="rbc"> <img src="https://asset.vanjor.com/images/006tNbRwly1fyo0duzipej305k01a3ya.jpg" alt="rbc"></li><li>极大似然比为 <img src="https://asset.vanjor.com/images/006tNbRwly1fyo0ehviukj30bb018743.jpg" alt="rbc"></li></ul><h1 id="基于规则归纳分类器（Induction-Rule-Based-Classifier-IRBC-）"><a href="#基于规则归纳分类器（Induction-Rule-Based-Classifier-IRBC-）" class="headerlink" title="基于规则归纳分类器（Induction Rule Based Classifier (IRBC)）"></a>基于规则归纳分类器（Induction Rule Based Classifier (IRBC)）</h1><p>给定两组规则集RBC与SBC，我们应用已有的两种归纳算法ID3 (Quinlan 1986) 和由Weka (Witten &amp; Frank 2005)提供的RIPPER (Cohen 1995)的归纳算法。来生成两组归纳规则几，并建立一个分类器采用这两个归纳规则分类机来对文本集进行分类。</p><p>这两个归纳规则集可以表明归纳算法对于无控制的先行词集的效果，也就是这些先行词所表示的属性没有预定义，但是可以简单的从预先分类文档中归纳出。并且可以预期这种归纳规则集的效果将会拥有更好的准确率与召回率。</p><p>最后，论文中提出结合SVM等方法的一种组合分类方法流程图如下：<br><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0fpprsbj30ec08q3ys.jpg" alt="rbc"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyo064xl7ij308g03ca9y.jpg&quot; alt=&quot;sentiment analysis&quot;&gt;&lt;/p&gt;
&lt;p&gt;情感计算中，很重要的一个问题就是为目标情感数据进行分类，先行的很多文本分类技术与文本聚类技术SVM，K-means等，背后都是利用一些先决的条件，比如SVM的先决条件是建立文本向量空间VSM上。而这些文本分类技术都很少涉及到语义语法分析，或者建立十分微弱的语义语法分析基础上，比如上篇文章《&lt;a href=&quot;/2010/12/latent-aspect-rating-analysis/&quot;&gt;评论潜在方面观点计算&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;本文为学习论文《&lt;a href=&quot;http://linkinghub.elsevier.com/retrieve/pii/S1751157709000108&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sentiment Analysis: A Combined Approach&lt;/a&gt;》，提取其中主要的方法-基于规则分类。 着重为基于规则分类RBC与基于统计分类SBC。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="Classifier" scheme="https://blog.vanjor.com/tags/classifier/"/>
    
      <category term="Sentiment Analysis" scheme="https://blog.vanjor.com/tags/sentiment-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Java界面开发工具WindowBuilder</title>
    <link href="https://blog.vanjor.com/2010/12/java-windowbuilder/"/>
    <id>https://blog.vanjor.com/2010/12/java-windowbuilder/</id>
    <published>2010-12-22T15:45:22.000Z</published>
    <updated>2010-12-22T15:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz8c4114g306s041746.gif" alt="windows-builder"></p><p>在项目要进行最终界面展示开发时，又得回到熟悉而久违的的SWT/JFACE，继而追寻那Eclipse的优秀的<a href="http://baike.baidu.com/view/6326.htm" target="_blank" rel="noopener">WYSIWYG</a>插件<a href="http://code.google.com/javadevtools/wbpro/index.html" target="_blank" rel="noopener">WindowBuilder</a>（没用WB之前都是手工敲代码，并界面排版），却惊喜的发现，不用再漫天搜查注册码，如今WindowBuilder的Java/Ajax工具开发商<a href="http://www.instantiations.com/" target="_blank" rel="noopener">Instantiations</a>已经于2010年8月被Google给收购了，WindowBuilder也作为免费工具开放，强大的Google！</p><p>并传闻Google这一收购用意不仅在GWT设计工具，更在于Ajax和Java方面，Google所有网页应用都部署了大量的Ajax，而Android应用则使用Java来创建。</p><a id="more"></a><h1 id="WindowBuilder简介"><a href="#WindowBuilder简介" class="headerlink" title="WindowBuilder简介"></a>WindowBuilder简介</h1><p>WindowBuilder是一款基于Eclipse平台的双向Java的GUI设计插件式的软件。具备SWT/JFACE开发、Swing开发及GWT 开发三大功能，是一款不可多得的Java体系中的WYSIWYG工具。</p><p>WindowBuilder目前最新版是8.1.0</p><p>WindowBuilder的主要用户界面构建为：</p><ul><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/design_view.html" target="_blank" rel="noopener">Design View</a></strong> - the main visual layout area.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/source_view.html" target="_blank" rel="noopener">Source View</a></strong> - write code and review the generated code</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/structure_view.html" target="_blank" rel="noopener">Structure View</a></strong> - composed of the <strong>Component Tree</strong> and the <strong>Property Pane.</strong><ul><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/component_tree.html" target="_blank" rel="noopener">Component Tree</a></strong> - shows the hierarchical relationship between all of the components.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/property_pane.html" target="_blank" rel="noopener">Property Pane</a></strong> - displays properties and events of the selected components.</li></ul></li><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/palette.html" target="_blank" rel="noopener">Palette</a></strong> - provides quick access to toolkit-specific components.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/toolbar.html" target="_blank" rel="noopener">Toolbar</a></strong> - provides access to commonly used commands.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/context_menu.html" target="_blank" rel="noopener">Context Menu</a></strong> - provides access to commonly used commands</li></ul><h1 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h1><ul><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/bidirectional.html" target="_blank" rel="noopener">Bi-directional Code Generation</a> -</strong> read and write almost any format and reverse-engineer most hand-written code</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/internationalization.html" target="_blank" rel="noopener">Internationalization (i18n) / Localization</a> -</strong> externalize component strings, create and manage resource bundles.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/custom_composites.html" target="_blank" rel="noopener">Custom Composites &amp; Panels</a></strong> - create custom, reusable components.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/factories.html" target="_blank" rel="noopener">Factories</a></strong> - create custom factory classes and methods.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/visual_inheritance.html" target="_blank" rel="noopener">Visual Inheritance</a></strong> - create visual component hierarchies.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/event_handling.html" target="_blank" rel="noopener">Event Handling</a></strong> - add event handlers to your components.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/menu_editing.html" target="_blank" rel="noopener">Menu Editing</a></strong> - visually create and edit menubars, menu items and popup menus.</li><li><strong><a href="http://code.google.com/javadevtools/wbpro/features/morphing.html" target="_blank" rel="noopener">Morphing</a></strong> - convert one component type into another.</li></ul><h1 id="基于Eclipse-MyEclipse的安装"><a href="#基于Eclipse-MyEclipse的安装" class="headerlink" title="基于Eclipse/MyEclipse的安装"></a>基于Eclipse/MyEclipse的安装</h1><p>目前只能通过windowbuilder更新地址在线安装：  </p><ul><li><a href="http://dl.google.com/eclipse/inst/d2wbpro/latest/3.6" target="_blank" rel="noopener">Eclipse 3.6 (Helios)</a>  </li><li><a href="http://dl.google.com/eclipse/inst/d2wbpro/latest/3.5" target="_blank" rel="noopener">Eclipse 3.5 (Galileo)</a>  </li><li><a href="http://dl.google.com/eclipse/inst/d2wbpro/latest/3.4" target="_blank" rel="noopener">Eclipse 3.4 (Ganymede)</a></li></ul><p>具体详见：<a href="http://code.google.com/javadevtools/download-wbpro.html" target="_blank" rel="noopener">http://code.google.com/javadevtools/download-wbpro.html</a></p><h1 id="Window-builder开发介绍文档"><a href="#Window-builder开发介绍文档" class="headerlink" title="Window-builder开发介绍文档"></a>Window-builder开发介绍文档</h1><p>官方在线文档地址：<a href="http://code.google.com/javadevtools/wbpro/index.html" target="_blank" rel="noopener">http://code.google.com/javadevtools/wbpro/index.html</a></p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>使用window-builder快速开发的实验展示demo，熟练的话，差不多半个小时就可以完成。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzc4xns3j30ec08n74z.jpg" alt="window-builder demo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fynz8c4114g306s041746.gif&quot; alt=&quot;windows-builder&quot;&gt;&lt;/p&gt;
&lt;p&gt;在项目要进行最终界面展示开发时，又得回到熟悉而久违的的SWT/JFACE，继而追寻那Eclipse的优秀的&lt;a href=&quot;http://baike.baidu.com/view/6326.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WYSIWYG&lt;/a&gt;插件&lt;a href=&quot;http://code.google.com/javadevtools/wbpro/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WindowBuilder&lt;/a&gt;（没用WB之前都是手工敲代码，并界面排版），却惊喜的发现，不用再漫天搜查注册码，如今WindowBuilder的Java/Ajax工具开发商&lt;a href=&quot;http://www.instantiations.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Instantiations&lt;/a&gt;已经于2010年8月被Google给收购了，WindowBuilder也作为免费工具开放，强大的Google！&lt;/p&gt;
&lt;p&gt;并传闻Google这一收购用意不仅在GWT设计工具，更在于Ajax和Java方面，Google所有网页应用都部署了大量的Ajax，而Android应用则使用Java来创建。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Java" scheme="https://blog.vanjor.com/tags/java/"/>
    
      <category term="Windows Builder" scheme="https://blog.vanjor.com/tags/windows-builder/"/>
    
      <category term="GUI" scheme="https://blog.vanjor.com/tags/gui/"/>
    
  </entry>
  
  <entry>
    <title>Windows常用shell命令大全</title>
    <link href="https://blog.vanjor.com/2010/12/windows-shell-dos-command/"/>
    <id>https://blog.vanjor.com/2010/12/windows-shell-dos-command/</id>
    <published>2010-12-06T07:25:21.000Z</published>
    <updated>2010-12-06T07:25:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于鼠标操作的后果就是OS界面外观发生改变，就得多花学习成本。更主要的是基于界面引导Path与命令行直达速度是难以比拟的。另外Geek很大一部分是键盘控，而非鼠标流的。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0rzdrrgj3072041749.jpg" alt="shell"></p><p>整理Windows的常用Shell命令，一方面帮助深入学习Mysql，另一方面准备尝试过渡到Linux家族来。</p><a id="more"></a><h1 id="Windows下Shell命令概述"><a href="#Windows下Shell命令概述" class="headerlink" title="Windows下Shell命令概述"></a>Windows下Shell命令概述</h1><p>Windows的Shell命令又是Windows的CMD命令。而cmd命令又是原来MS-DOS系统保留下来。</p><h2 id="Shell来源路径与配置"><a href="#Shell来源路径与配置" class="headerlink" title="Shell来源路径与配置"></a>Shell来源路径与配置</h2><p>对应的命令资源配置在windows的环境变量中：</p><p>Windows Shell命令是基于配置好的Path环境变量，对Shell命令在Path路径中依次从前至后搜寻到对应命名的可执行入口。</p><p>也就是可以自行编写一些Shell程序，C、Java、Perl等等，然后配置到环境变量中，就可以有自己的私有Shell命令了。大多数默认的Shell命令对应目标程序打多在“C:\Windows\”及“C:\Windows\System32”目录下。而基于Windows的一些应用程序（如Mysql）都会向Windows的Path中配置添加自己的目录。</p><h2 id="Shell命令的执行方式"><a href="#Shell命令的执行方式" class="headerlink" title="Shell命令的执行方式"></a>Shell命令的执行方式</h2><ul><li>一般的是通过调出CMD控制台执行</li><li>对于较熟悉的可以自行编写bat批处理Shell命令，然后保存为 .bat 后缀格式文件。</li><li>以Win7为例，可以通过Win键调出search 窗口，快捷执行，但不能全部使用</li><li>同时可以通过Win+R调出运行窗口来执行</li></ul><h1 id="常用Shell程序命令大全"><a href="#常用Shell程序命令大全" class="headerlink" title="常用Shell程序命令大全"></a>常用Shell程序命令大全</h1><p>下面分类列举那些调出Shell命令列表，通过使用对应命令可以大大节约时间：</p><h2 id="Windows常用工具类"><a href="#Windows常用工具类" class="headerlink" title="Windows常用工具类"></a>Windows常用工具类</h2><table><thead><tr><th>运行程序</th><th>运行命令</th></tr></thead><tbody><tr><td>记事本</td><td>notepad</td></tr><tr><td>计算器</td><td>calc</td></tr><tr><td>画图</td><td>mspaint</td></tr><tr><td>写字板</td><td>write</td></tr><tr><td>Windows放大镜</td><td>magnify</td></tr><tr><td>辅助工具管理器</td><td>utilman</td></tr><tr><td>Telnet客户端</td><td>telnet</td></tr><tr><td>任务管理器</td><td>taskmgr</td></tr><tr><td>关闭Windows</td><td>shutdown</td></tr><tr><td>扫描仪与相机</td><td>sticpl.cpl</td></tr><tr><td>远程桌面</td><td>mstsc</td></tr><tr><td>可移动存储</td><td>ntmsmgr.msc</td></tr><tr><td>注册表编辑器</td><td>regedit</td></tr><tr><td>TrueType造字程序</td><td>eudcedit</td></tr><tr><td>打印机文件夹</td><td>printers</td></tr><tr><td>打印机和传真</td><td>control printers</td></tr><tr><td>控制面板</td><td>control</td></tr><tr><td>屏幕键盘</td><td>osk</td></tr><tr><td>网络连接</td><td>ncpa.cpl 或control netconnections</td></tr><tr><td>从Windows注销</td><td>logoff</td></tr><tr><td>字体文件夹</td><td>fonts 或control fonts</td></tr><tr><td>磁盘管理</td><td>diskmgmt.msc</td></tr><tr><td>快速查找</td><td>findfast.cpl</td></tr><tr><td>磁盘碎片整理程序</td><td>dfrg.msc</td></tr><tr><td>磁盘检查工具</td><td>chkdsk</td></tr><tr><td>磁盘清理工具</td><td>cleanmgr</td></tr><tr><td>命令行提示符</td><td>cmd</td></tr><tr><td>剪贴簿查看器</td><td>clipbrd</td></tr><tr><td>辅助功能选项</td><td>access.cpl</td></tr><tr><td>添加硬件向导</td><td>hdwwiz.cpl</td></tr><tr><td>添加或删除程序</td><td>appwiz.cpl</td></tr></tbody></table><h3 id="常用管理配置工具"><a href="#常用管理配置工具" class="headerlink" title="常用管理配置工具"></a>常用管理配置工具</h3><table><thead><tr><th>设备管理器</th><th>devmgmt.msc</th></tr></thead><tbody><tr><td>Direct X控制面板(如果已经安装)</td><td>directx.cpl</td></tr><tr><td>Direct X诊断工具</td><td>dxdiag</td></tr><tr><td>磁盘分区管理器</td><td>diskpart</td></tr><tr><td>显示属性</td><td>desk.cpl 或 control desktop</td></tr><tr><td>文件夹选项</td><td>control folders</td></tr><tr><td>显示属性的外观选项卡</td><td>control color</td></tr><tr><td>文件签名验证</td><td>sigverif</td></tr><tr><td>IP配置实用程序</td><td>ipconfig</td></tr><tr><td>键盘属性</td><td>control keyboard</td></tr><tr><td>鼠标属性</td><td>main.cpl 或 control mouse</td></tr><tr><td>Internet属性</td><td>inetcpl.cpl</td></tr><tr><td>密码属性</td><td>assword.cpl</td></tr><tr><td>电话与调制解调器选项</td><td>telephon.cpl</td></tr><tr><td>电源选项属性</td><td>powercfg.cpl</td></tr><tr><td>性能</td><td>perfmon</td></tr><tr><td>区域和语言选项</td><td>intl.cpl</td></tr><tr><td>系统属性</td><td>sysdm.cpl</td></tr><tr><td>用户帐户管理</td><td>nusrmgr.cpl</td></tr><tr><td>Windows防火墙</td><td>firewall.cpl</td></tr><tr><td>运行Windows更新</td><td>wupdmgr</td></tr><tr><td>系统配置实用程序</td><td>msconfig</td></tr><tr><td>声音和音频设备属性</td><td>mmsys.cpl</td></tr><tr><td>共享文件夹</td><td>fsmgmt.msc</td></tr><tr><td>服务</td><td>services.msc</td></tr><tr><td>Windows安全中心</td><td>wscui.cpl</td></tr><tr><td>任务计划</td><td>control schedtasks</td></tr><tr><td>游戏控制</td><td>joy.cpl</td></tr><tr><td>字符映射表</td><td>charmap</td></tr><tr><td>证书管理控制台</td><td>certmgr.msc</td></tr></tbody></table><h3 id="一些高级配置管理"><a href="#一些高级配置管理" class="headerlink" title="一些高级配置管理"></a>一些高级配置管理</h3><table><thead><tr><th>Windows管理体系结构</th><th>wmimgmt.msc</th></tr></thead><tbody><tr><td>Windows系统安全工具</td><td>syskey</td></tr><tr><td>系统配置编辑器</td><td>sysedit</td></tr><tr><td>策略的结果集</td><td>rsop.msc</td></tr><tr><td>可移动存储</td><td>ntmsmgr.msc</td></tr><tr><td>可移动存储操作请求</td><td>ntmsoprq.msc</td></tr><tr><td>ODBC数据源管理器</td><td>odbccp32.cpl</td></tr><tr><td>本地安全设置</td><td>secpol.msc</td></tr><tr><td>本地用户和组</td><td>lusrmgr.msc</td></tr><tr><td>索引服务</td><td>ciadv.msc</td></tr><tr><td>组策略编辑器</td><td>gpedit.msc</td></tr><tr><td>事件查看器</td><td>eventvwr.msc</td></tr><tr><td>Driver Verifier Manager</td><td>verifier</td></tr><tr><td>Dr. Watson系统诊断工具</td><td>drwtsn32</td></tr></tbody></table><h1 id="一些Shell程序命令详解"><a href="#一些Shell程序命令详解" class="headerlink" title="一些Shell程序命令详解"></a>一些Shell程序命令详解</h1><p>下面围绕第二章节以及更多高级shell操作命令进行详细描述：(陆续根据使用补充)</p><h2 id="网络配置Ipconfig命令"><a href="#网络配置Ipconfig命令" class="headerlink" title="网络配置Ipconfig命令"></a>网络配置Ipconfig命令</h2><p>默认Ipconfig为显示当前网络基本连接信息</p><ul><li>显示连接配置    ipconfig /all</li><li>显示DNS缓存内容    ipconfig /displaydns</li><li>去除DNS缓存内容    ipconfig /flushdns</li><li>释放全部(或指定)适配器的由DHCP分配的动态IP地址)    ipconfig /release</li><li>为全部适配器重新分配IP地址    ipconfig /renew</li><li>刷新DHCP并重新注册DNS   ipconfig /registerdns</li><li>显示DHCP Class ID   ipconfig /showclassid</li><li>修改DHCP Class ID    ipconfig /setclassid</li></ul><h2 id="关机操作shutdown命令"><a href="#关机操作shutdown命令" class="headerlink" title="关机操作shutdown命令"></a>关机操作shutdown命令</h2><p>Shutdown使您能够一次关闭或重新启动一台本地或远程计算机：</p><p>语法:：<br>shutdown [/i | /l | /s | /r | /a | /p | /h | /e] [/f] [/m //computername/] [/t XXX] [/d [p:]XX:YY/c”Comment”]</p><p>参数：</p><ul><li>/i : 显示“远程关机对话框”。/i 选项必须是键入的第一个参数，之后的所有参数都将被忽略。</li><li>/l : 立即注销当前用户，没有超时期限。不能将 /l 与 /m //computername/ 或 /t 一起使用。</li><li>/s : 关闭计算机。</li><li>/r : 关机后重新启动计算机。</li><li>/a : 取消关机操作（仅在超时期限内有效）。a 参数仅可以与 /m //computername/ 一起使用。</li><li>/p : 仅关闭本地计算机（而不是远程计算机），没有超时期或警告。/p 只能和 /d 一起使用。如果您的计算机不支持关闭电源功能，使用 /p 将关闭系统但不会切断您的计算机电源。</li><li>/h : 使本地计算机处于休眠状态（如果已启用休眠）。仅可将 h 与 /f 一起使用。</li><li>/e : 允许在目标计算机上记录意外关机原因。</li><li>/f : 强制关闭正在运行的应用程序而不提前警告用户。</li><li>/t：设置经过过长时间进行当次操作，定时功能，时间单位为秒</li></ul><p>举例：</p><ul><li>立即关机：shutdown -s -t 0</li><li>30秒后重启：shutdown -r -t 30</li><li>取消关机：shutdown -a</li></ul><h2 id="网络连接查看命令netstat"><a href="#网络连接查看命令netstat" class="headerlink" title="网络连接查看命令netstat"></a>网络连接查看命令netstat</h2><ul><li>netstat -a 查看开启了哪些端口,常用netstat -an</li><li>netstat -n 查看端口的网络连接情况，常用netstat -an</li><li>netstat -v 查看正在进行的工作</li><li>netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）</li><li>netstat -s 查看正在使用的所有协议使用情况</li></ul><h2 id="系统网络服务命令net"><a href="#系统网络服务命令net" class="headerlink" title="系统网络服务命令net"></a>系统网络服务命令net</h2><ul><li>netstat -a 查看开启了哪些端口,常用netstat -an</li><li>net use \\ip\ipc$ “ “ /user:” “ 建立IPC空链接</li><li>net use \\ip\ipc$ “密码” /user:”用户名” 建立IPC非空链接</li><li>net use h: \\ip\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:</li><li>net use h: \\ip\c$ 登陆后映射对方C：到本地为H:</li><li>net use \\ip\ipc$ /del 删除IPC链接</li><li>net use h: /del 删除映射对方到本地的为H:的映射</li><li>net user 用户名 密码 /add 建立用户</li><li>net user guest /active:yes 激活guest用户</li><li>net user 查看有哪些用户</li><li>net user 帐户名 查看帐户的属性</li><li>net localgroup administrators 用户名 /add 把”用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数</li><li>net start 查看开启了哪些服务</li><li>net start 服务名 开启服务；(如:net start telnet， net start schedule)</li><li>net stop 服务名 停止某服务</li><li>net time \\目标ip 查看对方时间</li><li>net time \\目标ip /set 设置本地计算机时间与”目标IP”主机的时间同步,加上参数/yes可取消确认信息</li><li>net view 查看本地局域网内开启了哪些共享</li><li>net view \\ip 查看对方局域网内开启了哪些共享</li><li>net config 显示系统网络设置</li><li>net logoff 断开连接的共享</li><li>net pause 服务名 暂停某服务</li><li>net send ip “文本信息” 向对方发信息</li><li>net ver 局域网内正在使用的网络连接类型和信息</li><li>net share 查看本地开启的共享</li><li>net share ipc$ 开启ipc$共享</li><li>net share ipc$ /del 删除ipc$共享</li><li>net share c$ /del 删除C：共享</li><li>net user guest 12345 用guest用户登陆后用将密码改为12345</li><li>net password 密码 更改系统登陆密码</li></ul><h2 id="系统服务命令sc"><a href="#系统服务命令sc" class="headerlink" title="系统服务命令sc"></a>系统服务命令sc</h2><p>SC来控制系统创建服务和管理服务。</p><p>SC使用这样的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc &lt;server&gt; \[command\] \[service name\] &lt;option1&gt; &lt;option2&gt;...</span><br></pre></td></tr></table></figure><p>下面介绍各种参数。</p><ol><li>server ：可选，可以使用双斜线，如myserver，也可以是192.168.0.1来操作远程计算机。如果在本地计算机上操作就不用添加任何参数。</li><li>command：下面列出SC可以使用的命令<ul><li>config—-改变一个服务的配置。（长久的）</li><li>continue–对一个服务送出一个继续控制的要求。</li><li>control—-对一个服务送出一个控制。</li><li>create—-创建一个服务。（增加到注册表中）</li><li>delete—-删除一个服务。（从注册表中删除）</li><li>EnumDepend–列举服务的从属关系。</li><li>GetDisplayName–获得一个服务的显示名称。</li><li>GetKeyName–获得一个服务的服务键名。</li><li>interrogate–对一个服务送出一个询问控制要求。</li><li>pause—-对一个服务送出一个暂停控制要求。</li><li>qc—-询问一个服务的配置。</li><li>query—-询问一个服务的状态，也可以列举服务的状态类型。</li><li>start—-启动一个服务。</li><li>stop—-对一个服务送出一个停止的要求。</li></ul></li><li>service name：在注册表中为service key制定的名称。注意这个名称是不同于显示名称的（这个名称可以用net start和服务控制面板看到），而SC是使用服务键名来鉴别服务的。</li></ol><p>特别说明：<strong>SC create</strong>子命令<br>这个命令可以在注册表和服务控制管理数据库建立一个入口。使用语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> sc &lt;server&gt; create \[service name\] \[binPath= \] &lt;option1&gt; &lt;option2&gt;...</span><br></pre></td></tr></table></figure><p>这里的servername，servicename，optionname，optionvalues和上面的一样，这里就option描述，通常为键值对应：option name = option values 。</p><p>注：键值对应 name= value，等号后面应由一个空格，不能省略</p><p><strong>option</strong>详细描述如下：</p><ul><li>type=—-own, share, interact, kernel, filesys<br>  关于建立服务的类型，选项值包括驱动程序使用的类型，默认是share。</li><li>start=—-boot, sys tem, auto, demand, disabled<br>  关于启动服务的类型，选项值包括驱动程序使用的类型，默认是demand（手动）。</li><li>error=—-normal, severe, critical, ignore<br>  当服务在导入失败错误的严重性，默认是normal。</li><li>binPath=–(string)<br>  服务二进制文件的路径名，这里没有默认值，这个字符串是必须设置的。</li><li>group=—-(string)<br>  这个服务属于的组，这个组的列表保存在注册表中的ServiceGroupOrder下。默认是nothing。</li><li>tag=—-(string)<br>  如果这个字符串被设置为yes，sc可以从CreateService call中得到一个tagId。然而，SC并不显示这个标签，所以使用这个没有多少意义。默认是nothing</li><li>depend=—-(space separated string)有空格的字符串。<br>  在这个服务启动前必须启动的服务的名称或者是组。</li><li>obj=—-(string)<br>  账号运行使用的名称，也可以说是登陆身份。默认是localsys tem</li><li>Displayname=–(string)<br>  一个为在用户界面程序中鉴别各个服务使用的字符串。</li><li>password=–(string)<br>  一个密码，如果一个不同于localsys tem的账号使用时需要使用这个。</li><li>Optionvalues<br>  Optionname参数名称的数值列表。参考optionname。当我们输入一个字符串时，如果输入一个空的引用这意味着一个空的字符串将被导入。</li></ul><p>举例说明：在一台叫做（myserver）的计算机上为一个叫“NewService”的服务建立的一个注册表登记，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc myserver create MyService binpath= C:\\NewServ.exe</span><br></pre></td></tr></table></figure><p>待补充</p><p>参考：</p><ol><li><a href="http://tech.sina.com.cn/s/2006-04-27/0909920026.shtml" target="_blank" rel="noopener">http://tech.sina.com.cn/s/2006-04-27/0909920026.shtml</a></li><li><a href="http://yimok.f31.net/archives/2007/29711.shtml" target="_blank" rel="noopener">http://yimok.f31.net/archives/2007/29711.shtml</a></li><li><a href="http://wuhua.javaeye.com/blog/32374" target="_blank" rel="noopener">http://wuhua.javaeye.com/blog/32374</a></li><li><a href="http://blog.csdn.net/lryain/archive/2008/01/04/2026058.aspx" target="_blank" rel="noopener">http://blog.csdn.net/lryain/archive/2008/01/04/2026058.aspx</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于鼠标操作的后果就是OS界面外观发生改变，就得多花学习成本。更主要的是基于界面引导Path与命令行直达速度是难以比拟的。另外Geek很大一部分是键盘控，而非鼠标流的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyo0rzdrrgj3072041749.jpg&quot; alt=&quot;shell&quot;&gt;&lt;/p&gt;
&lt;p&gt;整理Windows的常用Shell命令，一方面帮助深入学习Mysql，另一方面准备尝试过渡到Linux家族来。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Windows" scheme="https://blog.vanjor.com/tags/windows/"/>
    
      <category term="Shell" scheme="https://blog.vanjor.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>英文论文缩写</title>
    <link href="https://blog.vanjor.com/2010/12/some-abbrs-for-english/"/>
    <id>https://blog.vanjor.com/2010/12/some-abbrs-for-english/</id>
    <published>2010-12-05T07:01:37.000Z</published>
    <updated>2010-12-05T07:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看英文论文，总结一部分平时可能误用到的英文缩写，如i.e.与e.g.及etc.做一点总结，并做个小分析。</p><a id="more"></a><h1 id="i-e-与e-g-及etc-的区别"><a href="#i-e-与e-g-及etc-的区别" class="headerlink" title="i.e.与e.g.及etc.的区别"></a>i.e.与e.g.及etc.的区别</h1><p>首先简要说明各自的含义：</p><ul><li><strong>i.e.</strong>  -&gt; 约同于“<strong>that is</strong>“，对应中文”<strong>也就是</strong>“的意思</li><li><strong>e.g.</strong> -&gt; 约同于”<strong>for example</strong>“，对应中文”<strong>例如</strong>“的意思</li><li><strong>etc.</strong> -&gt; 约同于”<strong>and so on</strong>“，对用中文”<strong>等等</strong>“的意思</li></ul><p>具体来说：</p><ul><li>i.e. 是拉丁文 “ id est” 的缩写，它的意思就是“那就是说，换句话说”，等同于“that is，in other words” ，<strong>目的是用来进一步解释前面所说的观点</strong>。</li><li>e.g. 是拉丁文 “ exempli gratia “ 的缩写，它的意思是“举个例子，比如”，等同与“for example”,<strong>目的就是用几个例子来说明前面的观点。</strong></li><li>etc. 是英文 “etcetera” 的缩写，意思是“以及其他，等等”，相当于“and so on”，<strong>目的用来表示省略更多。</strong></li></ul><p>使用注意事项：</p><ul><li>e.g. 和 etc. 不能出现在同一句话中，因为 e.g. 是表示泛泛的举几个例子，并没有囊括所有的实例，其中就已经包含“等等”，如果再加一个 etc. 就画蛇添足了；</li><li>用它们的时候，都不要把“小点”给省略掉。</li></ul><h1 id="英文与中文对事物描述思维的差异"><a href="#英文与中文对事物描述思维的差异" class="headerlink" title="英文与中文对事物描述思维的差异"></a>英文与中文对事物描述思维的差异</h1><p>也顺便mark下在翻译论文再一次感受到一些差异，英文中对于一个事物事件描写，通常是从小到大来表述的，也就是通常首先说明目标事物，然后再对目标事物作出特征性限定描述，这个差异也直接影响了目前阅读英文的速度。</p><p>例如：</p><blockquote><p>Where have you put the green apples where I brought for u from the supermarket nearby the subway？</p></blockquote><p>对应中文的意思是：</p><blockquote><p>你把我昨天从地铁旁边那个超市给你买的青苹果放到哪里了？</p></blockquote><p>用红色标注语句的核心主体事物”青苹果“，而对应的特征限制”我昨天从地铁旁边那个超市给你买的“，英文中通常放置在主体的后面，而中文放置在前面。这个也可从英文中存在大量的界定词”of，which，where，by，for，from”等。</p><p>这一思维差异也很强烈的反应在中英文对与地址的描述的截然相反的顺序上：</p><p>例如：</p><blockquote><p>北京海淀区西土城路10号物联大厦10楼916号</p></blockquote><p>对应英文的地址确应该是：</p><blockquote><p>No.916，Wulian Plaza , No.10 , Xitucheng Road , Haidian District，Beijing</p></blockquote><p>中文地址由范围大到小最后锁定，英文地址范围由小到大，先锁定最终目标，然后描述它的范围特征。</p><p>因而，中英文在事物描述思路图差异如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0qi5uooj309u07rglr.jpg" alt="chinese english mind different"></p><p>其他的还有一些留心可以发现的差异：</p><p>例如：</p><blockquote><p>A：“You’re not feeling good，are you？” 你好像不太舒服，是么？<br>B：“Yes，I am．”                                     不，我很好。<br>     （or:“No，I am not．”）                    (或： 是的，有点）</p></blockquote><p>背后原因在：中国人对别人的问话，总是以肯定或否定对方的话来确定用“对”或者“不对”，英语中，对别人的问话，总是依据事实结果的肯定或否定用“Yes”或者“No”。</p><p>更多的一些有趣的差异详见：<a href="http://dongxi.net/b03dL" target="_blank" rel="noopener">英汉文化十大常见差异</a></p><p>参考：</p><ol><li><a href="http://blog.ednchina.com/ic_net66/43177/message.aspx" target="_blank" rel="noopener">http://blog.ednchina.com/ic_net66/43177/message.aspx</a></li><li><a href="http://www.meryl.net/2005/12/11/ie-etc-and-eg/" target="_blank" rel="noopener">http://www.meryl.net/2005/12/11/ie-etc-and-eg/</a></li><li><a href="http://dongxi.net/b03dL" title="http://dongxi.net/b03dL" target="_blank" rel="noopener">http://dongxi.net/b03dL</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看英文论文，总结一部分平时可能误用到的英文缩写，如i.e.与e.g.及etc.做一点总结，并做个小分析。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="English" scheme="https://blog.vanjor.com/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>评论潜在方面观点计算</title>
    <link href="https://blog.vanjor.com/2010/12/latent-aspect-rating-analysis/"/>
    <id>https://blog.vanjor.com/2010/12/latent-aspect-rating-analysis/</id>
    <published>2010-12-03T19:46:23.000Z</published>
    <updated>2010-12-03T19:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo032faiwj306s046t8u.jpg" alt="lara"></p><p>本文为国外09年的最新文本挖掘类别论文：</p><p>原文：Latent Aspect Rating Analysis on Review Text Data: A Rating Regression Approach</p><p>链接：<a href="http://scholar.google.com.hk/scholar?q=Latent+Aspect+Rating+Analysis+on+Review+Text+Data:+A+Rating+Regression+Approach&amp;hl=zh-CN&amp;btnG=%E6%90%9C%E7%B4%A2&amp;lr=" target="_blank" rel="noopener">原文Paper</a>，<a href="http://sifaka.cs.uiuc.edu/~wang296/paper/hongning-KDD10-v2.pptx" target="_blank" rel="noopener">展示PPT</a></p><p>个人三天时间完整翻译而成，本文对于理解话题识别，用户潜在观点挖掘，情感计算方面都有很好的借鉴意义。</p><p>目前在用户观点情感挖掘方面属于一个十分前沿的话题，广泛应用在产品研究，用户行为分析，推荐系统上。比现行的许多基于文本分类论文都是更为细致的研究，本文中大量运用统计概率学方面知识对话题识别，情感词的渐进识别，权重推断，以及结果估计验证，与应用探讨，值得深入学习。</p><p>个人认为一个最重要的不足的是，论文中还是主要通过挖掘文本中词语间的关联，类似tf/idf词频统计，先验概率推断等进行文本挖掘分析，而对于语义的理解，句法的解读分析仍然没有考虑在内，这样必然导致结果仍然存在很多偏差与误判，而鉴于语义理解，句法分析尚属一个十分困难的前沿研究领域。文本尤为可佳。</p><a id="more"></a><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在本文，定义观点评估分析（LARA： Latent Aspect Rating Analysis）问题并针对含有观点意见的文本进行分析。 旨在分析在线评论中的实体，基于话题方面（topical aspects）来挖掘每个评论者在实体的每一个方面(Aspect)的潜在观点，以及分析不同方面对于评价者形成关于实体的总体评价所占权重。我们提出一种新颖概率回归评估模型来尝试以通法来解决这类文本挖掘问题。</p><p>基于酒店评论数据的经验分析实验表明这种提论可以有效的解决 LARA 问题，并且基于评论的具体挖掘与分析具有广泛的应用价值，包括类别观点概括，基于方面的实体评分，分析评论者评分表现行为。</p><ul><li><strong>分类：</strong>信息搜索与检索：文本挖掘（<em>Text Mining</em>）</li><li><strong>主要形式：</strong>算法，实验</li><li><strong>关键词：</strong>意见与情感分析（<em>Opinion and sentiment analysis</em>），评论挖掘（<em>Review mining</em>），潜在评估分析（<em>Latent rating analysis</em>）</li></ul><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>随着 Web2.0 的发展，越来越多的人可以对各种各样的产品和服务自由的表达观点，这些评论信息对于其他用户做出决策以及产品服务的改进具有很大价值。然而，随着评论信息快速增长，海量的信息让用户难以快速查找到所需要的信息，很多工作就是来减轻这个评价文本信息抽取的问题[18,16,26],提炼总结用户的观点，根据意见的极性分类[20,6,7],并从评论中抽取相应的观点句。尽管如此，在现有的技术下，用户仍然难以方便的从海量的评论信息中挖掘与发现信息，来支撑实体主题方面的观点。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzf0co6cj30dg05kt94.jpg" alt="lara"></p><p>以一个典型的酒店评价信息为例，如上图（1） ，这个评论信息涉及到了酒店的多个方面特点，包括价格，房屋条件以及服务，但是评论者只给出了宾馆的总体评分，没有提供每个单独方面的评分，其他用户就难以方便的了解到这个评论者在方面上的评级（<em>latent rating</em>）。透过整体评价进一步挖掘每一方面的评价是十分重要的，因为不同的评论者对于同一家酒店会有相同的总体评价，但是因为不同的方面原因。比如：一个评论者可能喜欢酒店的位置，另一个喜欢房间条件。</p><p>为了帮助用户发现这些不同，十分有必要挖掘并分析评论者在酒店的几个大的方面上的评级。此外，即使我们可以挖掘发现方面上的评价信息诸如“价格”，但仍然不够充分，因为“便宜”对于不同评论者有着不同的价格标准。而且及时同一个评论者可能因为其他方面的条件因素的诉求高低不同，而对”便宜”产生的不同的标准。为了理解如此微妙的差别，十分有必要挖掘发现评价者每一方面的评价与总体评价之间的权重关系。</p><p>为了进行对评论的更深入具体的的理解，我们尝试来研究这种新颖的文本挖掘问题 (LARA).</p><blockquote><p><strong>LARA任务目的： 给定一个含有总体评价信息的评论数据集，LARA旨在分析每个评论在不同话题方面的评论信息，来挖掘个体用户在每一个方面上的评级，以及不同的方面的评级对于形成总体评级的权重大小。</strong></p></blockquote><p>LARA的广泛应用价值表现在：潜在方面的评级（aspect rating）可以用来进行面向方面的意见概述；每个方面的权重（aspect weight）可以方便于分析用户的评分行为；潜在方面评价与方面评分权重可以作为实体的个性化面向方面级别评估 - 通过汇集在对应方面具有相同权重的偏好的评论的评价信息。</p><p>现有的观点概括工作将 LARA 问题挖掘到一定程度，尚没有人在单个评论在方面层级上的潜在评价信息挖掘做过研究，也没有人考虑挖掘评论者在方面上的评级与总体评级间的权重关系。</p><p>在尝试解决这个新型文本挖掘时，我们提出一种基于新颖潜在评价回归模型的两阶段处理模型（<em>a novel latent rating regression model</em>）。</p><ol><li><strong>第一阶段</strong>: 我们采用 自引导算法（<em>bootstrapping-based algorithm</em>）来确定主要的方面（通过一些方面的特征词语做指引学习），并将评论集分段切割处理。</li><li><strong>第二阶段</strong>: 我们提出一个通用潜在评价回归模型（LRR：<em>Latent Rating Regression</em>），旨在通过分析每个评论的文本与对应评论的总体评级数据信息，来确定每个评论的方面的评级与权重。</li></ol><p>更具体的说：<strong>LRR 的基本思想 就是假定总体评价完全产生来自于每个方面的潜在评级的有权重的组合。</strong></p><p>而且我们假定每个方面的潜在评级取决于对应评价中的讨论涉及到这一方面的文本片段。换句话说，我们将挖掘这些方面的潜在评级演化为一组特性词语的权重组合，这些词语权重对应为情感极性(Sentimental Polarities)。而因为我们无法直接观察到每一个方面的评级数据，所以这个回归模型的输出 - 响应结果是挖掘潜在的信息。</p><p>我们基于从TripAdviser (<a href="http://www.tripadvisor.com" target="_blank" rel="noopener">www.tripadvisor.com</a>)爬取到的一组酒店评价数据集来评估 LRR 模型。实现结果表明 LRR 模型可以有效的从对应评价的总体评级中分析挖掘出方面上的评级，以及发现这些评论者者对于每个方面的评级相对于总体评级的权重。我们也将展示 LRR 模型中所分析到的结果说支持的不同应用，包括方面观点概括，个性化实体评级排序以及评论者的评级行为表现。</p><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>在我们目前的调研中，还没有人做出关于LARA问题的研究，不过有些相关的工作。</p><p>分析评价文本的总体情感观点已经被广泛的研究。相关的研究基于文本的积极与消极的二元分类[6,7,20,5,14]。随后，这个定义被延伸到多元评级模型[10,9]。并且有提出的解决途径，包括监督，无监督，以及半监督的方法，但是他们都是尝试预测总体情感分类与评级，没有对潜在方面观点进行挖掘。</p><p>由于在线评论经常包含多个方面的的评价意见，一些近来工作开始挖掘基于方面层次的评级，来代替简单的总体评级。比如，Snyder et al.[23] 对于多元方面的建模，使用好的可信算法（<em>good grief algorithm</em>）可以改善对方面评级的预测。在[24]中，Titov et al. 尝试同时进行评论方面抽取与对应的评级计算：他们使用话题来描述方面，并且通过一个基于事实评级（ground-truth ratings）的回归模型。尽管如此，他们假定方面上的评级是明确包含在说提供的训练数据中。于此不同的是，我们假定方面评级是潜在的，并且是更普遍并面向现实场景的。</p><p>概括（<em>Summarization</em>）是一个十分广泛有用的应对信息过载的技术。一个最近的人类评估（<em>human evaluation</em>）[15] 指出情感与情绪概括具有很强的个体偏好性，相比于非情感方面，提出了情感建模以及方面观点概括的重要性。仍然，现有的基于方面的观点概括工作[10,21,18,26]只是目标停留在从评论集中聚合和展示话题上每个方面的主流观点。虽然聚合观点可以展现话题的概况信息，却导致个体评论的细节信息的丢失；此外，评论/评价者间的不同特性也没有在分析考虑范围内，这样情感的聚合是基于不同习性偏好的评论者间。Lu et al.[17]最近的一项工作是最接近于我们的，但是他们的目标仍然是从总体评级生成方面评级上的聚合概要。更为重要的是，没有已做工作考虑到评论者在不同方面上的强调程度的差异。</p><h1 id="三、问题定义"><a href="#三、问题定义" class="headerlink" title="三、问题定义"></a>三、问题定义</h1><p>在本章节里，我们规范定义潜在观点评级挖掘（LARA：<em>Latent Aspect Rating Analysis</em>）问题。划归为一个可计算的问题：</p><p><strong>LARA定义输入</strong>：一些有价值实体（如:酒店）的一组评价数据集，并且每一条评价数据都有对应的总体评级信息（这些数据在现在的web2.0中广泛存在，中国的如时光网中电影的评论，大众点评）</p><p><strong>公式化定义</strong>：假定  D={d1 , d2  , …，d|D|}  作为一个实体（entity）或话题（topic）的一组评论文本集，并且每个评论文本 d∈D 都关联一个总体评级 <strong>rd</strong> 。我们也假定有一个含有 n 个互异的词汇集V={w1 ,w2 , …, wn } 。</p><p><strong>定义：总体评级(<em>Overall Rating</em>)</strong></p><blockquote><p>一个评价文本 <strong>d</strong> 总体评级 <strong>rd</strong> 是按级别的量化数值，也就是 rd∈[rmin , rmax]，其中<strong>rmin</strong>和  <strong>rmax</strong> 是评级的最大值与最小值。</p></blockquote><p>最后我们假定我们已经知道给定 <strong>k</strong> 方面类别，并且每个方面评级都潜在影响给定话题的总体评级。例如：对于酒店的评级，可能的方面将包括“价格”和“位置”。每个方面都通过一组关键词界定关联，作为 LARA 问题的基础。</p><p><strong>定义：方面 (<em>Aspect</em>)</strong></p><blockquote><p>一个方面 <strong>Ai</strong> ，并包含有评论中一组能对评级产生影响的描述词（通常数目不大）。</p></blockquote><p>比如：词“price”，“value”和“worth”可以作为酒店实体的价格这个方面的特征词。我们把一个方面记做 <strong>Ai = { w|w∈V, A(w)=i}</strong> ,其中 A( . ) 是一个从词（word）到（aspect）的映射函数。</p><p><strong>定义：方面权重（<em>Acpect Weights</em>）</strong></p><blockquote><p>方面权重 <strong>αd</strong> 是一个 <strong>k</strong> 维向量，并且对于每一维 - 如第 <strong>i</strong> 维是一个数字量化刻度，指明对应评论文本 d 中的在方面 <strong>Ai</strong> 上的权重。</p></blockquote><p>我们定义αdi ∈[0,1] ，且∑i=1k αdi =1 使得权重更加容易理解并且在评论集中具有更好的可比性。一个高的权重意味对应方面的具有更加重要的强调与偏好。</p><p><strong>定义：潜在观点评级分析（<em>Latent Aspect Rating Analysis</em> (LARA))</strong></p><blockquote><p>给定一个关于话题 <strong>T</strong> 的评论集 <strong>D</strong> ，每个 评论 <strong>d</strong> 关联对应的总体评级 <strong>rd</strong> ，并且话题 <strong>T</strong> 涵盖 <strong>k</strong> 个待分析方面 {A1 , A2  , …，Ak} ，LRAR 问题目标在发现每个独立的评论文本在  <strong>k</strong>维方面的每一方面的评级 <strong>s**</strong>di<strong> ，以及对应的方面上的权重 **</strong>α<strong>di</strong></p></blockquote><p>LARA 问题也包含发现那些可能存在的未知方面，并挖掘潜在方面评级/权重的工作。在本篇论文中，我们假定，对某个实体（<em>entity</em>）类型的每一个方面都有一些关键词描述特征。这个假设对于任何实体类型都具有很好现实可操作性，它的寄语人工标注主要方面特性是可行的；另外，这种初始化模式让用户能够灵活控制他所想要分析的方面。</p><h1 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h1><p>LARA 问题的一个主要挑战在于，对于每个方面的评级，我们没有详细的监督学习方法，即使我们有对应方面的一组特征关键词。另一个挑战在于如何发现方面的权重。为了解决这些问题，我们提出LRR 模型，并且假定评论者对于实体的总体评级完全取决于他对于每个方面的潜在评级的权重聚合，以及每个方面的评级取决于他的评论中对应含有的一组具有权重的描述词。</p><p>在对这些评论数据采用这个二折回归模型后，我们便可以获取潜在方面评级与权重，以此解决LARA 问题。</p><p>因为 LRR 模型中界定了评论中初始词语集与方面的对应关系是已知的，我们按照给定的描述方面关键词对一个评论的基于方面进行分割，以此为每个方面提取对应的切割后的评论文本片段。这样，我们的总体方法包括两阶段，将在之后作详细介绍:</p><h2 id="4-1-基于方面的文本分割"><a href="#4-1-基于方面的文本分割" class="headerlink" title="4.1 基于方面的文本分割"></a>4.1 基于方面的文本分割</h2><p>第一步的目标是将评论中的句子与对应的方面建立映射关系。由于我们假定只有少部分的方面描述关键词指定出，我们设计出 自启动算法来为每个方面获取更多关联词语。</p><p>--------------------------------------------------------------------------------------</p><p>算法 : 基于方面的文本分割算法（<em>Aspect Segmentation Algorithm</em>）</p><p>--------------------------------------------------------------------------------------</p><ul><li><strong>输入：</strong>一个评论集合D={d1 , d2  , …，d|D|}  ，一组方面的关键词={T1 , T2  , …，Tk}，词汇表V，选定界限值 <strong>p</strong> 以及 迭代步骤上限 <strong>I</strong> .</li><li><strong>输出：</strong>评论集按照方面分割的句子组。</li><li><strong>步骤 0：</strong>把所有评论分割为句子，X={x1 , x2  , …，xM}；</li><li><strong>步骤 1：</strong>在每个句子 X 中匹配出方面关键词，并为每个记录匹配命中 i 计数 Count( i )；</li><li><strong>步骤 2：</strong>为句子与对应方面建立标记 αi =argmaxi Count( i ) 。如果得出有多个 i 值，则将对应句子关联到多个方面。【<strong>注：<a href="http://en.wikipedia.org/wiki/Arg_max" target="_blank" rel="noopener">argmax</a></strong>条件参数，αi 为使得Count( i )最大时的 i 值】</li><li><strong>步骤 3：</strong>对词汇表集合 V 中的每个词语计算 χ2 ；</li><li><strong>步骤 4：</strong>对与每个方面的词语按照计算出的 χ2 进行排序，并将前 p 个单词 加入到对应方面关键词集合 Ti 中；</li><li><strong>步骤 5：</strong>如果方面关键词不再变化，或迭代步数超过 I ，则转到 步骤 6 ，否则回到 步骤 1；</li><li><strong>步骤 6：</strong>输出带有方面标识的句子集合。</li></ul><p>--------------------------------------------------------------------------------------</p><p>具体来说，基于方面的文本分割算法 基本工作流程如下：给定每个方面的一组种子关键词 以及 所有评论文本作为输入，我们假定每个句子与对应方面共享一个最大量的形式重叠；基于这个初始方面标注，我们通过卡方统计（<em>Chi-Square</em> (χ2)）计算每个方面与词语的独立性，并将具有高独立性的词语加入到对应方面关键词列表中。这些步骤被重复执行知道方面关键词列表集收敛不在变化或者超出最大迭代步数。</p><p><strong>词语 w 与 方面 Ai 的独立性计算量 χ2 定义如下</strong>:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzk9ro9yj30dg01e0sl.jpg" alt="LARA"></p><p>其中:</p><ul><li>C1 为归属方面 Ai 的句子集中出现 w 次数总和</li><li>C2 为 <strong>不</strong> 归属方面 Ai 的句子集中 w 出现次数总和</li><li>C3 为归属方面 Ai 而没有包含 w 的句子集的 句子数目</li><li>C4 为 既 <strong>不</strong> 归属方面  Ai <strong>又</strong>没有包含 w 的句子集的 句子数目</li><li>C 为 w 在所有句子集中出现的总数 （C?）</li></ul><p>【思想类似于标准文本统计tf/idf】</p><p>在基于方面的文本分割后，我们可以得到对于每个评论 d 的 k 元分割子集，表示为 k × n 特性矩阵 Wd ，其中<strong>Wdij</strong> 是关键词 wj 在文本标记为方面Ai 上的频度（以对应方面的词语总数作为分母来标准化这个频度）。</p><h2 id="4-2-潜在观点评级回归模型（LRR）"><a href="#4-2-潜在观点评级回归模型（LRR）" class="headerlink" title="4.2 潜在观点评级回归模型（LRR）"></a>4.2 潜在观点评级回归模型（LRR）</h2><p>第二个环节是基于为文本按方面的分割后的延续，我们采用一种新颖的潜在观点评级回归（LRR）模型来同时分析方面评级 sd 与 方面评级权重 αd 。</p><h3 id="4-2-1-泛化假设（The-Generation-Assumption）"><a href="#4-2-1-泛化假设（The-Generation-Assumption）" class="headerlink" title="4.2.1 泛化假设（The Generation Assumption）"></a>4.2.1 泛化假设（The Generation Assumption）</h3><p>我们假设评价者的评级行为如下：</p><ul><li>为了形成一篇观点性的评论，评价者首先需要决定哪些方面她需要做出评论；</li><li>然后对于每个选定方面，评价者仔细的选择词语来表达她的观点。</li><li>评价者是基于她为所评论到的每一个方面所采用的情感词语进行评级。</li><li>最后评价者为实体进行总体评级，基于她所评论的方面按权重的加权聚合结果，这些权重反应了她在各自方面的强调重视程度。</li></ul><h3 id="4-2-2-LRR-模型"><a href="#4-2-2-LRR-模型" class="headerlink" title="4.2.2 LRR 模型"></a>4.2.2 LRR 模型</h3><p>LRR 模型是一个回归模型包含如下通用步骤：</p><p>对于基于方面分割后的评论文本，对于每个评论 d ，我们有一个频度矩阵 Wd 一个标准化的方面词频矩阵。 LRR 模型将 Wd 作为独立变量集（比如：评论 d 的特性），把对应总体评级 r 作为响应变量（比如：待预测变量）</p><p>为了进行不同方面的评级与权重建模，LRR模型进一步假定总体评级不是直接由词频特性决定，而是基于一组在潜在方面上的评级所决定，而这些潜在方面上的评级又直接的由词频特性所决定。</p><p>我们定义过，sd 和 αd 是一个 k 维方面对应的 权重向量  和方面评级向量。评价者对于文评价文本 d 会假定 先为每个方面 Ai 做出评级，基于线性组合 Wdi 和 βi ,比如下：公式(1)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzlehycsj304v01sdfm.jpg" alt="lara"></p><p>其中 βi ∈ R 暗示词语在对应方面Ai 的情感极性。</p><p>随后，这个评论者可以通过 sd 和 αd 的权重和来形成对实体的总体评价。</p><p>也就是：<img src="https://asset.vanjor.com/images/006tNbRwly1fynzlswpftj305900x3ya.jpg" alt="lara"></p><p>总体评级假定是一个采样服从高斯分布（<em>Gaussian distribution</em>），以αdTsd 和变量δ2 ,可以从这推断总体评级预测的不确定性。将这些汇合，我们得到如下公式(2)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzm52sfkj307j01sglf.jpg" alt="lara"></p><p>直观的核心思想是通过潜在观点权重 αd  与情感词权重 β ，为可观察到的总体评级与具体的文本描述建立关联，使得我们可以建立基于具体方面评级与总体评级关联模型。</p><p>进一步的观察评级行为，我们发现评价者在不同方面强调程度是一个复杂的行为：不同的评价者可能对不同方面就有不同的偏好程度，例如商业旅行者可能着重考虑互联网接入服务，相对正在度蜜月的夫妇可来说可能更加注重房屋环境。</p><p>方面之间不是独立的，尤其当方面之间有重叠，例如一个强调清洁（cleanliness aspect）的也可能表示偏向于间（room apect）</p><p>为了考虑评价者偏好的差异性，我们考虑每个评价文本 d 的方面权重 αd 作为从整个语料库的先验分布中产生一组随机变量。</p><p>接下来，为了计算不同方面的独立性，我们采用多变量的高斯分布（<em>Multivariate<br>Gaussian Distribution</em>）作为先验方面权重, 也就是如下公式(3)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzmknfu7j3043014we9.jpg" alt="lara"></p><p>其中 μ 与 ∑ 是平均值与方差参数。</p><p>结合公式(2)(3)，我们的得到贝叶斯回归问题，在给定评论中应用LRR模型后，总体评级的可能性为：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzmpdh4qj30dg02ka9z.jpg" alt="lara"></p><p>其中 rd 与 Wd 为评论文本 d 中可观察到的数据，θ =(μ，∑，σ2，β) 是一组基于语料库级别的模型参数。αd 是评论文本 d 潜在方面权重。注意到我们假定 σ2 与 β 不依赖于单个的评论者，同时它们也是语料库级别的模型参数。LRR 的一种图形化模型见下图(3)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzn7wm49j30b805qmx4.jpg" alt="lara"></p><p>图3：LRR图形化表示，外盒代表评论集，内盒代表单个评论文本的潜在观点评级和词语描述的组成。</p><p>假定我们已经有给定 LRR 模型参数 θ =(μ，∑，σ2，β) ，可以应用这个模型计算出每个评论文本的潜在观点评级与权重，步骤如下：</p><p>(1) 在给定评论文本 d 中的潜在观点评级sd 可以按照 公式(1) 进行计算；</p><p>(2) 我们采用最大后验证概率 (MAP：<em>Maximum a posteriori</em>）来计算评论文本中最可能的值 αd 。</p><p>评论文本d 的目标估计MAP函数定义为：公式(5)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynznjpnmej30bw01s745.jpg" alt="lara"></p><p>我们希望扩展这个公式，并为每个评论文本（记作_L_( ad )）关联这个所有方面的特征词 (terms) 到 αd 中,如下公式（6）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynznsxhn3j30dg028wed.jpg" alt="lara"></p><p>其中做出代换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∑i=1k αdi = 1;  0&lt;=αdi &lt;=1 , i=1,2,....,k</span><br></pre></td></tr></table></figure><p>为了以下约束非线性优优化问题，我们应用conjugate-gradient-interior-point 方法，采用如下公式，对 αd 求倒数。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzo3235zj30cl01q3yd.jpg" alt="lara"></p><h4 id="4-2-3-讨论"><a href="#4-2-3-讨论" class="headerlink" title="4.2.3 讨论"></a>4.2.3 讨论</h4><p>LRR 既不是一个纯粹的监督模型也不是一个纯粹的无监督模型，但是它包含了一些已经已知的监督与无监督模型。</p><p>一方面，对于它的目标函数，LRR与监督回归模型类似，都是用来适应可观察到的总体评级（见 公式（2））。尽管如此，不同于一个通常的监督模型，LRR 没有为一个评论的总体评级建立学习预测模型；反而，在LRR 中，我们更加感兴趣于从可观察到的总体评级中推断分析出潜在方面评级与权重（虽然 LRR 可以用来预测总体评级）。从另外一方面来说，通过公式（1），包含另外一个回归模型(一方面评级作为响应变量)，而方面评级又不是可以直接观测到的，这样，唯一的监督在于我们有总体评级这个已有指标，并且我们假定他是这些方面评级的权重总和。这是我们 LRR 模型与传统监督回归模型的最大区别。</p><p>另外一方面，LRR模型也具有类似于无监督方法的特点，在于我们不需要训练集包含有方面评级数据，并且我们可以推断出这些潜在方面评级。具体来说，要分析一组评论集的潜在方面评级，我们首先需要为数据集找到最优模型参数集 θ =(μ，∑，σ2，β) ，然后运用这些参数预测潜在观点评级 αd , 另外，当加入新数据，我们需要对应更新这些参数集。然而，LRR 也不是一个传统的无监督方法，因为我们有从总体评级中的间接监督。</p><p>将我们的LRR模型与标准的话题模型做比较同样十分有趣，例如LDA[2]，在LDA模型中，我们对于那些能够刻画话题的潜在词语分布感兴趣，在 LRR 中，我们尝试发现能够的能刻画语言模型的关联方面评级的词语权重。这两个模型的一个有意义的区别在于 LDA 是完全无监督的，而 LRR 是半监督：虽然我们没有对每个方面的评级做出直接监督，而总体评级对于方面评级做出限制使得我们可以间接监督。</p><h3 id="4-3-LRR-模型估计"><a href="#4-3-LRR-模型估计" class="headerlink" title="4.3 LRR 模型估计"></a>4.3 LRR 模型估计</h3><p>在之前的章节里，我们讨论了如何通过 θ =(μ，∑，σ2，β) 应用LRR模型来为每个评论推断计算方面权重 αd 。在本章节中，我们讨论怎样去运用最大似然（ML :<em>Maximum<br>Likelihood</em>）估计量估计这些模型参数，也就是，如何找到最优的 θ’ =(μ，∑，σ2，β)来最大化所有观测总体评级的可能性。</p><p>在整个评论集中的对数似然（log-likelihood）函数是如下公式(7)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzohwcp2j30ax01s745.jpg" alt="lara"></p><p>这样，ML估计参量：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzop0ebyj30d101s3ye.jpg" alt="lara"></p><p>为了计算ML估计参量，我们首先随机初始化所有参数值来获取一个初始θ(0) ,然后用如下EM-style算法来迭代的更新于改进这些参量，通过在每轮迭代中二选一的执行 E-Step 和M-Step：</p><ul><li><strong>E-Step</strong>：对于语料库中每个评论文本 d ，基于现阶段的参量θ(t)（下标t指迭代轮次）通过运用公式（1）（6）计算方面评级 sd 和方面权重αd 。</li><li><strong>M-Step</strong>：运用基于现阶段的参量 θ(t) 推断的方面评级 sd 和方面权重 αd 来更新模型参量，通过最大化“complete likelihood”来获取 θ(t+1) ，也就是为所有评论文本推断出所有如下变量，包括 总体评级 rd 、推测出的方面评级 sd 与方面权重 αd 。</li></ul><p>首先，我们看方面权重 αd 的高斯先验分布（Gaussian prior distribution）参数更新。目的是在 M-Step 中最大化计算出的所有计算值 αd 的可能性 ：对于所有的评论，我们又如下基于高斯分布的ML估计更新公式。如下公式（8）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzp01riqj30cr036mx1.jpg" alt="lara"></p><p>∑ (t+1) 记为:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzp8hl34j30cr01na9w.jpg" alt="lara"></p><p>也就有公式（9）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzpjgfpvj30cr01na9w.jpg" alt="lara"></p><p>然后，我们在看怎么来更新 σ2 和 β 。又这步已经假定 αd 是可知的，我们可以更新σ2 和 β 来 最大化 P( rd | ad ，σ2，β，Wd )（参见公式（2））。</p><p>我们通过如下更新公式来解决这个求最优问题：公式（10）（11）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzpvb0avj30do03cwee.jpg" alt="lara"></p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzq3fbgij30do01xt8l.jpg" alt="lara"></p><p>这个对于 β 的逼近解决方法对 一个 |V| ×|V| 据矩阵进行转置，要直接计算的话代价开销很大。为了避免这个问题，我们采用基于梯度算法（gradient-based method）来寻找 β 的最优解，梯度偏导算子如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzqf8yw3j30ad01swec.jpg" alt="lara"></p><p>这样，E-Step 与M-Step交替进行，直到方程（7）的似然值收敛。</p><h1 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h1><p>在本章节中，我们首先描述我们在评估 LRR 模型中所使用的评论数据集，然后讨论实验结果。</p><h2 id="5-1-数据集与预处理"><a href="#5-1-数据集与预处理" class="headerlink" title="5.1 数据集与预处理"></a>5.1 数据集与预处理</h2><p>我们从<a href="http://www.tripadvisor.com" target="_blank" rel="noopener">TripAdvisor</a>站点爬取到一个月内的（从2009年2月14到2009年3月15号）235793条酒店评论数据。选择这套数据集目的在于，它们不仅包含有总体评级，而且还包含有评论者各自的针对 7 个方面的细节评级，它们是value，room，location，cleanliness, checkin/front desk, service, business service，这些方面评级范围从 1 星到 5 星，我们可以利用这些作为 LARA的可靠的定量评估。这些数据集从以下网址获得：<a href="http://times.cs.uiuc.edu/~wang296/Data." target="_blank" rel="noopener">http://times.cs.uiuc.edu/~wang296/Data.</a></p><p>首先，我们对这些评论数据进行简单的预处理：</p><p>（1）统一大写转换为小写；</p><p>（2）移除标点符号，停用词（在文献[1]中所提供）；</p><p>（3）运用Porter Stemmer[22]还原每个单词词形【by vanjor：英文单词的词性、词形变化，去掉前缀、后缀等】</p><p>既然我们已经有 7 个预定义方面的评级数据，我们也把这 7 个方面应用到我们的预测实验中。因此，我们人工为每个预定义的方面选定一组种子关键词，并把他们作为 4.1 章节中所描述的算法的输入，我们设定选择门槛值 p = 5 、迭代步数上限 I = 10 。我们所用到的这个初始化方面词集，如下表，表（1）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzrdodfkj30dg0520t1.jpg" alt="lara"></p><p>在基于方面分割评论集后，我们丢弃掉那些不与任何方面关联的句子。如果我们需要每条评论中都包含这 7 个方面的描述信息，那么数据集中只有 关于184个酒店 的 780个评论符合。为了避免评论中的数据过于贫乏，以及方面描述信息丢失，我们将关于每个对应的酒店的所有评论汇集起来合并成一个新的“评论”（称之为“h-review”），并按 总体评级/方面评级 的平均值作为可信评级。经过这些处理后，我们得到一个1850酒店的语料库，以及108891条评论，具体见下表：表（2）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzrjaqdoj30ao03i3yk.jpg" alt="lara"></p><h2 id="5-2-定性评估-Qualitative-evaluation"><a href="#5-2-定性评估-Qualitative-evaluation" class="headerlink" title="5.2 定性评估 (Qualitative evaluation)"></a>5.2 定性评估 (Qualitative evaluation)</h2><p>首先，我们展示 LRR 模型关于定性评估生成的 3 个样列数据。</p><h2 id="方面层次酒店分析-Aspect-level-Hotel-Analysis"><a href="#方面层次酒店分析-Aspect-level-Hotel-Analysis" class="headerlink" title="方面层次酒店分析(Aspect-level Hotel Analysis)"></a>方面层次酒店分析(Aspect-level Hotel Analysis)</h2><p>通过检查总体评级来判断给定酒店的质量是一个简单的方法。而这样粗糙的分析可能会丢失不同方面的质量的细节评估：没能指出具有相同方面评级的酒店的差异。为了检验 LRR 模型的这种甄别能力，我们随机选择 就有相同总体评级不同方面评级的的 3 个酒店，并运用 LRR 模型来预测他们的潜在方面评级。预测结果见表 3 ，其中预测值在括弧内(由于空间有限，我们只展示前四个方面数据结果)，见下表（3）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzsstueaj30dg04e3yo.jpg" alt="LARA"></p><p>可以从中发现，3 个酒店具有相同的总体评级，不同的方面细节区别：Grand Mirage 与 Resort and Gold Coast Hotel 都有更高的 price 评级，而 Eurostars Grand Marina Hotel 拥有更高的 location 与 room 评级。这个信息对于那些有着不同方面需求的的人具有很好价值。</p><h3 id="评论者层次酒店分析-Reviewer-level-Hotel-Analysis"><a href="#评论者层次酒店分析-Reviewer-level-Hotel-Analysis" class="headerlink" title="评论者层次酒店分析(Reviewer-level Hotel Analysis)"></a>评论者层次酒店分析(Reviewer-level Hotel Analysis)</h3><p>即使对于同一个酒店，不同的评论者对于同一个方面会有不同的观点意见。 LRR模型可以更进一步的通过独立评论者层次的预测方面评级来支持这种细节的分析。为了证实这一点，我们选取总数据集中的一个子集 - 那些同时具有7个方面描述评论（覆盖184个酒店的780个评论），在表4 中，两个评论者同时对 Hotel Riu Palace Punta Cana 给出 4 星的总体评级，但是他们对于具体的方面评级不同：评论者1 对于酒店的 cleanliness  评级高于其他方面，而 评论者2 认为其 value 与  location 应该是最好的两个方面。为了证实这种不同，提供如下证据（方面评级）会让用户更好的基于拥有评论进行决策。表（4）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzt1t5ahj30dg03k3yn.jpg" alt="lara"></p><h3 id="语料特定词语情感倾向-Corpus-Specifc-Word-Sentimental-Orientation"><a href="#语料特定词语情感倾向-Corpus-Specifc-Word-Sentimental-Orientation" class="headerlink" title="语料特定词语情感倾向(Corpus Specifc Word Sentimental Orientation)"></a>语料特定词语情感倾向(Corpus Specifc Word Sentimental Orientation)</h3><p>为了对真个评论文本进行预测潜在观点评级，LRR 同样可以风分析词语的情感倾向。与传统的无监督情感分类算法不同，它们依赖预先定义的词典，LRR 可以直接从给定数据中挖掘这些情感化的信息。在 表5 中展示一些 LRR 有趣的结果，我们按每个方面 展示前5个具有积极权重的单词与前5个具有消极权重的单词。将它们与观点标注词典SentiWordNet [8]进行比较（由于空间有限，我们只展示前四个方面数据结果）。如下表，表（5）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynztzp2h4j30dg05saah.jpg" alt="lara"></p><p>我们可以发现一些有趣的结果，单词“ok”在 SentiWordNet 定义为积极的，但在我们的语料库中，评论者使用这个单词表示 仅仅可以接受的；单词 “linen”,“walk”以及”beach” 在SentiWordNet中并没有标注具有观点，而他们也是名词，而 LRR 系统赋予它们积极的情感倾向，可能因为”lean”可能暗示”cleanliness”的状况是好的，”walk”与”beach”可能暗示酒店的位置是很便捷的。</p><p>这样，LRR可以为我们提供指定领域的词语倾向信息，这对于指定领域中的已有的情感字典的丰富扩大是很有帮助的。</p><h2 id="5-3-定量分析（Quantitative-Evaluation）"><a href="#5-3-定量分析（Quantitative-Evaluation）" class="headerlink" title="5.3 定量分析（Quantitative Evaluation）"></a>5.3 定量分析（Quantitative Evaluation）</h2><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>在我们所调研范围内，尚没有人做过解决类似问题的尝试，最接近我们的工作[17]，其中，作者提出两种方法，那就是Local prediction与Global prediction。因此，我们也把这两个方法作为我们基本算法予以比较。也采用其他的一些算法，比如，把评论的总体评级作为方面评级来训练监督模型。我们通过支持向量回归（SVR：<em>Support Vector Regression</em> ）模型[3]，并命名为 SVR-O 。另外，作为一个上限，我们同样也测试了一个完全监督算法 SVR-A，那就是喂有已知方面评级的训练数据的SVR模型做比较，以此找出什么样的 LRR 模型能够不需要监督而达到这一效果。我们使用libsvm包[4]中带有默认参数时间的RBF核心算法，进行SVR-O与SVR-A处理。所有的模型包括 LRR 以及这两个方法[17]都基于同一组数据集。我们采用四折交叉验证（<em><a href="/2010/10/cross-validation/">4-fold cross validation</a></em>），并给出处理性能的平均值。</p><h3 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h3><p>我们使用四个不同的测度来定量评估这些不同的方法，包括</p><ol><li>方面评级预测的均方误差（mean square error） <strong>△aspect 2</strong> ；</li><li>评论中的方面相关系数（ρaspect）;</li><li>评论间的方面相关系数（ρreview）;</li><li>平均准确率（MAP：<em>Mean Average Precision</em>）[11]，一个经常用来衡量信息检索中平局准确性的指标。</li></ol><p>正式的，假定s di<em> 是真实的方面评级Ai 。<strong>△aspect 2</strong> 直接测量预测方面评级sdi 与真实方面评级s di</em> 的差异，定义如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzv53yutj30ak01xmwz.jpg" alt="LARA">)</p><p>ρaspect 目的在于测量方面评级预测的性能，用于保存对应评论的按照真实评级的相关方面排序。例如，在一个评论中，评论者可能偏好 location大于cleanliness，ρaspect 会评估这个预测的评级与对应真实的偏好排序是否一致，ρaspect 定义如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzvbop3wj306701yjr6.jpg" alt="LARA"></p><p>其中 ρsd,sd 是两个向量 sd 与 sd 的皮尔森相关系数（Pearson correlation）。</p><p>类似的 ρreview 定义了如下皮尔森相关系数：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzvm2h7vj306j01wmwy.jpg" alt="LARA"></p><p>其中 si 与 si* 两向量为整个评论集中的关于方面 Ai 的预测值与真实值。它可以指出在整个评论集中，有关方面Ai 的方面预测值与真实值是否是一致的，这种排序可以回答如下问题：”那个酒店拥有最好的service？”</p><p>尽管如此，ρreview 对于所有的条目平等权重，并且不反应排名前几个的特性，直观来说从用户的视角来看更为重要。因此，我们也采用MAP来评估模型关于评论的的排序准确信。更准确的说，我们对真实评论站前十的评论子集作为一个相关评论集，以此来看如果我们通过预测方面评级，是否也能把这10个评论预测前十。我们对所有酒店按照7个方面排序，并计算 MAP 前10个评论作为临界值。</p><p>结果分析：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzwom1gqj30cw042weo.jpg" alt="LARA"></p><p>如上表，表（6）展示了所有5个算法在四个度量上的测量结果。因为SVR-A是完全监督算法，而其它均不是，我们把它单独列在最下一行。同时出SVR-A外的四个模型，粗体着重标注在四个度量上各自最高性能值。</p><p>总体观察来看在 LRR 的性能在<strong>△aspect 2</strong> 与 ρreview 这两个度量比其他的非 SVR-A 模型性能要好的多，但是它也不是在这两个方面表现性能最好的。较高的 ρreview 表明LRR可以更好的区分一个评论中的不同方面的评价。注意到这个在不同方面上的相对偏好信息不能仅从总体评级中获取。另外，高的 MAP@10 表明 LRR 相比其他方法也能更好的检测到 在各个方面排名前十的酒店，这些对于用户的直接排名也十分有用，因为高排名的结果将可能会最影响用户满意度。</p><p>注意到 <strong>△aspect 2</strong> 是独立的衡量每个预测方面评级与真实方面评级，也就无法反应方面关联排序性能如何。比如，有一个只有三个方面的实体，一个评论的整体评级为 4 而事实的方面评级为（3,4,5）。那么一个生涩的预测（4,4,4）没能辨别出方面的不同，将会有<strong>△aspect 2</strong> =0.67，而另外一个预测（2,3,4），能够辨别出方面上的不同，却有相对更高（效果更差）<strong>△aspect 2</strong> =1。却是，可以观察到Local prediction模型达到最好的<strong>△aspect 2</strong> =0.588，但是是在以最低的 ρaspect 指标性能为代价，而事实上 ρaspect 具有更重要的用途。</p><p>通过对基于方面评级预测的准确度排名深入研究，我们可以看到两个测度 <strong>△aspect 2</strong> 与 ρreview 产生不同结论。这个是在预期的，因为ρreview 测度这 1850 个 h-reviews 的相关性，而<a href="mailto:MAP@10" target="_blank" rel="noopener">MAP@10</a>只关心前十的，Local prediction 没有在 ρreview 指标上得分最高，却在<a href="mailto:MAP@10" target="_blank" rel="noopener">MAP@10</a>指标上表现糟糕。这说明了它比LRR的更出色与低排名而不是高排名的那些，而这些又是用户最为关心的。</p><p>注意到给 SVR 喂养总体评级并没有达到预期的性能，这也在一定程度上证实了我们的假设：总体评级与方面评级是有区别的。因此，光只看总体评级是不够充分的。最终，并不奇怪的是，LRR 没有基于事实方面评级数据训练模型 SVR-A 那样高的表现性能。尽管如此 LRR 不需要训练集包含有任何方面评级的标记，比 SVR-A 具有更显示的应用前景。</p><h3 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h3><p>在实际的应用中高效的挖掘算法是十分重要的。LRR 的主要计算工作在于解决非线性优化器问题，见公式（6）（11）。LRR的训练步骤中的收敛度取决于模型参量 Θ ,评论集 |D| 的数量 以及 迭代步骤上限 I，这个算法复杂度初步估计为O(k(n + k + 1)|D| I )，与评论集数目线性相关，对于我们的数据集，这个算法在奔腾4系列2.8CPU/2GB 内存的台式电脑上用时不到3分钟完成。</p><h2 id="5-4-应用"><a href="#5-4-应用" class="headerlink" title="5.4 应用"></a>5.4 应用</h2><p>运用 LRR 模型进行 具体的观点理解与获取对于许多应用都具有潜在的价值，我们列举如下三个样列应用.</p><h3 id="基于方面的概括"><a href="#基于方面的概括" class="headerlink" title="基于方面的概括"></a>基于方面的概括</h3><p>因为LRR可以为评论 sd 推断方面评级，我们就可以更为容易的对于酒店的各个方面上 聚合评论集的方面评级（例如：（1/|D| )∑d∈D sd）。这样酒店的方面评级可以被看做为基于方面观点的概括。基于这些，我们也可以对指定酒店通过公式（1）计算选择那些句子，这些在每个方面具有最高的和最低的评分，帮助用户更加理解每个方面的观点。</p><p>我们在 表7 中展示了一个基于方面的概括。我们可以看到评价者当考虑到酒店在西雅图这么好的位置时对于价格的容忍值就很高。尽管如此，还是有很多地方可以改进，不好的供暖系统，以及互联网接入需收费。这些细节信息将会对用户从海量评价信息中挖掘基本观点十分有用。如下表（7）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzza221uj30dg04i74p.jpg" alt="LARA"></p><h3 id="用户评价行为表现分析"><a href="#用户评价行为表现分析" class="headerlink" title="用户评价行为表现分析"></a>用户评价行为表现分析</h3><p>通过为每个独立的评论推断潜在方面权重ad，我们可以知道对应的评论者在不同方面的强调程度，可以视作为用户评级行为表现的理解。一个潜在的应用是挖掘用户在作出最终评价时，那些因素对于用户的判断具有最大影响。为了深入研究，我们选择了两组不同价格区间的酒店数据：一组的价格超过$800（称之为昂贵的酒店），另一组为价格低于$100（称之为廉价的酒店），对于每一组，我们选取平均整体评级排名前十与末十的酒店，最终形成四个酒店子集。我们展示这四个酒店子集的平均方面权重ad，结果见表（8）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzzgsjwwj30cw05g74k.jpg" alt="LARA"></p><p>我们发现一个有趣的现象是，评价者们为昂贵的酒店给出高评价主要是因为他们良好的service与locations，而对应给出低评价这是因为糟糕的房屋环境与过高价格。</p><p>作为对比，评价者为廉价的酒店给出高评价主要是因为好的price/value 以及良好的location，而相对给出低评是因为糟糕的cleanliness.</p><p>另外，这些量化的评级可能包含不同评价间的平均反应：低收入客户为便宜的酒店给出“value”方面的 5 星评价，而一些其他追求更好服务的客户可能给予昂贵的酒店在“value”方面的 5 星评价。仅仅为每个方面预测评级仍然不够以挖掘到用户间的微妙差异，但是这种方面权重的推断更好的便于我们理解为什么低收入客户相比“service”更倾向于“value”。为了深入了解这些，我们从四个城市：Amsterdam、Barcelona、Florence 以及 San Francisco中（这些地方的酒店在我们的语料库中大有所在），挑选出在“value”方面评级都具有5星评价的酒店，我们按照他们的方面权重比率 value/location、value/room、value/service 进行排序，相对应的，对于每个比率，计算出平均前十和末十的酒店。数据展现在表（9）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzzpcmp9j30dg05s0t0.jpg" alt="LARA"></p><p>我们发现那些相对具有“value”上更高权重的酒店具有更低的价格，同时对“location”、“room”与“service”这些方面具有较高权重的酒店倾向于就有更高的价格，表明了即时这些酒店在“value”方面具有同样方面评价，偏好于“value”方面的客户可能更倾向于价格低廉的酒店，而那些对偏好于“location”或“service”（除了”price”）方面的则可能会接受更高的价格。这样推断出的方面权重αd 对于挖掘用户评级行为十分有用。</p><h3 id="个性化排序"><a href="#个性化排序" class="headerlink" title="个性化排序"></a>个性化排序</h3><p>对酒店按照各个方面推断出的评级对于用户十分有用。我们展示为每个独立的评论学习不同方面的评级权重，使得我们可以为一个当前用户挑选具有相同评价行为偏好的评论进行个性化排序。具体来说，给定一个用户的偏好权重作为查询条件，我们可以通过选择那些具有类似偏好权重的评论者，并且只基于这些评论者们的评论集做出酒店排名。</p><p>为了有效的展示 LRR 模型支持这种个性化牌型，考虑一个样例查询：Query= { value weight：0.9, others：0.016 }，暗示用户最看重偏好“value”，并不太关心其他方面。我们运用两用不同排名方法：</p><ul><li><strong>方法 1</strong>: 不考虑输入查询，通过按预测方面评级对酒店进行排序。</li><li><strong>方法 2</strong>: 挑选出与所给定查询具有最接近的方面权重（也就是 αd）的评论者前10%，并仅只根据他们的评论做出酒店排名。</li></ul><p>通过两种方法，我们基于查询中定义的方面权重对酒店进行排序，得到的前 5 的结果如下表：表（10）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo02siw85j30dg06jaai.jpg" alt="lara"></p><p>十分有趣的现象是尽管方法 1 中前5的结果都具有5星评价（并且大致也可推测道他们在“value”方面上也具有很高评级，因为排名主要是基于查询中的权重的），它们的价格倾向比方法2 中得到的前五酒店要高；的确，方法 1 中的前 5 酒店平均价格是$412.6 而方法2 中前5 酒店平均价格仅为$289.4，相对要低很多。（整个数据集中所有酒店的平均价格为$334.3）。直觉可以看到对于样列查询，方法 2 对于用户更有帮助。这也就意味着像方法2 这样，只从挑选类似偏好权重行为的用户的评论集进行排序，个性化排序对“value”方面偏好权重更大，确保排名前几的酒店真的具有相对较低的价格。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文中，我们定义了一种新颖文本挖掘算法问题-潜在方面观点评级分析（LARA：Latent Aspect Rating Analysis）来分析在线评论在话题方面级别的观点。LARA 通过分析一套带有整体评级的评论文本 以及 一组指定的方面作为输入，来挖掘每个独立的评论者在给定的这些方面的潜在评级，以及不同方面的相对权重大小。为了解决这个问题，我们提出一个新颖的潜在评级回归模型（LRR）。</p><p>我们对于一组酒店评论数据集的以经验为主的实验表明 LRR 模型能有效的解决 LARA 问题，挖掘那些方面评级的差异背后的有趣行为，即使总体评级相同。这个结果页表明基于话题方面的层级上的观点分析可以支持多种应用，包括方面观点概括，基于方面评级的实体排序 以及 用户评级行为分析。</p><p>我们的工作开启了一个文本挖掘的新颖方向，聚焦在分析带有观点性文本的潜在评级分析。再为来它将会有更多有趣的研究方向值得挖掘。列于，虽然我们是基于评论定义了LARA问题，LARA 也很明显可以应用于任何带有观点性的文本（比如网络日志），并带有总体评级以达到具体的理解文本观点。她可能在其他应用场景中就有有趣研究价值。另外,我们的LRR模型并没有严格的显示为词语特性，其他的类型特性也可以很容易的应用到此模型中。同样，在我们的LARA定义中，我们假定方面描述为一组关键词形式。这有利于用户灵活的把握控制他所想要研究的方面。</p><p>LARA问题 在未来关于潜在方面挖掘与方面评级及方面权重将是十分有趣的研究话题方向。</p><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>感谢匿名评论者的十分有价值的评论。本文基于IBM Faculty Award -an Alfred P. Sloan Research Fellow-ship, and by the National Science Foundation under grants IIS-0347933, IIS-0713581, IIS-0713571, and CNS-0834709所支持下的工作。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] Onix text retrieval toolkit stopword list. <a href="http://www.lextek.com/manuals/onix/stopwords1.html" target="_blank" rel="noopener">http://www.lextek.com/manuals/onix/stopwords1.html</a>.</li><li>[2] D. Blei, A. Ng, and M. Jordan. Latent dirichlet allocation. The Journal of Machine Learning Research, 3:993 - 1022, 2003.</li><li>[3] C. Burges. A tutorial on support vector machines for pattern recognition. Data mining and knowledge discovery, 2(2):121 - 167, 1998.</li><li>[4] C.C. Chang and C.J. Lin. LIBSVM: a library for support vector machines, 2001. Software available at <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a>.</li><li>[5] H. Cui, V. Mittal, and M. Datar. Comparative experiments on sentiment classifcation for online product reviews. In Twenty-First National Conference on Artificial Intelligence, volume 21, page 1265, 2006.</li><li>[6] K. Dave, S. Lawrence, and D. M. Pennock. Mining the peanut gallery: opinion xtraction and semantic classifcation of product reviews. In WWW ‘03, pages 519{528, 2003.</li><li>[7] A. Devitt and K. Ahmad. Sentiment polarity identifcation in fanancial news: A cohesion-based approach. In Proceedings of ACL’07, pages 984 - 991, 2007.</li><li>[8] A. Esuli and F. Sebastiani. SentiWordNet: A publicly available lexical resource for opinion mining. In Proceedings of LREC, volume 6, 2006.</li><li>[9] A. Goldberg and X. Zhu. Seeing stars when there aren , a¶rt many stars: Graph-based semi-supervised learning for sentiment categorization. In HLT-NAACL 2006 Workshop<br>  on Textgraphs: Graph-based Algorithms for Natural Language Processing, 2006.</li><li>[10] M. Hu and B. Liu. Mining and summarizing customer reviews. In W. Kim, R. Kohavi, J. Gehrke, and W. DuMouchel, editors, KDD, pages 168 - 177. ACM, 2004.</li><li>[11] K. Jarvelin and J. Kekalainen. IR evaluation methods for retrieving highly relevant documents. In Proceedings of SIGIR’00, pages 41 - 48. ACM, 2000.</li><li>[12] N. Jindal and B. Liu. Identifying comparative sentences in text documents. In Proceedings of SIGIR ‘06, pages 244 - 251, New York, NY, USA, 2006. ACM.</li><li>[13] H. Kim and C. Zhai. Generating Comparative Summaries of Contradictory Opinions in Text. In Proceedings of CIKM’09, pages 385 - 394, 2009.</li><li>[14] S. Kim and E. Hovy. Determining the sentiment of opinions. In Proceedings of COLING, volume 4, pages 1367 - 1373, 2004.</li><li>[15] K. Lerman, S. Blair-Goldensohn, and R. T. McDonald. Sentiment summarization: Evaluating and learning user preferences. In EACL, pages 514 - 522, 2009.</li><li>[16] B. Liu, M. Hu, and J. Cheng. Opinion observer: Analyzing and comparing opinions on the web. In WWW ‘05, pages 342 - 351, 2005.</li><li>[17] Y. Lu, C. Zhai, and N. Sundaresan. Rated aspect summarization of short comments. In Proceedings of WWW’09, pages 131 - 140, 2009.</li><li>[18] S. Morinaga, K. Yamanishi, K. Tateishi, and T. Fukushima. Mining product reputations on the web. In KDD ‘02, pages 341{349, 2002.</li><li>[19] B. Pang and L. Lee. Seeing stars: Exploiting class relationships for sentiment categorization with respect to rating scales. In Proceedings of the ACL, pages 115 - 124, 2005.</li><li>[20] B. Pang, L. Lee, and S. Vaithyanathan. Thumbs up? Sentiment classi¯cation using machine learning techniques. In EMNLP 2002, pages 79 - 86, 2002.</li><li>[21] A.-M. Popescu and O. Etzioni. Extracting product features and opinions from reviews. In Proceedings of HLT ‘05, pages 339 - 346, Morristown, NJ, USA, 2005. Association for Computational Linguistics.</li><li>[22] M. Porter. An algorithm for su±x stripping. Program, 14(3):130 - 137, 1980.</li><li>[23] B. Snyder and R. Barzilay. Multiple aspect ranking using the good grief algorithm. In Proceedings of NAACL HLT, pages 300 - 307, 2007.</li><li>[24] I. Titov and R. McDonald. A joint model of text and aspect ratings for sentiment summarization. In ACL ‘08, pages 308 - 316.</li><li>[25] Y. Yang and J. O.Pedersen. A comparative study on feature selection in text categorization. In Proceedings of ICML’97, pages 412 - 420, 1997.</li><li>[26] L. Zhuang, F. Jing, and X. Zhu. Movie review mining and summarization. In Proceedings of CIKM 2006, page 50. ACM, 2006.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyo032faiwj306s046t8u.jpg&quot; alt=&quot;lara&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文为国外09年的最新文本挖掘类别论文：&lt;/p&gt;
&lt;p&gt;原文：Latent Aspect Rating Analysis on Review Text Data: A Rating Regression Approach&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;http://scholar.google.com.hk/scholar?q=Latent+Aspect+Rating+Analysis+on+Review+Text+Data:+A+Rating+Regression+Approach&amp;amp;hl=zh-CN&amp;amp;btnG=%E6%90%9C%E7%B4%A2&amp;amp;lr=&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文Paper&lt;/a&gt;，&lt;a href=&quot;http://sifaka.cs.uiuc.edu/~wang296/paper/hongning-KDD10-v2.pptx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;展示PPT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人三天时间完整翻译而成，本文对于理解话题识别，用户潜在观点挖掘，情感计算方面都有很好的借鉴意义。&lt;/p&gt;
&lt;p&gt;目前在用户观点情感挖掘方面属于一个十分前沿的话题，广泛应用在产品研究，用户行为分析，推荐系统上。比现行的许多基于文本分类论文都是更为细致的研究，本文中大量运用统计概率学方面知识对话题识别，情感词的渐进识别，权重推断，以及结果估计验证，与应用探讨，值得深入学习。&lt;/p&gt;
&lt;p&gt;个人认为一个最重要的不足的是，论文中还是主要通过挖掘文本中词语间的关联，类似tf/idf词频统计，先验概率推断等进行文本挖掘分析，而对于语义的理解，句法的解读分析仍然没有考虑在内，这样必然导致结果仍然存在很多偏差与误判，而鉴于语义理解，句法分析尚属一个十分困难的前沿研究领域。文本尤为可佳。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="NLU" scheme="https://blog.vanjor.com/tags/nlu/"/>
    
  </entry>
  
  <entry>
    <title>文本情感分析概述</title>
    <link href="https://blog.vanjor.com/2010/12/sentiment-analysis-brief/"/>
    <id>https://blog.vanjor.com/2010/12/sentiment-analysis-brief/</id>
    <published>2010-12-01T10:52:06.000Z</published>
    <updated>2010-12-01T10:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0h8l8vij307203dt8q.jpg" alt="nlu"></p><p>文本情感分析(Sentiment Analysis)： 又称意见挖掘,简单而言,是对带有情感色彩的主观性文本进行分析、处理、归纳和推理的过程.最初的情感分析源自前人对带有情感色彩的词语的分析。(右图参考论文[2])</p><p>应用背景与意义： 互联网(如博客和论坛以及社会服务网络如大众点评)上产生了大量的用户参与的、对于诸如人物、事件、产品等有价值的评论信息.这些评论信息表达了人们的各种情感色彩和情感倾向性,如喜、怒、哀、乐和批评、赞扬等. 基于此,潜在的用户就可以通过浏览这些主观色彩的评论来了解大众舆论对于某一事件或产品的看法。</p><p>本文主要介绍情感分析所要涉及的两个基础概念方面，情感分类主客观识别，情感信息提取，主客体的识别，与情感信息的计算。</p><a id="more"></a><h1 id="情感分析概述"><a href="#情感分析概述" class="headerlink" title="情感分析概述"></a>情感分析概述</h1><p>层次分类：</p><ul><li>按照处理<strong>文本的粒度</strong>不同,情感分析可分为词语级、短语级、句子级、篇章级以及多篇章级等几个研究层次</li><li>按照处理<strong>文本的类别</strong>不同,可分为基于新闻评论的情感分析和基于产品评论的情感分析等</li></ul><p>以下主要从情感分析的几个需要考虑的问题做阐述：<strong>情感信息的抽取</strong>、<strong>情感信息的分类</strong></p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0iar441j30cu06hjrw.jpg" alt="sentiment"></p><h1 id="情感信息的抽取"><a href="#情感信息的抽取" class="headerlink" title="情感信息的抽取"></a>情感信息的抽取</h1><p>情感分析的最底层的任务,它旨在抽取情感评论文本中有意义的信息单元.</p><p>其目的在于将无结构化的情感文本转化为计算机容易识别和处理的结构化文本,继而供情感分析上层的研究和应用服务。</p><p>有价值的情感信息单元主要有评价词语(如优秀、好用)、评价对象 (如GPS,屏幕分辨率)、观点持有者 (如国家政府、台湾当局)</p><p>总体三部分:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0imrjmcj30cs0233yf.jpg" alt="情感分析主客体结构"></p><h2 id="评价词语的抽取和判别"><a href="#评价词语的抽取和判别" class="headerlink" title="评价词语的抽取和判别"></a>评价词语的抽取和判别</h2><p>即为评价词语的识别和极性及度量判断，评价词语的抽取和判别往往是一个一体化的工作:</p><p>主要分为基于语料库和基于词典两种方法</p><h3 id="基于语料库的评价词语抽取和判别"><a href="#基于语料库的评价词语抽取和判别" class="headerlink" title="基于语料库的评价词语抽取和判别"></a>基于语料库的评价词语抽取和判别</h3><p>主要是利用大语料库的统计特性,观察一些现象来挖掘语料库中的评价词语并判断极性.</p><p>优缺点： 基于语料库的方法最大的优点在于简单易行,缺点则在于可利用的评论语料库有限,同时评价词语在大语料库中的分布等现象并不容易归纳</p><h3 id="基于词典的评价词语抽取及判别方法"><a href="#基于词典的评价词语抽取及判别方法" class="headerlink" title="基于词典的评价词语抽取及判别方法"></a>基于词典的评价词语抽取及判别方法</h3><p>主要是使用词典中的词语之间的词义联系来挖掘评价词</p><p>优缺点：难度较大，词典的更新程度决定词义分析</p><h2 id="评价对象的抽取"><a href="#评价对象的抽取" class="headerlink" title="评价对象的抽取"></a>评价对象的抽取</h2><p>评价对象是指某段评论中所讨论的主题, 具体表现为评论文本中评价词语所修饰的对象</p><p>可参考一下两种</p><h3 id="基于规则-模板的方法抽取评价对象"><a href="#基于规则-模板的方法抽取评价对象" class="headerlink" title="基于规则/模板的方法抽取评价对象"></a>基于规则/模板的方法抽取评价对象</h3><p>规则的制定通常要基于一系列的语言分析与预处理过程,如词性标注、命名实体识别、句法分析等.相应地,制定的规则也包括词序列规则、词性规则以及句法规则等形式</p><p>优缺点：在于针对性强,可以直接针对待解决的问题或特定的语言现象制定规则/模板;而其缺点则在于规则/模板的可扩展性差,人工编写的工作量大,成本较高.</p><h3 id="基于对象归属"><a href="#基于对象归属" class="headerlink" title="基于对象归属"></a>基于对象归属</h3><p>一个角度诠释了评价对象的抽取.他们将评价对象看作产品属性的一种表现形式(如对数码相机领域而言,“相机的大小”是数码相机的一个属性,而“相机滑盖”是数码相机的一个组成部分),继而考察候选评价对象与领域指示词(如“整体-部分”关系指示词“scanner has”)之间的关联度来获取真正的评价对象.</p><p>优缺点：实验效果超过了基于规则/模板的方法,但难点在于领域指示词的获取.</p><p>评价对象在产品服务专栏评论，如大众点评评论中，一般可以以默认当前产品作为用户的评价对象。</p><h3 id="观点持有的抽取"><a href="#观点持有的抽取" class="headerlink" title="观点持有的抽取"></a>观点持有的抽取</h3><p>观点持有者的抽取目的在于辨别情感文本的意见主体是谁，比如在美国大选中，需要甄别，那一部分群体支持，那一部分群体赞成，</p><ul><li>借助于命名实体识别技术来获取观点持有，类似于词典分析法者<ul><li>优缺点：较为依赖自然语言处理的基础技术,有较低的语言覆盖现象和较差的领域适应性.</li></ul></li><li>将所有名词短语都视为候选观点持有者<ul><li>使用ME(maximum entropy)模型来进行计算.</li></ul></li><li>将观点和观点持有者的识别作为一个任务同时解决<ul><li>在抽取出情感句中的观点单元(多是由一些短语组成)之后,分析句中观点和动词的句法关系,即可同步获取观点持有者.</li></ul></li></ul><p>产品评论中一般默认观点持有者是用户本身,因此很少有研究者在产品评论领域研究这一任务。</p><h3 id="组合观点持有的抽取"><a href="#组合观点持有的抽取" class="headerlink" title="组合观点持有的抽取"></a>组合观点持有的抽取</h3><p>组合观点主要考虑到现实情形中，用户的评价存在领域方向的针对性，以及存在多个评价客体的比较等更复杂也普遍存在的场景考虑。</p><p>评价词语在情感分析中的作用是不言而喻的.然而在某些情况下,单独的评价词语存在一定的歧义性,如评价词语“高”在以下3 个句子中的使用:</p><ul><li>Sen 1:凯越的油耗真高.</li><li>Sen 2:捷达的性价比相当高.</li><li>Sen 3:这辆车有1米多高.</li></ul><p>Sen 1 和Sen 2 是情感句,但是评价词语“高”在修饰不同的评价对象时表现出不同的极性.如,“高”在Sen 1 中表示贬义,而在Sen 2 中则表示褒义.</p><p>此外,评价词语往往也会出现在非情感句中,如Sen 3.</p><p>因此,仅考虑单独的评价词语在情感分析中的应用是远远不够的.研究者们发现,有些包含评价词语的“组合评价单元”(如组合“油耗-高”、“性价比-高”)对于处理情感分析的上层任务更有帮助. 另一考虑途径是对产品的子类别划分，按照油耗节能，总体性价比，等分别进行用户情感评估。</p><p>可以由以下两方面考虑</p><p><strong>主观表达式的抽取</strong>:</p><p>从不同的语料中扩充了大量的主观表达式,主要包括手工收集的一部分主观表达式以及自动从标注/未标注语料中学习而来的一部分主观表达式</p><p><strong>评价短语的抽取</strong>:</p><p>评价短语表现为一组连续出现的词组,但不同于主观表达式,该词组往往是由程度副词和评价词语组合而 成,如“very good”等.因此,这种组合评价单元不仅顾及了主观表达式的情感极性,还考察了其修饰成分.这些修饰成分或加强或减弱或置反了主观表达式的情感极性,使得评价短语成为一种情感色彩丰富的组合评价单元。</p><h1 id="情感分类"><a href="#情感分类" class="headerlink" title="情感分类"></a>情感分类</h1><p>情感分类首要的是对文本的主客观性进行甄别，在新闻，个人博客，以及电影评论中都会涉及到一些客观是事物描述，比如电影评论中涉及到对电影中的剧透，这些客观的描述潜在会包含情感词，而不能作为用户的情感计算。</p><p>主、客观信息的分类可以参考如下两种方式：</p><ol><li>通过考察文本内部是否含有情感知识(具体表现为情感信息抽取的结果)来完成主客观信息分类</li><li>将情感文本单元的主客观分类定义为一种二元分类任务,即对任意给定的情感文本单元,由分类器协助判断其主客观性.这种方法的关键在于分类器和分类特征的选取.</li></ol><h2 id="主观信息最简化分类"><a href="#主观信息最简化分类" class="headerlink" title="主观信息最简化分类"></a>主观信息最简化分类</h2><p>一般而言,情感最简化建模为将主观本文的极性分为褒义和贬义两类(thumbs up? thumbs down?).</p><p>两种方法基于情感知识的方法以及基于特征分类的方法</p><ol><li>基于情感知识：主要是依靠一些已有的情感词典或领域词典以及主观文本中带有情感极性的组合评价单元进行计算</li><li>基于特征分类：主要是使用机器学习的方法,选取大量有意义的特征来完成分类任务.将情感文本单元的主客观分类定义为一种二元分类任务,即对任意给定的情感文本单元,由分类器协助判断其主客观性.这种方法的关键在于分类器和分类特征的选取.</li></ol><p>注: 全本主要针对文献[1]按个人观点整理补充而成，仅供学习参考</p><p>参考文献：</p><ol><li>赵研研等，《<a href="http://scholar.google.com.hk/scholar?q=文本情感分析" target="_blank" rel="noopener">文本情感分析</a>》，Journal of Software，2010</li><li>Hongning Wang, Y.L.C.Z. , <a href="http://scholar.google.com.hk/scholar?hl=zh-CN&amp;q=Latent+Aspect+Rating+Analysis+on+Review+Text+Data" target="_blank" rel="noopener">Latent Aspect Rating Analysis on Review Text Data</a>. 2009.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fyo0h8l8vij307203dt8q.jpg&quot; alt=&quot;nlu&quot;&gt;&lt;/p&gt;
&lt;p&gt;文本情感分析(Sentiment Analysis)： 又称意见挖掘,简单而言,是对带有情感色彩的主观性文本进行分析、处理、归纳和推理的过程.最初的情感分析源自前人对带有情感色彩的词语的分析。(右图参考论文[2])&lt;/p&gt;
&lt;p&gt;应用背景与意义： 互联网(如博客和论坛以及社会服务网络如大众点评)上产生了大量的用户参与的、对于诸如人物、事件、产品等有价值的评论信息.这些评论信息表达了人们的各种情感色彩和情感倾向性,如喜、怒、哀、乐和批评、赞扬等. 基于此,潜在的用户就可以通过浏览这些主观色彩的评论来了解大众舆论对于某一事件或产品的看法。&lt;/p&gt;
&lt;p&gt;本文主要介绍情感分析所要涉及的两个基础概念方面，情感分类主客观识别，情感信息提取，主客体的识别，与情感信息的计算。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="Classifier" scheme="https://blog.vanjor.com/tags/classifier/"/>
    
      <category term="NLU" scheme="https://blog.vanjor.com/tags/nlu/"/>
    
      <category term="Sentiment Analysis" scheme="https://blog.vanjor.com/tags/sentiment-analysis/"/>
    
  </entry>
  
  <entry>
    <title>十一探乂</title>
    <link href="https://blog.vanjor.com/2010/11/november-peace-unrest/"/>
    <id>https://blog.vanjor.com/2010/11/november-peace-unrest/</id>
    <published>2010-11-30T14:43:35.000Z</published>
    <updated>2010-11-30T14:43:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>不经意的抬手看看时间，恰好手表那分针挡住了日期，多么希望看到时间为我所停驻，却已不由感觉只下徒劳，这是十一月的最后一天啊。</p><a id="more"></a><p>月首寄语已悄然变换为月末的那尚未及回味完的丝丝的留恋，为一件事前前后后忙碌了一月，已孵化成型，颇有些欣慰，莞尔也暂多了一份担忧。从没想过曾经看似久远的时代，如今那么贴近，平滑的过渡，转身。</p><p>就如同时光的消逝，动荡中求得安逸，却从来没有忘记过忧患的存在，就如同总是感觉到它静悄悄的沉寂在你身边的一个角度，待得你足够遗忘它时，悄然现身之时，即是被其吞噬时。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynu48jkgbj30ec090glz.jpg" alt="november-for-peace"></p><p>看过<a href="http://www.youku.com/show_page/id_zac398d46a47011df97c0.html" target="_blank" rel="noopener">11度青春系列电影</a>之《<a href="http://v.youku.com/v_show/id_XMjE4MDU1MDE2.html" target="_blank" rel="noopener">老男孩</a>》的视频，在命运变幻的河流里，青春如同奔流的江河，一去不回来不及道别。生活像一把无情刻刀，改变了我们模样，未曾绽放就要枯萎吗 ，我有过梦想，青春如同奔流的江河，一去不回来不及道别，只剩下麻木的我没有了当年的热血，看那漫天飘零的花朵，在最美丽的时刻凋谢，有谁会记得这世界她曾经来过。深刻感受到时间的那把无情刻刀，也感觉一种未来得及把握时度未作为的深深的遗憾与危机感。</p><p>同样也看过《<a href="http://movie.mtime.com/108953/" target="_blank" rel="noopener">社交网络</a>》，感受到电影中的主角原型马克·扎克伯格的那种人生理想与创业历程同时，也得到内在的一种启迪与深思，在想法与实施间也只是一念之间，在坚持与妥协间也只差一步。无论何种形式的发展，都需要自身的超强领域能力为基础，外加优良的综合品质付诸于行动。</p><p>越来越清晰所要做的事，也越来明晓时光易逝，在一件一件琐碎之事轮流压栈出栈时，或许早已忘记当初下的断点再也回不到起初的路，或许已经疲惫不堪，再也无力继续航行，或许，所要做之事已如堵塞的交通，走走停停，没有个明了的前方。因而也感觉到很多事情应该顺着好的状态追击下去，而不能纵然耽搁。</p><p>在程式的编织之路上也遇到一些困惑，或许是先进的一个瓶颈，也是一个急需汲取新知识的时期，经常权衡不定是自己是否有些重造车轮，还是该寻找前人的框架作为基础，但是也没有完全能够符合自身的需求的框架，消化并修改复用前人框架与自己重新制造总是有些权衡的痛苦。同时基于程序复用，代码究竟该抽象到什么一个程度上，仍然是不断的探索，也是与自身能力，事务的分析，抽离合理性挂钩，作坊的试验品与发布的构件之间其实是一个巨大的鸿沟。</p><p>在这一个月，其实是几个月内感触的另一点是，没有经过完全消化掉的东西从来不归属与自己，就如同没有经过消化过的食物一样，那些每天所认识，学习到的杂碎的知识都急需要整理归纳，否则一大堆的夹生的知识都只会局促在一起腐败。有时看似方便快捷，为了省时，任由离散的资料，知识散布在脑海，PC中的每一个快捷文件夹中，最终这些膨胀不可掌控的东西由如鸡肋，拾之困难，弃之可惜。除去每天需要更加清晰的划分任务外，不至于过于盲目乐观，总是未完了。也需要留下一段时间，不是去学习新的东西，而是去整理当天的那些夹生的知识。同时，也进一步规范行为，辅之以工具，如Notepress等，增强对周边的知识的可达性与掌控能力。</p><p>也正与一次在论坛中讨论引发感悟，对于自身未亲自实验证实或想法阶段的，也未尝不可形式化提出来，从脑子里到书面的整理加工也是进一步的学习与思考，也是一个Tag作为待做事项的存根，而避免了为暴露的问题会遗留成更大的潜在障碍与灾难。</p><p>所以后会尝试更加活跃的写文章，同时会减少一些细节的注意力，如格式(其实已于中旬为Windows-Live-Writer结合Wordpress定制一个学科总结文模板，大大减少以后写作书面排版的工作)，拼写（不会写完一篇文章要来回几遍只为审查拼写与语法通顺）。会更加注重条理的整理，问题，观点，原因，解决方案式的条理陈述。方面会涉及到一些领域概念学习，个人想法，技术hacks，problem solve&amp;bug fix与软件使用心得等，篇幅会更加长短不定。</p><p>如同已到月末都不知如何凝练这个月的情感，却在百度的手写输入法中随手得到此字-乂(yì)，其一义是安稳的意思，而十一这个月不真是动荡中雕琢探求一片乂居么。</p><p>十一探乂的思语，探乂之时，勿忘居安思危，众多尚需改进与执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不经意的抬手看看时间，恰好手表那分针挡住了日期，多么希望看到时间为我所停驻，却已不由感觉只下徒劳，这是十一月的最后一天啊。&lt;/p&gt;
    
    </summary>
    
      <category term="指尖舞蹈" scheme="https://blog.vanjor.com/categories/life/"/>
    
    
      <category term="Mood" scheme="https://blog.vanjor.com/tags/mood/"/>
    
  </entry>
  
  <entry>
    <title>支持向量机SVM</title>
    <link href="https://blog.vanjor.com/2010/11/support-vector-machine/"/>
    <id>https://blog.vanjor.com/2010/11/support-vector-machine/</id>
    <published>2010-11-11T14:45:51.000Z</published>
    <updated>2010-11-11T14:45:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>支持向量机 Support Vector Machine, 简称<strong>SVM</strong>（或SV机），是一种监督是学习的方法，广泛应用于统计分类及回归分析中。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxkke2xtj306s04hjrg.jpg" alt="SVM"></p><p>其中, <strong>机</strong>（machine,机器）实际上是一个算法。在<a href="http://zh.wikipedia.org/zh/机器学习" target="_blank" rel="noopener">机器学习</a>(ML)领域里，常把一些算法看做是一个机器。</p><a id="more"></a><h1 id="SVM定义"><a href="#SVM定义" class="headerlink" title="SVM定义"></a>SVM定义</h1><p>参考WIKI定义：</p><blockquote><p><strong>支持向量机</strong> 将向量映射到一个更高维的空间裡，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。</p></blockquote><h1 id="SVM目的"><a href="#SVM目的" class="headerlink" title="SVM目的"></a>SVM目的</h1><p>分类是机器学习的一个常用手法，假设给定数据点（这些点不一定是R2 纬度集合中，可以是任意Rn 纬度中的店），每个都归属于某一个或几个类别，我们希望能够把这些点通过一个n-1维的<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">超平面</a>分开，通常这个被称为<a href="http://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8" target="_blank" rel="noopener">线性分类器</a>。</p><p>有很多分类器都符合这个要求，但是我们还希望找到分类最佳的平面，即使得属于两个不同类的数据点间隔最大的那个面，该面亦称为<strong>最大间隔超平面</strong>。如果我们能够找到这个面，那么这个分类器，就称为最大间隔分类器。<strong>支持向量机目的也就是一种最大间隔分类器。</strong></p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxll809ej307i05kmx0.jpg" alt="Svm_separating_hyperplanes"></p><p>（有很多个分类器(超平面)可以把数据分开，但是只有一个能够达到最大分割。H3不能准确分割，H1能分割但不能做到最大分割，H2则是最大分割）</p><h1 id="SVM推理引入"><a href="#SVM推理引入" class="headerlink" title="SVM推理引入"></a>SVM推理引入</h1><p>我们考虑以下形式的样本点<strong>D</strong>（n个数量的如下形式点集）：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxnrltecj309u0163ya.jpg" alt="svm"></p><p>其中:</p><ul><li><strong>_ci_</strong> 为1或−1 ,用以表示数据点属于哪个类.</li><li><strong>xi</strong> 是一个 <strong>_p_ 维向量</strong> ，其每个元素都被缩放到 [0, 1] 或 [-1, 1]. 缩放的目的是防止方差大的随机变量主导分类过程。</li></ul><p>我们可以把这些数据称为“训练数据”，希望我们的支持向量机能够通过一个超平面正确的把他们分开。超平面的数学形式可以写作:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxoerb4gj303s012gld.jpg" alt="svm"></p><p>根据几何知识，我们知道<strong>w</strong>向量垂直于分类超平面。<strong>w</strong>与<strong>x</strong>为<strong>内积</strong>，加入位移<strong>b</strong>的目的是增加间隔。如果没有<strong>b</strong>的话，那超平面将不得不通过原点，限制了这个方法的灵活性</p><p><strong>由于我们要求最大间隔</strong>，因此我们需要知道支持向量以及（与最佳超平面）平行的并且离支持向量最近的超平面。我们可以看到这些平行超平面可以由方程族：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxp8wykcj303n00zdfl.jpg" alt="svm"> and <img src="https://asset.vanjor.com/images/006tNbRwly1fynxpfvqh9j304600zdfl.jpg" alt="svm"></p><p>如果这些训练数据是线性可分的，那就可以找到这样两个超平面，在它们之间没有任何样本点并且这两个超平面之间的距离也最大。通过几何不难得到这两个超平面之间的距离是2/|<em><strong>w</strong></em>|，因此我们需要最小化 |<em><strong>w</strong></em>|。同时为了使得样本数据点都在超平面的间隔区以外，我们需要保证对于所有的<em><strong>i</strong></em> 满足其中的一个条件：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxq27ufqj303j00h741.jpg" alt="svm">对于第一类 <strong>xi</strong></p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxqoac9pj303x00h741.jpg" alt="svm"> 对于第二类 <strong>xi</strong></p><p>通过类别二元量 <strong>Ci</strong> 可以合并为：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxr5ih9wj309k00pwe9.jpg" alt="svm"></p><p>现在寻找最佳超平面这个问题就变成了在上式这个约束条件下最小化|<em><strong>w</strong></em>|. 这是一个<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92" target="_blank" rel="noopener">二次规划</a>(QP：Quadratic Programming)最优化中的问题。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxrj1i0uj308w08mt8n.jpg" alt="Svm_max_sep_hyperplane_with_margin(最大间隔超平面，两类分割数据集)"></p><p>更清楚的表示</p><p>求最小化<img src="https://asset.vanjor.com/images/006tNbRwly1fynxs8u77yj3013010741.jpg" alt="svm">，并且满足限定条件<img src="https://asset.vanjor.com/images/006tNbRwly1fynxsi4kdbj309g00lq2p.jpg" alt="svm"><br><em>(1/2这个因子是为了数学上表达的方便加上的)</em></p><p><strong>解如上问题通常的想法可能是使用非负</strong><a href="http://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0" target="_blank" rel="noopener"><strong>拉格朗日乘数</strong></a> <strong>α_i_ 于下式</strong></p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxt27qdaj30a3023gle.jpg" alt="svm"></p><p>不过这样可能出错. 原因是：假如我们能找到一族超平面将这些点分割开来；那么所有的 <img src="https://asset.vanjor.com/images/006tNbRwly1fynxzw4kqgj305000lgld.jpg" alt="svm">. 因此我们可能通过将所有α_i_趋向正无穷大得到最小值, 此最小值对这一族内所有成员都有效，而不是解决原问题的最优解。</p><p><strong>但是可以将约束问题表示为：</strong>（注：这一部分没弄得十分明白..）</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny2cdc72j30ai01jmwz.jpg" alt="svm"></p><p><strong>从而化解问题为寻找一个鞍点（saddle point）</strong>.</p><p>这样所有可以被<img src="https://asset.vanjor.com/images/006tNbRwly1fyny3a4sq3j304z00ldfl.jpg" alt="svm">分离的点就无关紧要了，因为我们必须设置相应的 αi 为零。</p><p><strong>这个问题现在可以用标准二次规划技术标准和程序解决</strong>。结论可以表示为如下<strong>训练向量的线性组合</strong></p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny0q17c3j303f01jjr5.jpg" alt="svm"></p><p>只有很少的 <strong>αi</strong> 会大于0. 相应的 <strong>xi</strong> 就是<strong>支持向量</strong>, 这些支持向量在边缘上并且满足 <img src="https://asset.vanjor.com/images/006tNbRwly1fyny5134vfj304z00ldfl.jpg" alt="svm">. 由此可以推导出支持向量也满足: <img src="https://asset.vanjor.com/images/006tNbRwly1fyny5so8bpj30a000l3ya.jpg" alt="svm">因此允许定义偏移量_b_. 实际上此支持向量比一般<em>N__S__V</em>的支持向量鲁棒性更强:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny77l52ej305w01na9u.jpg" alt="svm"></p><h2 id="SVM改进模型-软间隔（Soft-margin）"><a href="#SVM改进模型-软间隔（Soft-margin）" class="headerlink" title="SVM改进模型-软间隔（Soft margin）"></a>SVM改进模型-软间隔（Soft margin）</h2><p>1995年, <a href="http://zh.wikipedia.org/w/index.php?title=Corinna_Cortes&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Corinna Cortes</a>与Vapnik提出了一种改进的最大间隔区方法，这种方法可以处理标记错误的样本。如果可区分正负例的超平面不存在，则“软边界”将选择一个超平面尽可能清晰地区分样本，同时使其与分界最清晰的样本的距离最大化。这一成果使术语“支持向量机”（或“SVM”）得到推广。这种方法引入了松驰参数 <strong>ξ</strong><em><strong>i</strong></em> 以衡量对数据 <strong>x</strong> <strong>_i_</strong> 的误分类度。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny815832j308k00pt8h.jpg" alt="svm"></p><h1 id="SVM特性"><a href="#SVM特性" class="headerlink" title="SVM特性"></a>SVM特性</h1><p>SVM的特点可以总结为：</p><ol><li>SVM学习问题可以表示为凸优化问题，因此可以利用已知的有效算法发现目标函数的全局最小值。而其他分类方法（如基于规则的分类器和人工神经网络）都采用一种基于贪心学习的策略来搜索假设空间，这种方法一般只能获得局部最优解。</li><li>SVM通过最大化决策边界的边缘来控制模型的能力。尽管如此，用户必须提供其他参数，如使用核函数类型和引入松弛变量等。</li><li>通过对数据中每个分类属性引入一个哑变量，SVM可以应用与分类数据。</li><li>SVM不仅可以用在二类问题，还可以很好的处理多类问题，比如通过引入决策树模型。</li></ol><h1 id="SVM实现"><a href="#SVM实现" class="headerlink" title="SVM实现"></a>SVM实现</h1><h2 id="SVM实现难点与核心"><a href="#SVM实现难点与核心" class="headerlink" title="SVM实现难点与核心"></a>SVM实现难点与核心</h2><p>SVM的关键在于核函数。低维空间向量集通常难于划分，解决的方法是将它们映射到高维空间。但这个办法带来的困难就是计算复杂度的增加，而核函数正好巧妙地解决了这个问题。</p><p>也就是说，只要选用适当的核函数，就可以得到高维空间的分类函数。在SVM理论中，采用不同的核函数将导致不同的SVM算法。</p><h2 id="SVM开源实现工具LIBSVM"><a href="#SVM开源实现工具LIBSVM" class="headerlink" title="SVM开源实现工具LIBSVM"></a>SVM开源实现工具LIBSVM</h2><p><strong>LIBSVM</strong>工具主页：<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" title="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/libsvm/</a></p><p>是由台湾大学林智仁(Lin Chih-Jen)副教授等开发设计的一个简单、易于使用和快速有效的SVM模式识别与回归的软件包.</p><p>项目不但提供了编译好的可在Windows系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它操作系统上应用；该软件对SVM所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数可以解决很多问题；并提供了交互检验(Cross Validation)的功能。该软件可以解决C-SVM、ν-SVM、ε-SVR和ν-SVR等问题，包括基于一对一算法的多类模式识别问题</p><p>LIBSVM拥有Java、Matlab、C#、Ruby、Python、R、Perl、Common LISP、Labview等数十种语言版本。最常使用的是Matlab、Java和命令行的版本。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li>WIKI-SVM: <a href="http://en.wikipedia.org/wiki/Support_vector_machine" title="http://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Support_vector_machine</a></li><li>WIKI-支持向量机：<a href="http://zh.wikipedia.org/zh/支持向量机" title="http://zh.wikipedia.org/zh/支持向量机" target="_blank" rel="noopener">http://zh.wikipedia.org/zh/支持向量机</a></li><li>CSIE：<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" title="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/libsvm/</a></li><li>百科-SVM：<a href="http://baike.baidu.com/view/960509.html" title="http://baike.baidu.com/view/960509.html" target="_blank" rel="noopener">http://baike.baidu.com/view/960509.html</a></li><li>百科-支持向量机：<a href="http://baike.baidu.com/view/541845.htm" title="http://baike.baidu.com/view/541845.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/541845.htm</a></li><li>百科-LIBSVM: <a href="http://baike.baidu.com/view/598089.htm" title="http://baike.baidu.com/view/598089.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/598089.htm</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;支持向量机 Support Vector Machine, 简称&lt;strong&gt;SVM&lt;/strong&gt;（或SV机），是一种监督是学习的方法，广泛应用于统计分类及回归分析中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://asset.vanjor.com/images/006tNbRwly1fynxkke2xtj306s04hjrg.jpg&quot; alt=&quot;SVM&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中, &lt;strong&gt;机&lt;/strong&gt;（machine,机器）实际上是一个算法。在&lt;a href=&quot;http://zh.wikipedia.org/zh/机器学习&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;机器学习&lt;/a&gt;(ML)领域里，常把一些算法看做是一个机器。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="Classifier" scheme="https://blog.vanjor.com/tags/classifier/"/>
    
      <category term="SVM" scheme="https://blog.vanjor.com/tags/svm/"/>
    
  </entry>
  
  <entry>
    <title>线性回归</title>
    <link href="https://blog.vanjor.com/2010/11/linear-regression/"/>
    <id>https://blog.vanjor.com/2010/11/linear-regression/</id>
    <published>2010-11-10T08:06:21.000Z</published>
    <updated>2010-11-10T08:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性回归-Linear-regression"><a href="#线性回归-Linear-regression" class="headerlink" title="线性回归-Linear regression"></a>线性回归-Linear regression</h1><blockquote><p>在统计学中，线性回归是利用称为线性回归方程的<a href="http://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="noopener">最小二乘</a>函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合[1]</p></blockquote><a id="more"></a><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynsw1b1adj30b807tdfu.jpg" alt="一元线性回归-Linear_regression"></p><p>带一个自变量的的线性回归：一元线性回归</p><p>通俗来说：所谓线性回归模型就是指因变量和自变量之间的关系是直线型的。</p><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><p><a href="http://wiki.mbalib.com/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90" target="_blank" rel="noopener">回归分析</a>是对客观事物数量依存关系的分析．是<a href="http://wiki.mbalib.com/wiki/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1" target="_blank" rel="noopener">数理统计</a>中的一个常用的方法．是处理多个变量之间相互关系的一种数学方法[3]</p><blockquote><p>回归分析是一种统计学上对数据进行分析的方法，主要是希望探讨数据之间是否有一种特定关系。回归分析是建立因变量Y（或称依变量response variables, dependent variables）与自变量X（或称独变量，predictors, independent variables）之间关系的模型。目的在于了解两个或多个变量间是否相关、相关方向与强度，并建立数学模型以便观察特定变量来预测研究者感兴趣的变量[4]</p></blockquote><p>而线性回归是回归分析中的首要的一种分析研究方法，并广泛应用在各项实践分析领域。</p><h1 id="多元线性回归预测模型"><a href="#多元线性回归预测模型" class="headerlink" title="多元线性回归预测模型"></a>多元线性回归预测模型</h1><p>给定一个n组统计单元样本数据集 <img src="https://asset.vanjor.com/images/006tNbRwly1fynthkoen3j304g00la9t.jpg" alt="math">，一个线性回归模型假设因变量yi与p纬回归变量xi之间近似线性关系，这个近似关联模型建立通过引入一个误差项_εi_ (也是一个随机变量），来捕获除了x自变量之外任何对<em>Y__i</em>的影响。这样模型可以建立为：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntirsan6j30dc00nq2q.jpg" alt="math"></p><p>以向量方式可以表示为如下：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntqatoh5j302w00i0sh.jpg" alt="math"></p><p>其中：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntoav203j30ho031jrc.jpg" alt="math"></p><p>一般在科学论文研究中，做如下统一：</p><p>yi 称为因变量或从属变量（<em>regressand</em>）, xii称为回归量，自变量（<em>regressor</em>）</p><p>注：其中X通常会包含一个常数项,(不同于误差项_εi_ )，这时，观测值矩阵为[1] ：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynts0r0ksj305z031dfn.jpg" alt="math"></p><p>(如果_X_列之间存在线性相关，那麽参数向量β就不能以最小二乘法估计除非β被限制，比如要求它的一些元素之和为0)</p><h1 id="古典假设"><a href="#古典假设" class="headerlink" title="古典假设"></a>古典假设</h1><p>在线性回归模型理论中，样本是在总体之中随机抽取出来的。因变量在实直线上是连续的，误差项是独立同分布的，也就说，残差是i.i.d.(独立同分布，independent and identically distributed)且服从高斯分布。这些假设意味着残差项不依赖自变量的值，所以和自变量（预测变量）之间是相互独立的。</p><p>在这些假设下，建立一个显示线性回归作为条件预期模型的简单线性回归，可以表示为：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynttlwcykj306100lq2p.jpg" alt="math"></p><h1 id="最小二乘法估计-OLS"><a href="#最小二乘法估计-OLS" class="headerlink" title="最小二乘法估计(OLS)"></a>最小二乘法估计(OLS)</h1><p>最小二乘法(<a href="http://en.wikipedia.org/wiki/Ordinary_least_squares" target="_blank" rel="noopener">Ordinary least squares</a>[6])，是一种简洁并且常用的线性回归估计方法，回归分析的最初目的是估计模型的参数以便达到对数据的最佳拟合。在决定一个最佳拟合的不同标准之中，普通最小二乘法是非常优越的。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntvejl8sj30ab00tjr7.jpg" alt="math"></p><p>其中，最小二乘法是建立在无偏一致估计，建立在古典假设，认为<img src="https://asset.vanjor.com/images/006tNbRwly1fyntwxaae1j302u00k3y9.jpg" alt="math">之上。</p><p>在得到参数的最小二乘法的估计值之后，需要进行必要的检验与评价，以决定模型是否可以应用。关于最小二乘法估计的回归推断见<a href="http://zh.wikipedia.org/zh-cn/線性回歸" target="_blank" rel="noopener">线性回归</a>[1] ，多元回归模型的检验见多元线性回归分析预测法[3]</p><p>其他估计方法有：<a href="http://en.wikipedia.org/wiki/Generalized_least_squares" target="_blank" rel="noopener">Generalized least squares</a> (GLS)，<a href="http://en.wikipedia.org/wiki/Iteratively_reweighted_least_squares" target="_blank" rel="noopener">Iteratively reweighted least squares</a> (IRLS)等[2]</p><p>具体一元线性回归分析预测法分析见<a href="http://wiki.mbalib.com/wiki/一元线性回归预测法" target="_blank" rel="noopener">一元线性回归预测法</a>[5]</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://zh.wikipedia.org/zh-cn/線性回歸" title="http://zh.wikipedia.org/zh-cn/線性回歸" target="_blank" rel="noopener">http://zh.wikipedia.org/zh-cn/線性回歸</a></li><li><a href="http://en.wikipedia.org/wiki/Linear_regression" title="http://en.wikipedia.org/wiki/Linear_regression" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Linear_regression</a></li><li><a href="http://wiki.mbalib.com/w/index.php?title=%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%E6%B3%95" title="http://wiki.mbalib.com/wiki/线性回归预测法" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/线性回归预测法</a></li><li><a href="http://zh.wikipedia.org/zh-cn/迴歸分析" title="http://zh.wikipedia.org/zh-cn/迴歸分析" target="_blank" rel="noopener">http://zh.wikipedia.org/zh-cn/迴歸分析</a></li><li><a href="http://wiki.mbalib.com/wiki/一元线性回归预测法" title="http://wiki.mbalib.com/wiki/一元线性回归预测法" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/一元线性回归预测法</a></li><li><a href="http://en.wikipedia.org/wiki/Ordinary_least_squares" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ordinary_least_squares</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性回归-Linear-regression&quot;&gt;&lt;a href=&quot;#线性回归-Linear-regression&quot; class=&quot;headerlink&quot; title=&quot;线性回归-Linear regression&quot;&gt;&lt;/a&gt;线性回归-Linear regression&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在统计学中，线性回归是利用称为线性回归方程的&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最小二乘&lt;/a&gt;函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合[1]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="Linear Regression" scheme="https://blog.vanjor.com/tags/linear-regression/"/>
    
      <category term="Classifier" scheme="https://blog.vanjor.com/tags/classifier/"/>
    
  </entry>
  
  <entry>
    <title>向量空间模型VSM</title>
    <link href="https://blog.vanjor.com/2010/11/vector-space-model/"/>
    <id>https://blog.vanjor.com/2010/11/vector-space-model/</id>
    <published>2010-11-09T05:18:09.000Z</published>
    <updated>2010-11-09T05:18:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>向量空间模型 (VSM：Vector Space Model)</strong> 是一个应用于资讯过滤, 资讯撷取, 索引以及评估相关性的代数模型。由Salton等人于60年代提出，并成功地应用于著名的SMART文本检索系统。</p><a id="more"></a><h1 id="VSM概念"><a href="#VSM概念" class="headerlink" title="VSM概念"></a>VSM概念</h1><p>文件(语料)被视为索引词(关键字)形成的多次元向量空间， 索引词的集合通常为文件中至少出现过一次的词组。在文本检索中，文档与查询词可以表示为以下向量空间模型[1] :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dj = (w1,j,w2,j,...,wt,j)</span><br><span class="line"></span><br><span class="line">q = (w1,q,w2,q,...,wt,q)</span><br></pre></td></tr></table></figure><p>搜寻时，输入的检索词q会被转换成类似于文件的向量，这个模型假设，文件和搜寻词的相关程度，可以经由比较每个文件(向量)和检索词(向量)的夹角偏差程度而得知。 由此两个文档向量空间的夹角余弦为:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz2hn4byj304s01pmwx.jpg" alt="向量空间模型（VSM）"></p><p>而对应检索词q与文档集中文档d2的向量空间夹角余弦为 :</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz2tu1ddj304k01umwx.jpg" alt="vector"></p><p>在坐标系中如图:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz35rqdlj306805emx1.jpg" alt="向量空间模型-Vector Space Model"></p><p>(余弦为零表示检索词向量垂直于文件向量，即没有符合，也就是说该文件不含此检索词)</p><h1 id="VSM优势"><a href="#VSM优势" class="headerlink" title="VSM优势"></a>VSM优势</h1><p>向量空间模型相对标准布尔模型，优势在于:</p><ol><li>基于线性代数的简单模型</li><li>权重非简单的二值化</li><li>可以在查询与文档集见计算一个连续的相似度</li><li>可以按照文档集间的关联度做排序</li><li>可以进行局部匹配</li></ol><h1 id="VSM局限性"><a href="#VSM局限性" class="headerlink" title="VSM局限性"></a>VSM局限性</h1><ol><li>不适合处理过长的文件，因为近似值不理想（过小的<a href="http://zh.wikipedia.org/zh-cn/%E6%A0%87%E9%87%8F%E7%A7%AF" target="_blank" rel="noopener">标量积</a>以及过高的次元)。</li><li>检索词组必须要完全符合文件中出现的词组；不完整词组(子字串)会会生<a href="http://zh.wikipedia.org/w/index.php?title=False_positive&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">false positive</a>。</li><li>语言敏感度不佳；情境相同但使用不同语汇的文件无法被关连起来，这产生所谓的<a href="http://zh.wikipedia.org/w/index.php?title=False_negative&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">false negative</a></li><li>无法反应词语见的出现的顺序关联性</li><li>模型假设在词语特性均各自独立上</li><li>权重计算比较偏直觉经验上，而非十分正式</li></ol><p><strong>VSM通俗来说缺点</strong>:</p><ul><li>它的缺点是相似度的计算量大，当有新文档加入时，则必须重新计算词的权值；</li><li>不适合处理过长的文件，因为近似值不理想；</li><li>检索词组必须要完全符合文件中出现的词组，不完整词组(子字串)会会生false positive；</li><li>语言敏感度不佳，情境相同但使用不同语汇的文件无法被关联起来，这产生所谓的false negative。</li></ul><h1 id="VSM中的关键词-Term"><a href="#VSM中的关键词-Term" class="headerlink" title="VSM中的关键词(Term)"></a>VSM中的关键词(Term)</h1><p>向量空间模型是基于关键词标量模型的，关键词对于区分文档的作用是不同的。例如一些虚词对于区分文档的内容与查询是否相关并没有多大的意义。</p><p>对于概率模型而言，可以有完备的理论来估计每篇文档生成某个词的概率，因而其主要工作集中于如何确定较好的概率估计方法。而对于向量 空间模型来说，确定关键词权重在很大程度上依赖于研究者的经验及对文档特性的分析。</p><p>目前，对关键词权重的确定方法一般都需要获取一些关于关键词的统计量，而后根据这些统计量，应用某种认为规定的计算公式来得到权重。 最常用的统计量包括：</p><ul><li><strong>tf</strong>，(Term Frequency), 表示某个关键词在某个文档中出现的频率。</li><li><strong>qtf</strong>，(Query Term Frequency). 表示查询中某关键词的出现频率。</li><li><strong>N</strong>，(Num), 集合中的文档总数</li><li><strong>df</strong>，(Document Frequency), 的缩写，表示文档集合中，出现某个关键词的文档个数。</li><li><strong>idf</strong>，(Inversed Document Frequency), 的缩写。</li><li><strong>dl</strong>，(Document Length), 文档长度</li><li><strong>adl</strong>，(Average Document Length), 平均文档长度</li></ul><h1 id="VSM指导思想"><a href="#VSM指导思想" class="headerlink" title="VSM指导思想"></a>VSM指导思想</h1><p>在向量空间模型下，构造关键词权重计算公式有三个基本原则：</p><ol><li>如果一个关键词在某个文档中出现次数越多，那么这个词应该被认为越重要。</li><li>如果一个关键词在越多的文档中出现，那么这个词区分文档的作用就越低，于是其重要性也应当相应降低。</li><li>一篇文档越长，那么其出现某个关键词的次数可能越高，而每个关键词对这个文档的区分作用也越低，相应的应该对这些关键词予以一定的折扣。</li></ol><h1 id="扩展模型"><a href="#扩展模型" class="headerlink" title="扩展模型"></a>扩展模型</h1><p>基于向量空间模型上的扩展模型有</p><p>Models based on and extending the vector space model include:</p><ul><li><a href="http://en.wikipedia.org/wiki/Generalized_vector_space_model" target="_blank" rel="noopener">Generalized vector space model</a></li><li><a href="http://en.wikipedia.org/wiki/Topic-based_vector_space_model" target="_blank" rel="noopener">(enhanced) Topic-based Vector Space Model</a></li><li><a href="http://en.wikipedia.org/wiki/Latent_semantic_analysis" target="_blank" rel="noopener">Latent semantic analysis</a></li><li><a href="http://en.wikipedia.org/wiki/Latent_semantic_indexing" target="_blank" rel="noopener">Latent semantic indexing</a></li><li><a href="http://en.wikipedia.org/w/index.php?title=DSIR_model&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">DSIR model</a></li><li><a href="http://en.wikipedia.org/wiki/Term_Discrimination" target="_blank" rel="noopener">Term Discrimination</a></li><li><a href="http://en.wikipedia.org/wiki/Rocchio_Classification" target="_blank" rel="noopener">Rocchio Classification</a></li></ul><p><strong>参考:</strong></p><ol><li>WIKI, Vector Space Model：<a href="http://en.wikipedia.org/wiki/Vector_space_model" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Vector_space_model</a></li><li>SEO-VSM: <a href="http://www.dugutianjiao.com/post/vector-space-model-seo.html" target="_blank" rel="noopener">http://www.dugutianjiao.com/post/vector-space-model-seo.html</a></li><li>COGSYS,VSM:<a href="http://cogsys.imm.dtu.dk/thor/projects/multimedia/textmining/node5.html" target="_blank" rel="noopener">http://cogsys.imm.dtu.dk/thor/projects/multimedia/textmining/node5.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;向量空间模型 (VSM：Vector Space Model)&lt;/strong&gt; 是一个应用于资讯过滤, 资讯撷取, 索引以及评估相关性的代数模型。由Salton等人于60年代提出，并成功地应用于著名的SMART文本检索系统。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Information Retrieval" scheme="https://blog.vanjor.com/tags/information-retrieval/"/>
    
      <category term="Vector Space Model" scheme="https://blog.vanjor.com/tags/vector-space-model/"/>
    
  </entry>
  
  <entry>
    <title>TF-IDF统计</title>
    <link href="https://blog.vanjor.com/2010/11/tf-idf/"/>
    <id>https://blog.vanjor.com/2010/11/tf-idf/</id>
    <published>2010-11-09T05:04:21.000Z</published>
    <updated>2010-11-09T05:04:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TF-IDF</strong>（Term Frequency – Inverse Document Frequency）</p><p>TF-IDF是一种用于<a href="http://zh.wikipedia.org/zh-cn/%E8%B3%87%E8%A8%8A%E6%AA%A2%E7%B4%A2" target="_blank" rel="noopener">资讯检索</a>与<a href="http://zh.wikipedia.org/zh-cn/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98" target="_blank" rel="noopener">文本挖掘</a>的常用加权技术。TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度，也是建立在<a href="/2010/11/vector-space-model/">向量空间模型理论</a>中的一种统计技术。</p><p>字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，互联网上的搜寻引擎还会使用基于链接分析(PR)的评级方法，以确定文件在搜寻结果中出现的顺序。</p><a id="more"></a><h1 id="公式概念"><a href="#公式概念" class="headerlink" title="公式概念"></a>公式概念</h1><p>在一个文本集中，对于一份给定的文件</p><p><strong>词频</strong>（Term Frequency，TF）指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被正规化，以防止它偏向长的文件。（同一个词语在长文件里可能会比短文件有更高的词频，而不管该词语重要与否。）对于在某一特定文件里的词语 <em>t__i</em> 来说，它的词频(重要性)可表示为：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynys23fwdj303v01qmwx.jpg" alt="tfidf"></p><p>(以上式子中 ni,j 是该词在文件dj中的出现次数，而分母则是在文件dj中所有字词的出现次数之和)</p><p><strong>逆向文件频率</strong>（Inverse Document Frequency，IDF）是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynysdlg06j305t01vwe9.jpg" alt="tfidf"></p><p>(其中:</p><ul><li>| D |：语料库中的文件总数</li><li><img src="https://asset.vanjor.com/images/006tNbRwly1fynyuhu0g4j302t00k3y9.jpg" alt="tfidf">包含词语<em>t__i</em>的文件数目（即 <strong>ni,j != 0</strong>的文件数目）,如果关键词不在语料库中，这会导致除零错误，这种情况通常用1+<img src="https://asset.vanjor.com/images/006tNbRwly1fynyvjgwckj302t00k3y9.jpg" alt="tfidf">来代替。</li></ul><h1 id="TF-IDF权重："><a href="#TF-IDF权重：" class="headerlink" title="TF-IDF权重："></a>TF-IDF权重：</h1><p>由此，TF，IDF权重为TF，IDF的乘积</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynyzr2vxuj30g402gt8l.jpg" alt="tfidf"></p><p>为在整个文档集中，关键词Term i（最小单元）在文档j中的权重。某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p><h1 id="基于TF-IDF余弦相似度"><a href="#基于TF-IDF余弦相似度" class="headerlink" title="基于TF-IDF余弦相似度"></a>基于TF-IDF余弦相似度</h1><p>查询q与文档dj的余弦相似度可以表示为:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynyphga3bj30ci02g0sj.jpg" alt="tf-idf-cosine"></p><p>其中，i为q与文档dj 把q视作一个文档向量，i为dj 与q中的每一个元关键词标量。</p><h1 id="TF-IDF的理论依据与不足"><a href="#TF-IDF的理论依据与不足" class="headerlink" title="TF-IDF的理论依据与不足"></a>TF-IDF的理论依据与不足</h1><p>TF-IDF算法是建立在这样一个假设之上的:</p><blockquote><p>对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取TF词频作为测度，就可以体现同类文本的特点。</p><p>另外考虑到单词区别不同类别的能力，TF-IDF法认为一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。因此引入了逆文本频度IDF的概念，以TF和IDF的乘积作为特征空间坐标系的取值测度，并用它完成对权值TF的调整，调整权值的目的在于突出重要单词，抑制次要单词。</p></blockquote><p>但是在本质上IDF是一种试图抑制噪音的加权 ，并且单纯地认为文本频数小的单词就越重要，文本频数大的单词就越无用，显然这并不是完全正确的。IDF的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以TF-IDF法的精度并不是很高。</p><p>此外，在TFIDF算法中并没有体现出单词的位置信息，这也是空间向量模型的不足点。对于Web文档而言，权重的计算方法应该体现出HTML的结构特征。特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>WIKI,TF-IDF: <a href="http://en.wikipedia.org/wiki/Tf–idf" title="http://en.wikipedia.org/wiki/Tf–idf" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Tf–idf</a></li><li>BAIDU,TF-IDF: <a href="http://baike.baidu.com/view/1228847.html" title="http://baike.baidu.com/view/1228847.html" target="_blank" rel="noopener">http://baike.baidu.com/view/1228847.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TF-IDF&lt;/strong&gt;（Term Frequency – Inverse Document Frequency）&lt;/p&gt;
&lt;p&gt;TF-IDF是一种用于&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/%E8%B3%87%E8%A8%8A%E6%AA%A2%E7%B4%A2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;资讯检索&lt;/a&gt;与&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文本挖掘&lt;/a&gt;的常用加权技术。TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度，也是建立在&lt;a href=&quot;/2010/11/vector-space-model/&quot;&gt;向量空间模型理论&lt;/a&gt;中的一种统计技术。&lt;/p&gt;
&lt;p&gt;字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，互联网上的搜寻引擎还会使用基于链接分析(PR)的评级方法，以确定文件在搜寻结果中出现的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Information Retrieval" scheme="https://blog.vanjor.com/tags/information-retrieval/"/>
    
      <category term="TF-IDF" scheme="https://blog.vanjor.com/tags/tf-idf/"/>
    
  </entry>
  
  <entry>
    <title>信息检索基本评价指标-P·R·F</title>
    <link href="https://blog.vanjor.com/2010/11/recall-precision/"/>
    <id>https://blog.vanjor.com/2010/11/recall-precision/</id>
    <published>2010-11-08T13:40:34.000Z</published>
    <updated>2010-11-08T13:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何研究都需要有一个客观的评价体系，信息检索系统也不例外。但是对于一项需要在实际生产生活中应用的系统，其评价导向又必须包含一定的主观性。</p><p>信息检索系统性能的两个基本客观指标是 <strong>召回率(Recall Rate)</strong> 和 <strong>准确率(Precision Rate)</strong> 这与绝大多数的模式识别技术相同。</p><a id="more"></a><p>召回率和精度是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中召回率是是检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率。精度是检索出的相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率。</p><h1 id="概念公式"><a href="#概念公式" class="headerlink" title="概念公式"></a>概念公式</h1><blockquote><p>召回率 =  系统检索到的相关文件 / 系统所有相关的文件总数</p><p>准确率 = 系统检索到的相关文件 / 系统所有检索到的文件总数</p></blockquote><p>运用图示表示如下<br><img src="https://asset.vanjor.com/images/006tNbRwly1fynu9mb0drj30d70800sq.jpg" alt="召回率，准确率，F-measure"></p><h1 id="召回率，准确率关系"><a href="#召回率，准确率关系" class="headerlink" title="召回率，准确率关系"></a>召回率，准确率关系</h1><p>由于信息检索系统返回的是一个排序的文档集合，因此召回率与准确率是互补的。设定不同的相关性得分门限就能够得到相应的准确率与 召回率。如果我们在以准确率为Y轴，召回率为X轴的图上画出不同门限下的准确率与召回率，一般它会程下面的形状：</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxal1hldj309u07jjrb.jpg" alt="召回率 准确率关系"></p><p>那么，对于系统的评价指标就存在一个问题，如果一个系统偏重与给用户最准确的结果，那么高的准确率是必要的，反之，如果系统 希望包括尽可能多的相关结果，又会偏好召回率。系统如果简单的用召回率或准确率对系统性能作评价，无法评估系统的理想性能的。</p><h1 id="F-meause值"><a href="#F-meause值" class="headerlink" title="F-meause值"></a>F-meause值</h1><p>模式识别中常用F值作为性能的评价指标，其定义为以召回率R与准确率P为基础：F=2PR/P+R。</p><p><strong>F值以平衡地反映召回率与准确率，但是在信息检索中仍然不是非常实用，因为它仍然是一个单点的指标，没有反映全局特性</strong>。</p><p><strong>平均准确率(mean Average Precision, mAP):</strong></p><p>mAP是为解决P，R，F-measure的单点值局限性的。为了得到 一个能够反映全局性能的指标，可以看考察下图，其中两条曲线(方块点与圆点)分布对应了两个检索系统的准确率-召回率曲线。</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0z9bzkmj309u07it8p.jpg" alt="Mean-avg-prec"></p><p>可以看出，虽然两个系统的性能曲线有所交叠但是以圆点标示的系统的性能在绝大多数情况下要远好于用方块标示的系统。</p><p>从中我们可以 发现一点，如果一个系统的性能较好，其曲线应当尽可能的向上突出。更加具体的，曲线与坐标轴之间的面积应当越大。最理想的系统， 其包含的面积应当是1，而所有系统的包含的面积都应当大于0。这就是用以评价信息检索系统的最常用性能指标，</p><h1 id="平均准确率mAP"><a href="#平均准确率mAP" class="headerlink" title="平均准确率mAP"></a>平均准确率mAP</h1><p>其规范的定义如下:(其中P，R分别为准确率与召回率)</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxgyan35j304w019t8h.jpg" alt="mAP"></p><p>一般在做评价时取得的准确率与召回率都是离散值，因此一般在计算时都采用求和而非积分.</p><p>mAP是一个较好的客观评价指标，但是它也有一个缺陷，那就是</p><p><strong>缺乏直观性,是一个系统的总体性能评价指标，但无法反应区段间的变化。因此在系统评测时常常还是要附带上准确率-召回率曲线</strong>。</p><h1 id="单值评价指标N-Best"><a href="#单值评价指标N-Best" class="headerlink" title="单值评价指标N-Best"></a>单值评价指标N-Best</h1><p>在实际应用中，还有一些单值评价指标，能够反映系统的主观性能。其中最常用的是N-Best准确率。一般系统的返回结果都采用分页显示，用户一般 不会翻看太多页，从实际应用的角度看，前几个结果在检索中是最为重要的。N-Best准确率可以很好的反映这个性能。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>高勤,《汉语语音文档检索技术研究及系统实现》. 北京大学硕士研究生学位论文 <a href="http://geek.kyloo.net/public/master-thesis.pdf" target="_blank" rel="noopener">http://geek.kyloo.net/public/master-thesis.pdf</a></li><li>WIKI: <a href="http://zh.wikipedia.org/zh/%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2" target="_blank" rel="noopener">http://zh.wikipedia.org/zh/%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2</a></li><li>互动百科 <a href="http://www.hudong.com/wiki/%E5%8F%AC%E5%9B%9E%E7%8E%87" target="_blank" rel="noopener">http://www.hudong.com/wiki/%E5%8F%AC%E5%9B%9E%E7%8E%87</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何研究都需要有一个客观的评价体系，信息检索系统也不例外。但是对于一项需要在实际生产生活中应用的系统，其评价导向又必须包含一定的主观性。&lt;/p&gt;
&lt;p&gt;信息检索系统性能的两个基本客观指标是 &lt;strong&gt;召回率(Recall Rate)&lt;/strong&gt; 和 &lt;strong&gt;准确率(Precision Rate)&lt;/strong&gt; 这与绝大多数的模式识别技术相同。&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="Information Retrieval" scheme="https://blog.vanjor.com/tags/information-retrieval/"/>
    
  </entry>
  
  <entry>
    <title>Java开源自然语言处理-LingPipe</title>
    <link href="https://blog.vanjor.com/2010/11/lingpipe/"/>
    <id>https://blog.vanjor.com/2010/11/lingpipe/</id>
    <published>2010-11-08T12:00:00.000Z</published>
    <updated>2010-11-08T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://alias-i.com/lingpipe/" target="_blank" rel="noopener">LingPipe</a> 是<a href="http://alias-i.com/" target="_blank" rel="noopener">Alias-i</a>公司开发的一款自然语言处理开源Java软件包，目前最高版本是4.0.1</p><a id="more"></a><h1 id="LingPipe的优势"><a href="#LingPipe的优势" class="headerlink" title="LingPipe的优势"></a>LingPipe的优势</h1><ul><li>比较全面的覆盖自然语言处理的各个分支，文本分词，聚类，语义情感分析，领域知识学习等等</li><li>具有全套在research上免费的源码，样列代码，测试代码(商业与非商业均同一套代码)，并且文档详细，对于其中模型所参考的论文都引用出来，适合研究学习.</li><li>作为相对开源资源缺少的领域，项目一直持续更新中.</li></ul><h1 id="LinePipe包含的模块"><a href="#LinePipe包含的模块" class="headerlink" title="LinePipe包含的模块"></a>LinePipe包含的模块</h1><ul><li><strong>主题分类（Top Classification）</strong>: 基于文本语言模型训练，归类</li><li><strong>命名实体识别（Named Entity Recognition）</strong>: 基于first-best, n-best and per-entity confidence modes识别，以及训练与评估识别器</li><li><strong>聚类（Clustering）</strong>: 基于single-link and complete-link多层聚类，包裹一些聚类评估技术</li><li><strong>词性标注（Part-of Speech Tagging）</strong></li><li><strong>句题检测（Sentence Detection）</strong></li><li><strong>拼写更正（Spelling Correction）</strong>:基于”你要找的是” 风格的检查引擎</li><li><strong>数据库文本挖掘（Database Text Mining）</strong></li><li><strong>字符串比较(String Comparison)</strong>: 基于距离与相似度测量，包括权重距离，TF/IDF距离，Jaccard distance, Jaro-Winkler distance, 等</li><li><strong>兴趣短语检测（Interseting Phrase Detection）</strong></li><li><strong>字符语言建模（Character Language Modeling）</strong></li><li><strong>中文分词（Chinese Word Segmentation）</strong>: 基于空格分割类似训练库，机器学习，发现认知新词</li><li><strong>数据库文本挖掘（Database Text Mining）</strong></li><li><strong>情感分析（Sentiment Analysis）</strong>: 基于文本聚类</li><li><strong>断字识音（Hyphenation and Syllabification）</strong></li><li><strong>语言辨别（Language Identification）</strong></li><li><strong>奇异值分解（Singular Value Decomposition）</strong></li><li><strong>逻辑回归 （Logistic Regression）</strong></li><li><strong>期望最大化（Expectation Maximization）</strong></li><li><strong>词义排歧（Word Sense Disambiguation）</strong></li></ul><h1 id="LingPipe包含资源"><a href="#LingPipe包含资源" class="headerlink" title="LingPipe包含资源"></a>LingPipe包含资源</h1><ul><li>Source： <a href="http://alias-i.com/lingpipe/web/download.html" target="_blank" rel="noopener">http://alias-i.com/lingpipe/web/download.html</a></li><li>API Docs: <a href="http://alias-i.com/lingpipe/docs/api/index.html" target="_blank" rel="noopener">http://alias-i.com/lingpipe/docs/api/index.html</a></li><li>Tutorials: <a href="http://alias-i.com/lingpipe/demos/tutorial/read-me.html" target="_blank" rel="noopener">http://alias-i.com/lingpipe/demos/tutorial/read-me.html</a></li><li>Papaer&amp;language material : source，介绍中均包含有所引用资源</li></ul><p>目前个人应用LingPipe包中的中文分词，结合情感分析模块研究中文情感检测与辨别。API接口均已高度概括化，便于快速实现，不过所运用的算法需要详尽的分析。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://alias-i.com/lingpipe/" target="_blank" rel="noopener"><strong>LingPipe</strong></a>: <a href="http://alias-i.com/lingpipe" target="_blank" rel="noopener">http://alias-i.com/lingpipe</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://alias-i.com/lingpipe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LingPipe&lt;/a&gt; 是&lt;a href=&quot;http://alias-i.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alias-i&lt;/a&gt;公司开发的一款自然语言处理开源Java软件包，目前最高版本是4.0.1&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Machine Learning" scheme="https://blog.vanjor.com/tags/machine-learning/"/>
    
      <category term="NLU" scheme="https://blog.vanjor.com/tags/nlu/"/>
    
      <category term="LingPipe" scheme="https://blog.vanjor.com/tags/lingpipe/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法</title>
    <link href="https://blog.vanjor.com/2010/11/template-method/"/>
    <id>https://blog.vanjor.com/2010/11/template-method/</id>
    <published>2010-11-08T08:55:13.000Z</published>
    <updated>2010-11-08T08:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java Design Pattern - Template Method ( 模板方法 )</strong>.</p><a id="more"></a><h1 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h1><ul><li><strong>归类</strong>: 操作性模式</li><li><strong>目标</strong>: 在一个方法中实现一个算法，把算法中的某些步骤定义进行抽象，推迟到子类中去重新定义，或具体实现。</li><li><strong>实现方法</strong>: 准备一个抽象类，定义一个操作中的算法的骨架，将一些步聚声明为抽象方法迫使子类去实现。不同的子类可以以不同的方式实现这些抽象方法。</li><li><strong>样列</strong>: 以<a href="http://zh.wikipedia.org/zh/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">WIKI</a>中的的样列代码为列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An abstract class that is common to several games in</span></span><br><span class="line"><span class="comment">* which players play against the others, but only one is</span></span><br><span class="line"><span class="comment">* playing at a given time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> playersCount;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initializeGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makePlay</span><span class="params">(<span class="keyword">int</span> player)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">endOfGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWinner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A template method : */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">playOneGame</span><span class="params">(<span class="keyword">int</span> playersCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.playersCount = playersCount;</span><br><span class="line">        initializeGame();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!endOfGame())&#123;</span><br><span class="line">            makePlay(j);</span><br><span class="line">            j = (j + <span class="number">1</span>) % playersCount;</span><br><span class="line">        &#125;</span><br><span class="line">        printWinner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Now we can extend this class in order to implement actual games:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monopoly</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Implementation of necessary concrete methods */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePlay</span><span class="params">(<span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">endOfGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWinner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Specific declarations for the Monopoly game. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Implementation of necessary concrete methods */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePlay</span><span class="params">(<span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">endOfGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWinner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Specific declarations for the chess game. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于具有公用的程式，通过抽象类Game定义模板方法与对外行为步骤，明确对外行为规范，具体实现子类，ChessGame按照父类接口程式实现各自方法内部逻辑功能。</p><p>不同的子类游戏通过共同父类，实现统一接口，消除代码重复，与混乱不一致，并做到代码即是文档接口，方便他人扩展与实现。</p><p>模板方法不要求定义子类前编写具体模板方法，而是抽象算法框架，上移至超类，简化和组织代码，作为开发者间的一种约束。</p><p>这就是：</p><p>通常我们会遇到这样的一个问题：我们知道一个算法所需的关键步聚，并确定了这些步聚的执行顺序。但是某些步聚的具体实现是未知的，或者是某些步聚的实现与具体的环境相关。</p><p>模板方法模式把我们不知道具体实现的步聚封装成抽象方法，提供一些按正确顺序调用它们的具体方法(这些具体方法统称为模板方法),这样构成一个抽象基类。子类通过继承这个抽象基类去实现各个步聚的抽象方法，而工作流程却由父类来控制。</p><p><strong>JDK中样列</strong>:</p><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynygm0dzuj30dz053aa1.jpg" alt="template method"></p><p>JDK类：Arrays和Collections提供的sort(）方法</p><h1 id="深入模式"><a href="#深入模式" class="headerlink" title="深入模式"></a>深入模式</h1><p><strong>模式中两种角色</strong>:</p><ul><li><strong>抽象模版（AbstractClass</strong>: 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。定义并实现了一个模版方法。这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li><li><strong>具体模版（ConcreteClass）</strong>: 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。每一个抽象模版角色都可以有任意多个具体模版角色与之对应，而每一个具体模版角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li></ul><p><strong>适用场景</strong>:</p><p>在高级语言中，模板方法通过多态，继承，封装而灵活的应用，总之模板类适用于以下场景：</p><ul><li><strong>延迟具体实现</strong>: 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li><strong>公用行为归纳</strong>: 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。其实这可以说是一种好的编码习惯了。</li><li><strong>控制子类扩展</strong>: 模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。如果不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做：一是在API中不体现出你的模板方法；二将模板方法置为final组织被覆盖。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Javaeye: <a href="http://www.javaeye.com/topic/78611" target="_blank" rel="noopener">http://www.javaeye.com/topic/78611</a></li><li>cnBlog: <a href="http://www.cnblogs.com/zhenyulu/articles/79894.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhenyulu/articles/79894.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java Design Pattern - Template Method ( 模板方法 )&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="知识积累" scheme="https://blog.vanjor.com/categories/learning/"/>
    
    
      <category term="Java" scheme="https://blog.vanjor.com/tags/java/"/>
    
      <category term="Design Pattern" scheme="https://blog.vanjor.com/tags/design-pattern/"/>
    
  </entry>
  
</feed>
