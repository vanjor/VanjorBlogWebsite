<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>告别2019</title>
    <url>/2019/12/fareware_2019/</url>
    <content><![CDATA[<p>时间过得飞快，2019年马上就要过去，再有四天就要步入2020年了。</p>
<a id="more"></a>
<p>最近几年生活上变化比较大，在2019年悬而未决的进程-工作签证问题早在一月中旬欣然的落定了，一个非常好的开端，在二月中旬，举家迁徙来到西雅图，来到地球另一端的这个城市开启完全不一样的生活。</p>
<p>在这一年里生活上有几件大事，五月买了车，梦想中7座SUV, 八月买了房，梦想中的独立庭院的山间别墅，九月H1B抽中并顺利通过只等大使馆激活，小十一也健康的成长，并开始蹦蹦跳跳，翻箱倒柜了。</p>
<p>虽然相比之下，工作上的进展就缓慢平淡的许多，仍在调整适应。</p>
<p>2020年即将到来，有些期许，希望能在工作生活的达到一种良好的平衡，工作上能有说更大进展，生活上能多一些时间陪伴，多一起做些尝试，多留下一些美好的记忆。财务中慢慢更加清晰的规划和执行，身份问题顺利进展，政策稳定明朗。</p>
<p>附: </p>
<p>Christmas Eve当天即兴去Warmat买了彩灯并装饰房屋，算是入乡随俗，也尊重下邻里。<br><img src="https://asset.vanjor.com/imgs/home_exterior_santa_lantern.jpeg" alt="article-logo"></p>
<p>Christmas Eve Living Room的装饰<br><img src="https://asset.vanjor.com/imgs/home_santa_interior_deer.jpeg" alt="article-logo"></p>
<p>与小十一的15个月的合照<br><img src="https://asset.vanjor.com/imgs/vanjor_15_months.jpg" alt="article-logo"></p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn on AWS DynamoDB</title>
    <url>/2019/06/dynamo-db-learning-summary/</url>
    <content><![CDATA[<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><ul>
<li>Tables: same with RDS</li>
<li>Items: similar as record/row in RDS</li>
<li>Attributes: similarcolumns in RDS</li>
</ul>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul>
<li>A key-value and document database</li>
<li>Fully cloud host, auto scale </li>
<li>No connection pool, only concurrent concept to avoid break limit for Dynamodb API is based on web service.</li>
</ul>
<a id="more"></a>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul>
<li>Table: A table is a collection of data</li>
<li>Item: Similar to row in RDB, Each table contains zero or more items. An item is a group of attributes that is uniquely identifiable among all of the other items.</li>
<li>Attribute: Each item is composed of one or more attributes. An attribute is a fundamental data element. Similar to column in RDB, each item contains multiple attributes.</li>
</ul>
<h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><ul>
<li>Primary key (aka: Primary Index)</li>
<li>Secondary Index<ul>
<li>Local Secondary Indexes (LSI)</li>
<li>Global Secondary Indexe (GSI)</li>
</ul>
</li>
</ul>
<h3 id="Primary-key"><a href="#Primary-key" class="headerlink" title="Primary key"></a>Primary key</h3><p>Table must define the primary key, support two types:</p>
<ul>
<li>partition key:<ul>
<li>aka: hash attribute</li>
<li>should be unique</li>
<li>dynamo will run hash function on this to decide partition for physical storage.</li>
</ul>
</li>
<li>partition key and sort key:<ul>
<li>a composite key with two attributes</li>
<li>aka: hash attribute + range attribute</li>
<li>partition key + sort key should be unique, while partition key can be not unique.</li>
<li>All items with the same partition key value are stored together, in sorted order by sort key.</li>
</ul>
</li>
</ul>
<p>More introduction:</p>
<ul>
<li>The only data types allowed for primary key attributes are string, number, or binary</li>
</ul>
<h3 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h3><p>DynamoDB supports two kinds of indexes:</p>
<ul>
<li>Global secondary index – An index with a partition key and sort key that can be different from table primary key. support eventually consistent or strongly consistent reads.</li>
<li>Local secondary index – An index that has the same partition key with table primary key, but have a different sort key. only support eventually consistent reads.</li>
</ul>
<p>Each table in DynamoDB has a limit of 20 global secondary indexes (default limit) and 5 local secondary indexes per table.</p>
<h2 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h2><ul>
<li>Scalar Types: Number(int, long, double, float), String, Boolean, Bytes, Date.</li>
<li>Collection types: Set</li>
<li>Support any user defined type by using DynamoDBTypeConverter.</li>
</ul>
<h2 id="Retrieve-Operation"><a href="#Retrieve-Operation" class="headerlink" title="Retrieve Operation"></a>Retrieve Operation</h2><ul>
<li>Query: must specify a partition key value; the sort key is optional.</li>
<li>Scan: lower efficient.</li>
</ul>
<h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><ul>
<li>A Query operation always returns a result set. will be empty Set if not found.</li>
<li>Query results are always sorted by the sort key value. By default, the sort order is ascending. We can set the ScanIndexForward parameter to false to reverse order.</li>
<li>A single Query operation can retrieve a maximum of 1 MB of data. This limit applies before any FilterExpression is applied to the results. If LastEvaluatedKey is present in the response and is non-null, we will need to paginate the result set.</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>AWS official document: <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html</a></li>
<li>AWS DDB data types: <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.DataTypes.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.DataTypes.html</a></li>
<li>DDB study notes:  <a href="https://rickhw.github.io/2016/08/17/AWS/Study-Notes-DynamoDB/" target="_blank" rel="noopener">https://rickhw.github.io/2016/08/17/AWS/Study-Notes-DynamoDB/</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>DynamoDB</tag>
        <tag>AWS</tag>
      </tags>
  </entry>
  <entry>
    <title>告别2018</title>
    <url>/2018/12/fareware_2018/</url>
    <content><![CDATA[<p>来不及回忆，来不及告别，2018马上就悄然而去了。</p>
<a id="more"></a>
<p>2018最大的收获，宝宝小十一降生了，过程比我想的要顺利，宝宝也我期望的也要更可爱。</p>
<p>2018也有许些遗憾，有戛然而止的期待，也有悬而未决进程。不过宝宝的到来，让我开始沉稳了些，因为遗憾的事不再是生活的全部，每天看着宝宝快乐的成长，前方的路总会是有的。</p>
<p>2018年的最后一周，重新捡起了博客，升级了程序代码，迁移下旧的博客内容，写了个小程序自动备份博客图片，让它变的更完整了，至此再也不担心丢失什么了。</p>
<p>最近多次触动到感悟: “人生很短, 活明白太迟”, 真切的感受到要重视并利用好时间，去做些有意义的事情，不苟且眼前的工作。不希望到老来回忆起来是太多虚度年华，留下太多遗憾。</p>
<p>当感受到眼前的剧烈起伏，跳出来，把目光放远，收获你的定力，坚定你的动力。</p>
<p>2019, 我来了，你呢？</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Maven的Java包版本管理</title>
    <url>/2016/10/maven-version-control/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk9jm52b3j30zk085dfw.jpg" alt="maven logo"></p>
<p>Java打包与依赖奠定了软件包发布与版本管理的依赖的一个业界规范。</p>
<a id="more"></a>
<h1 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h1><p>Maven中版本号类似1.0,1.1,1.1.1,主题规则如下</p>
<blockquote>
<p>&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;</p>
</blockquote>
<p>其中:</p>
<ul>
<li>主版本: 重大架构变更，类似maven1和maven2，兼容性业不一定保证的，Gitlab项目以年为粒度迭代</li>
<li>次版本：功能模块级别的变更，Gitlab项目已月为粒度迭代</li>
<li>增量版本：补丁buffix级别，一般针对次版本的发布的功能等快速修复，Gitlab以天或周级别迭代</li>
</ul>
<h1 id="snapshot与release区别"><a href="#snapshot与release区别" class="headerlink" title="snapshot与release区别"></a>snapshot与release区别</h1><p>release是稳定版，但在开发中为了解决间依赖的项目间并行开发，可以基于snapshot快速迭代，而不需要频繁变更pom.xml中依赖的版本</p>
<ul>
<li>snapshot：用于保存开发过程中不稳定版本，一般允许redeploy</li>
<li>release：用于保存稳定发布的版本，一般不允许redeploy</li>
</ul>
<p>假设当前CodeOne，已发布1.0.0 release版本，现在开发新的功能。</p>
<ul>
<li>更新pom版本从1.0.0 到 1.1.0-SNAPSHOT</li>
<li>不断开发功能，持续发布1.1.0-SNAPSHOT版本, 开发完毕后需要正式发布</li>
<li>更新pom版本从1.1.0-SNAPSHOT 到 1.1.0，并项目打上tag 1.1.0,完成1.1.0 release正式版发布.</li>
</ul>
<p>注意: 一般发布是不分源代码项目分支的，如果多个分支需要各自迭代，可实现安排号发布版本号区别，比如 1.1.0-SNAPSHOT与1.2.0-SNAPSHOT</p>
<h1 id="maven发布规则"><a href="#maven发布规则" class="headerlink" title="maven发布规则"></a>maven发布规则</h1><h2 id="snapshot发布"><a href="#snapshot发布" class="headerlink" title="snapshot发布"></a>snapshot发布</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vanjor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>-SNAPSHOT(必须大写)，maven将自动判断为snapshot发布</p>
<p>如果发布到 <a href="http://central.maven.org/maven2/" target="_blank" rel="noopener">http://central.maven.org/maven2/</a> 中，则实际发布地址为：</p>
<blockquote>
<p><a href="http://central.maven.org/maven2/com/vanjor/demo/0.1-SNAPSHOT/demo-0.1-20161020.091255-1.jar" target="_blank" rel="noopener">http://central.maven.org/maven2/com/vanjor/demo/0.1-SNAPSHOT/demo-0.1-20161020.091255-1.jar</a></p>
</blockquote>
<p>其中demo-0.1-20161020.091255-1.jar, snapshot将自动被转换为 日期-时间-迭代次数</p>
<h2 id="release发布"><a href="#release发布" class="headerlink" title="release发布"></a>release发布</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vanjor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果发布到 <a href="http://central.maven.org/maven2/" target="_blank" rel="noopener">http://central.maven.org/maven2/</a> 中，则实际发布地址为：</p>
<blockquote>
<p><a href="http://central.maven.org/maven2/com/vanjor/demo/0.1/demo-0.1.jar" target="_blank" rel="noopener">http://central.maven.org/maven2/com/vanjor/demo/0.1/demo-0.1.jar</a></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://juvenshun.iteye.com/blog/376422" target="_blank" rel="noopener">http://juvenshun.iteye.com/blog/376422</a></li>
<li><a href="http://liyixing1.iteye.com/blog/2171254" target="_blank" rel="noopener">http://liyixing1.iteye.com/blog/2171254</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习指南</title>
    <url>/2016/05/git-complete-user-guide/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk93b0u54j30xc0hi759.jpg" alt="article-logo"></p>
<a id="more"></a>
<h1 id="Git-工作原理"><a href="#Git-工作原理" class="headerlink" title="Git 工作原理"></a>Git 工作原理</h1><p>Git作为一种分布式代码仓库，便在设计上区别与SVN</p>
<h2 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h2><h3 id="simplest"><a href="#simplest" class="headerlink" title="simplest"></a>simplest</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk93ufs6oj30uy0k5757.jpg" alt="git workflow basic"></p>
<h3 id="detailer"><a href="#detailer" class="headerlink" title="detailer"></a>detailer</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk94abf3wj30dm0b0dft.jpg" alt="git workflow complex"></p>
<h3 id="comprehension"><a href="#comprehension" class="headerlink" title="comprehension"></a>comprehension</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyl9gxi6mhj30sg0ift9c.jpg" alt="complex workflow"></p>
<h3 id="multiple-remote-repos"><a href="#multiple-remote-repos" class="headerlink" title="multiple remote repos"></a>multiple remote repos</h3><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk963sdybj30sg0r4tak.jpg" alt="multiple remote repos"></p>
<h3 id="扩展参考"><a href="#扩展参考" class="headerlink" title="扩展参考"></a>扩展参考</h3><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git - 简明指南</a></li>
<li><a href="https://www.sonassi.com/blog/knowledge-base/our-magento-git-guide-and-work-flow" target="_blank" rel="noopener">Our Magento Git Guide and Work Flow</a></li>
<li><a href="https://www.quora.com/What-is-the-best-Git-cheat-sheet" target="_blank" rel="noopener">What is the best Git cheat sheet?</a></li>
</ul>
<h1 id="Git-常用命令清单"><a href="#Git-常用命令清单" class="headerlink" title="Git 常用命令清单"></a>Git 常用命令清单</h1><p>重度参考 <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a> ，有增删改纠。 以下为常用的20几个命令分类介绍</p>
<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 新建一个目录，并初始化为本地Git代码库</span><br><span class="line"><span class="meta">$</span> git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下载一个远程Git项目代码库到指定目录</span><br><span class="line"><span class="meta">$</span> git clone &lt;repository_uri&gt; [directory]</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 查看当前git配置</span><br><span class="line"><span class="meta">$</span> git config --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编辑git配置, global为用户全局配置</span><br><span class="line"><span class="meta">$</span> git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置当前用户信息，提交代码需要</span><br><span class="line"><span class="meta">$</span> git config [--global] user.name "[name]"</span><br><span class="line"><span class="meta">$</span> git config [--global] user.email "[email address]"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置项目git忽略文件/夹列表, 项目根目录创建.gitignore文件</span><br><span class="line"><span class="meta">$</span> echo ".project" &gt;&gt; .gitigore</span><br></pre></td></tr></table></figure>
<h2 id="增删文件"><a href="#增删文件" class="headerlink" title="增删文件"></a>增删文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 添加文件/目录到暂存区(stage/index)</span><br><span class="line"><span class="meta">$</span> git add [file1] [file2]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加当前目录所有文件到暂存区</span><br><span class="line"><span class="meta">$</span> git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加当前项目所有文件到暂存区</span><br><span class="line"><span class="meta">$</span> git add --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除[递归]指定workspace文件或目录</span><br><span class="line"><span class="meta">$</span> git rm [-r] [file1] [file2]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 停止追踪指定文件，git add的反向操作</span><br><span class="line"><span class="meta">$</span> git rm --cached [file]</span><br></pre></td></tr></table></figure>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 将变更从暂存区提交到本地仓库</span><br><span class="line"><span class="meta">$</span> git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动stage哪些已经被修改或删除的文件（新增文件无效）, 一并提交到本地仓库</span><br><span class="line"><span class="meta">$</span> git commit -am [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用一次新的commit，替代上一次提交，并包含当前stage的变更</span><br><span class="line"><span class="meta">$</span> git commit --amend -m [message]</span><br></pre></td></tr></table></figure>
<h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 列举所有本地分支, -a 包含远程分支</span><br><span class="line"><span class="meta">$</span> git branch [-a]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 对当前分支新建一个分支，仍停留在当前分支</span><br><span class="line"><span class="meta">$</span>  git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 对当前分支新建一个分支，切换工作区间到新分支</span><br><span class="line"><span class="meta">$</span> git checkout -b [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 合并指定分支到当前分支</span><br><span class="line"><span class="meta">$</span> git merge [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 选择一个commit，仅合并改commit到当前分支</span><br><span class="line"><span class="meta">$</span> git cherry-pick [commit-hashcode]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除分支</span><br><span class="line"><span class="meta">$</span> git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除远程分支</span><br><span class="line"><span class="meta">$</span> git branch -dr [branch-name]</span><br><span class="line"><span class="meta">$</span> git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 显示变更文件</span><br><span class="line"><span class="meta">$</span> git status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示当前仓库中所有版本历史, stat显示变更文件</span><br><span class="line"><span class="meta">$</span> git log [--stat]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示某个文件的历史版本，包括改名</span><br><span class="line"><span class="meta">$</span> git log --follow [file]</span><br><span class="line"><span class="meta">$</span> git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示指定文件每一行是什么人在什么时间修改过</span><br><span class="line"><span class="meta">$</span> git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示暂存区和工作区的差异</span><br><span class="line"><span class="meta">$</span> git diff</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示暂存区和本地仓库(最后一次commit)的差异</span><br><span class="line"><span class="meta">$</span> git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示工作区和本地仓库(最后一次commit)的差异</span><br><span class="line"><span class="meta">$</span> git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示某次提交的具体变动内容</span><br><span class="line"><span class="meta">$</span> git show [commit-hashcode]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示本地仓库最近几次提交 (当前分支)</span><br><span class="line"><span class="meta">$</span> git reflog [branch]</span><br></pre></td></tr></table></figure>
<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 取回远程仓库所有变动</span><br><span class="line"><span class="meta">$</span> git fetch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 取回远程仓库所有变动到本地仓库，并与本地分支合并</span><br><span class="line"><span class="meta">#</span> 相当于 git fetch &amp; git merge</span><br><span class="line"><span class="meta">$</span> git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line"><span class="meta">$</span> git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 推送所有分支到远程仓库</span><br><span class="line"><span class="meta">$</span> git push [remote] --all</span><br></pre></td></tr></table></figure>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 恢复暂存区的指定文件(最后一次添加到暂存区的版本)到工作区，清除工作区改文件的修改</span><br><span class="line"><span class="meta">$</span> git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 恢复暂存区的所有文件到工作区</span><br><span class="line"><span class="meta">$</span> git checkout .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变， git add 逆向操作</span><br><span class="line"><span class="meta">$</span> git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line"><span class="meta">$</span> git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line"><span class="meta">$</span> git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 暂时将未提交的变化移除，稍后再移入</span><br><span class="line"><span class="meta">$</span> git stash</span><br><span class="line"><span class="meta">$</span> git stash pop</span><br></pre></td></tr></table></figure>
<h1 id="Git-的特点"><a href="#Git-的特点" class="headerlink" title="Git 的特点"></a>Git 的特点</h1><h2 id="Git与SVN常用命令对比"><a href="#Git与SVN常用命令对比" class="headerlink" title="Git与SVN常用命令对比"></a>Git与SVN常用命令对比</h2><table>
<thead>
<tr>
<th>操作</th>
<th>svn</th>
<th>git</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建</td>
<td>svnadmin create</td>
<td>git init</td>
</tr>
<tr>
<td>签出</td>
<td>svn checkout</td>
<td>git clone</td>
</tr>
<tr>
<td>更新</td>
<td>svn update</td>
<td>git pull</td>
</tr>
<tr>
<td>添加</td>
<td>svn add</td>
<td>git add</td>
</tr>
<tr>
<td>提交</td>
<td>svn commit</td>
<td>git commit</td>
</tr>
<tr>
<td>查看状态</td>
<td>svn status</td>
<td>git status</td>
</tr>
<tr>
<td>合并</td>
<td>svn merge</td>
<td>git merge</td>
</tr>
<tr>
<td>回滚</td>
<td>svn revert</td>
<td>git checkout</td>
</tr>
<tr>
<td>diff</td>
<td>svn diff</td>
<td>git diff</td>
</tr>
<tr>
<td>创建分支</td>
<td>svn copy</td>
<td>git branch</td>
</tr>
<tr>
<td>切换分支</td>
<td>git checkout</td>
<td>svn switch</td>
</tr>
</tbody>
</table>
<h2 id="Git-特点"><a href="#Git-特点" class="headerlink" title="Git 特点"></a>Git 特点</h2><ul>
<li>分布式代码版本控制</li>
<li>基于清点引用的方式进行变更追踪</li>
</ul>
<h1 id="Git-完整命令清单"><a href="#Git-完整命令清单" class="headerlink" title="Git 完整命令清单"></a>Git 完整命令清单</h1><h2 id="Git-官方最常用命令"><a href="#Git-官方最常用命令" class="headerlink" title="Git 官方最常用命令"></a>Git 官方最常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git help</span><br><span class="line">The most commonly used git commands are:</span><br><span class="line"> add        Add file contents to the index</span><br><span class="line"> bisect     Find by binary search the change that introduced a bug</span><br><span class="line"> branch     List, create, or delete branches</span><br><span class="line"> checkout   Checkout a branch or paths to the working tree</span><br><span class="line"> clone      Clone a repository into a new directory</span><br><span class="line"> commit     Record changes to the repository</span><br><span class="line"> diff       Show changes between commits, commit and working tree, etc</span><br><span class="line"> fetch      Download objects and refs from another repository</span><br><span class="line"> grep       Print lines matching a pattern</span><br><span class="line"> init       Create an empty Git repository or reinitialize an existing one</span><br><span class="line"> log        Show commit logs</span><br><span class="line"> merge      Join two or more development histories together</span><br><span class="line"> mv         Move or rename a file, a directory, or a symlink</span><br><span class="line"> pull       Fetch from and integrate with another repository or a local branch</span><br><span class="line"> push       Update remote refs along with associated objects</span><br><span class="line"> rebase     Forward-port local commits to the updated upstream head</span><br><span class="line"> reset      Reset current HEAD to the specified state</span><br><span class="line"> rm         Remove files from the working tree and from the index</span><br><span class="line"> show       Show various types of objects</span><br><span class="line"> status     Show the working tree status</span><br><span class="line"> tag        Create, list, delete or verify a tag object signed with GPG</span><br></pre></td></tr></table></figure>
<h2 id="Git-全部命令清单"><a href="#Git-全部命令清单" class="headerlink" title="Git 全部命令清单"></a>Git 全部命令清单</h2><p>全部命令共155个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git help</span><br><span class="line">  add                       fsck                      receive-pack</span><br><span class="line">  add--interactive          fsck-objects              reflog</span><br><span class="line">  am                        gc                        relink</span><br><span class="line">  annotate                  get-tar-commit-id         remote</span><br><span class="line">  apply                     grep                      remote-ext</span><br><span class="line">  archimport                gui                       remote-fd</span><br><span class="line">  archive                   gui--askpass              remote-ftp</span><br><span class="line">  bisect                    hash-object               remote-ftps</span><br><span class="line">  bisect--helper            help                      remote-http</span><br><span class="line">  blame                     http-backend              remote-https</span><br><span class="line">  branch                    http-fetch                remote-testsvn</span><br><span class="line">  bundle                    http-push                 repack</span><br><span class="line">  cat-file                  index-pack                replace</span><br><span class="line">  check-attr                init                      request-pull</span><br><span class="line">  check-ignore              init-db                   rerere</span><br><span class="line">  check-mailmap             instaweb                  reset</span><br><span class="line">  check-ref-format          interpret-trailers        rev-list</span><br><span class="line">  checkout                  log                       rev-parse</span><br><span class="line">  checkout-index            ls-files                  revert</span><br><span class="line">  cherry                    ls-remote                 rm</span><br><span class="line">  cherry-pick               ls-tree                   send-email</span><br><span class="line">  citool                    mailinfo                  send-pack</span><br><span class="line">  clean                     mailsplit                 sh-i18n--envsubst</span><br><span class="line">  clone                     merge                     shell</span><br><span class="line">  column                    merge-base                shortlog</span><br><span class="line">  commit                    merge-file                show</span><br><span class="line">  commit-tree               merge-index               show-branch</span><br><span class="line">  config                    merge-octopus             show-index</span><br><span class="line">  count-objects             merge-one-file            show-ref</span><br><span class="line">  credential                merge-ours                stage</span><br><span class="line">  credential-cache          merge-recursive           stash</span><br><span class="line">  credential-cache--daemon  merge-resolve             status</span><br><span class="line">  credential-store          merge-subtree             stripspace</span><br><span class="line">  cvsexportcommit           merge-tree                submodule</span><br><span class="line">  cvsimport                 mergetool                 svn</span><br><span class="line">  cvsserver                 mktag                     symbolic-ref</span><br><span class="line">  daemon                    mktree                    tag</span><br><span class="line">  describe                  mv                        unpack-file</span><br><span class="line">  diff                      name-rev                  unpack-objects</span><br><span class="line">  diff-files                notes                     update-index</span><br><span class="line">  diff-index                p4                        update-ref</span><br><span class="line">  diff-tree                 pack-objects              update-server-info</span><br><span class="line">  difftool                  pack-redundant            upload-archive</span><br><span class="line">  difftool--helper          pack-refs                 upload-pack</span><br><span class="line">  fast-export               patch-id                  var</span><br><span class="line">  fast-import               prune                     verify-commit</span><br><span class="line">  fetch                     prune-packed              verify-pack</span><br><span class="line">  fetch-pack                pull                      verify-tag</span><br><span class="line">  filter-branch             push                      web--browse</span><br><span class="line">  fmt-merge-msg             quiltimport               whatchanged</span><br><span class="line">  for-each-ref              read-tree                 write-tree</span><br><span class="line">  format-patch              rebase</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git 官方中文手册</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a></li>
<li><a href="http://gitref.org/zh/index.html" target="_blank" rel="noopener">Git 参考手册-命令详解</a></li>
</ul>
<h2 id="Git-cheat-sheet"><a href="#Git-cheat-sheet" class="headerlink" title="Git cheat sheet"></a>Git cheat sheet</h2><p><img src="https://asset.vanjor.com/images/006tNbRwly1fyk97sbhsxj30sg0kddij.jpg" alt="git-cheatsheet"></p>
<h1 id="Git-深入学习"><a href="#Git-深入学习" class="headerlink" title="Git 深入学习"></a>Git 深入学习</h1><h2 id="git-reset-git-checkout-git-revert-区别"><a href="#git-reset-git-checkout-git-revert-区别" class="headerlink" title="git reset, git checkout, git revert 区别"></a>git reset, git checkout, git revert 区别</h2><p>svn主要有revert，而git有三个，</p>
<p> git reset用于撤销未被提交到远端的改动。除了可以移动当前分支的HEAD，你可以通过不同的标记选择修改 staged snapshot 或者 working directory</p>
<ul>
<li>–soft： staged snapshot 和 working directory 都未被改变 (建议在命令行执行后，再输入 git status 查看状态)</li>
<li>–mixed： staged snapshot 被更新， working directory 未被更改。【这是默认选项】（建议同上)</li>
<li>–hard： staged snapshot 和 working directory 都将回退。</li>
</ul>
<p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting" target="_blank" rel="noopener">Reset, Checkout, and Revert</a>, <a href="http://blog.mexiqq.com/index.php/archives/3/" target="_blank" rel="noopener">中文翻译</a></p>
<h2 id="Merging-vs-Rebasing"><a href="#Merging-vs-Rebasing" class="headerlink" title="Merging vs. Rebasing"></a>Merging vs. Rebasing</h2><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">Merging vs. Rebasing</a></p>
<h2 id="Refs-and-the-Reflog"><a href="#Refs-and-the-Reflog" class="headerlink" title="Refs and the Reflog"></a>Refs and the Reflog</h2><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/refs-and-the-reflog" target="_blank" rel="noopener">Refs and the Reflogg</a></p>
<h2 id="Git-log-高级使用方法"><a href="#Git-log-高级使用方法" class="headerlink" title="Git log 高级使用方法"></a>Git log 高级使用方法</h2><p>详细参考:  <a href="https://www.atlassian.com/git/tutorials/git-log" target="_blank" rel="noopener">Advanced Git log</a></p>
<h2 id="Git-hacks"><a href="#Git-hacks" class="headerlink" title="Git hacks"></a>Git hacks</h2><h3 id="避免每次迁入迁出输入密码"><a href="#避免每次迁入迁出输入密码" class="headerlink" title="避免每次迁入迁出输入密码"></a>避免每次迁入迁出输入密码</h3><p><a href="https://blog.sleeplessbeastie.eu/2012/08/12/git-how-to-avoid-typing-your-password-repeatedly/" target="_blank" rel="noopener">Git - How to avoid typing your password repeatedly</a></p>
<h1 id="Git-Ops"><a href="#Git-Ops" class="headerlink" title="Git Ops"></a>Git Ops</h1><h2 id="如何搭建私有Git代码仓库"><a href="#如何搭建私有Git代码仓库" class="headerlink" title="如何搭建私有Git代码仓库"></a>如何搭建私有Git代码仓库</h2><p>git本身是一种去中心化的设计，可以无需中心代码仓库而工作，大家协同工作可以基于各自私有的repos进行互相track开发。但企业难免需要有一个中心代码仓库，方便统一管理、权限控制、24小时服务。</p>
<p>严格来说任意一台联网机器至少装了git客户端就可以作为中心服务器，但不支持多种协议签出代码，没有权限控制等一系列功能。</p>
<p>目前最好的方式就是直接搭建<a href="https://about.gitlab.com/features/" target="_blank" rel="noopener">Gitlab</a>（开源免费）一站式服务，包含有全面的代码管理，权限，issue，wiki等功能，与github功能十分类似。</p>
<p>不基于Gitlab可以自己通过<a href="http://gitolite.com/gitolite/index.html" target="_blank" rel="noopener">Gitolite</a>(权限控制层模块)，<a href="http://nginx.org" target="_blank" rel="noopener">nginx</a>(提供http协议)，等自己组装实现。</p>
<ul>
<li><a href="http://stackoverflow.com/questions/17167414/which-is-the-best-git-hosting-sw-gitolite-vs-gitlab-vs-gitorius" target="_blank" rel="noopener">Which is the best git hosting sw? - Gitolite vs. Gitlab vs.<br>Gitorius</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">搭建Git服务器</a></li>
<li><a href="http://zodiacg.net/2014/05/gitolite_gitweb_nginx/" target="_blank" rel="noopener">配置Gitolite+Gitweb+Nginx</a></li>
</ul>
<h1 id="Git-开发流程与规范"><a href="#Git-开发流程与规范" class="headerlink" title="Git 开发流程与规范"></a>Git 开发流程与规范</h1><p><img src="https://asset.vanjor.com/images/006tNbRwly1fylpkjyx4uj30u013rwhl.jpg" alt="A successful Git branching model"></p>
<ul>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git 分支管理策略</a></li>
</ul>
<h1 id="Git-commit-message-编写规范"><a href="#Git-commit-message-编写规范" class="headerlink" title="Git commit message 编写规范"></a>Git commit message 编写规范</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></li>
</ul>
]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo在Github上搭建技术博客</title>
    <url>/2016/05/hexo-github-blog-install/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyjdb5974cj30hs07sdgp.jpg" alt="Github托管Hexo博客"></p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>选型配置如下:</p>
<ul>
<li>博客语言: <a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown</a> 可移植跨平台</li>
<li>博客程序: <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a></li>
<li>博客主题: <a href="https://theme-next.org" target="_blank" rel="noopener">NexT</a></li>
<li>静态博客托管: <a href="https://github.com" target="_blank" rel="noopener">Github</a> + <a href="https://coding.net" target="_blank" rel="noopener">Coding.net</a> 双线托管</li>
<li>域名DNS: <a href="https://www.aliyun.cn/" target="_blank" rel="noopener">Aliyun</a> 双线解析</li>
<li>自动部署: <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci</a> 持续集成自动部署</li>
<li>写作编辑: <a href="https://code.visualstudio.com" target="_blank" rel="noopener">vscode</a> + <a href="https://prose.io" target="_blank" rel="noopener">prose</a> 离线&amp;在线写作</li>
<li>图片工具: <a href="https://itunes.apple.com/cn/app/ipic-markdown-图床-文件上传工具/id1101244278" target="_blank" rel="noopener">iPic</a> 图床管理</li>
<li>评论&amp;阅读数统计: <a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a> 基于 next 的valine 插件实现</li>
</ul>
<a id="more"></a>
<p>为什么要从自建worldpress迁移过来，原因可参考阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">文章</a>，相比之下wordpress各种不省心并复杂繁琐，而现在方案每篇文章就是一个markdown文档，满足随心DIY。</p>
<blockquote>
<p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<h1 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h1><p>Hexo搭建教简单，参考<a href="https://hexo.io/docs/setup.html" target="_blank" rel="noopener">官方教程</a> 10分钟能出hello world。</p>
<p>个人大致总结Hexo特点:</p>
<ul>
<li>极易上手，几部命令完成</li>
<li>单一配置文件_config.yml 易懂扩展性强</li>
<li>Hexo支持较好的部署功能，支持多种部署方式与多目标部署</li>
<li>模板与插件丰富，安装方便。 官方网站已经有多达百种供选择</li>
</ul>
<p>其他可见: <a href="https://www.zhihu.com/question/21981094" target="_blank" rel="noopener">开源博客横向评测</a></p>
<h1 id="国内国外双线加速"><a href="#国内国外双线加速" class="headerlink" title="国内国外双线加速"></a>国内国外双线加速</h1><p>国内访问gitlub不太稳定，通过Hexo方便的支持双线同时发布，并通过dnspod的智能路由解析功能实现，国内访问到是coding.net托管的，国外访问的是github托管的。</p>
<p>详细教程参考: <a href="https://segmentfault.com/a/1190000004548638" target="_blank" rel="noopener">hexo同时托管到coding.net与github</a></p>
<p>附我的hexo的<a href="https://github.com/vanjor/VanjorBlogWebsite/blob/source/_config.yml" target="_blank" rel="noopener">_config.yml</a></p>
<h1 id="自动部署发布文章"><a href="#自动部署发布文章" class="headerlink" title="自动部署发布文章"></a>自动部署发布文章</h1><p>Github支持Webhook可以自动触发自己主机上的发布脚本，但仍需要自己维护主机，利用travis-ci可以消除这一依赖。</p>
<p>完整教程参考: <a href="http://blog.acwong.org/2016/03/20/auto-deploy-hexo-with-travis-CI/" target="_blank" rel="noopener">用 Travis CI 自动部署 hexo</a><br>注: ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ -t id_rsa 通过-t命令指定保存为当前目录的id_rsa文件。</p>
<p>附本博客:</p>
<ul>
<li>源码系统项目: <a href="https://github.com/vanjor/VanjorBlogWebsite" target="_blank" rel="noopener">https://github.com/vanjor/VanjorBlogWebsite</a><ul>
<li>branch: source as default branch is the source code</li>
<li>branch: master retain the compiled website code serve as Github Page service</li>
</ul>
</li>
<li>travis-ci自动编译部署历史: <a href="https://travis-ci.org/vanjor/VanjorBlogWebsite" target="_blank" rel="noopener">https://travis-ci.org/vanjor/VanjorBlogWebsite</a></li>
</ul>
<h1 id="博客的详细配置变更"><a href="#博客的详细配置变更" class="headerlink" title="博客的详细配置变更"></a>博客的详细配置变更</h1><p>对 hexo 定制化过的文件</p>
<ul>
<li>source 文档及一些图片资源</li>
<li>_config.yml hexo 的配置</li>
<li>package.json hexo 依赖</li>
<li>themes/next/source/lib 扩展包安装</li>
<li>themes/next/_config.yml 主体配置</li>
<li>.travis.yml travis CI 配置</li>
<li>.travis travis 所需 ssh key token 配置</li>
<li>.gitignore git 所需</li>
<li>README.md 文档</li>
</ul>
<p>开启的的功能列表:</p>
<ul>
<li>valine + leancloud_visitors基于 leancloud 的评论与阅读数统计 [依赖三方网络服务]</li>
<li>RSS</li>
<li>local_search 搜索</li>
<li>math公式支持</li>
<li>han + pangu 文章编排美化</li>
<li>百度+谷歌统计分析  [依赖三方网络服务]</li>
<li>fancybox 图片相册支持</li>
<li>pace 加载进度条</li>
<li>post_edit 显示文章源码link</li>
<li>symbols_count_time 字数与阅读时长显示</li>
<li>icon 更新页底copyright信息</li>
<li>增加 tags, categories, archieves, about 四个子页面</li>
<li>开启social 社交网站链接</li>
<li>Hexo 特有的 Tags Settings (开启，但暂没使用需要进一步评估)</li>
<li>增加了 robots 协议</li>
<li>增加 sitemap 提交百度+谷歌+微软站长管理平台</li>
<li>强制 tags 链接全小写 filename_case=1</li>
<li>Add license and copy right by using creative_commons config</li>
<li>Enable full English URL by enable category_map</li>
</ul>
]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>情感计算-基于规则分类</title>
    <url>/2010/12/rule-based-classification/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo064xl7ij308g03ca9y.jpg" alt="sentiment analysis"></p>
<p>情感计算中，很重要的一个问题就是为目标情感数据进行分类，先行的很多文本分类技术与文本聚类技术SVM，K-means等，背后都是利用一些先决的条件，比如SVM的先决条件是建立文本向量空间VSM上。而这些文本分类技术都很少涉及到语义语法分析，或者建立十分微弱的语义语法分析基础上，比如上篇文章《<a href="/2010/12/latent-aspect-rating-analysis/">评论潜在方面观点计算</a>》。</p>
<p>本文为学习论文《<a href="http://linkinghub.elsevier.com/retrieve/pii/S1751157709000108" target="_blank" rel="noopener">Sentiment Analysis: A Combined Approach</a>》，提取其中主要的方法-基于规则分类。 着重为基于规则分类RBC与基于统计分类SBC。</p>
<a id="more"></a>
<h1 id="基于规则分类基础分析"><a href="#基于规则分类基础分析" class="headerlink" title="基于规则分类基础分析"></a>基于规则分类基础分析</h1><p>一个规则包含一个先行词（antecedent）和关联的后项（consequent），并有着“如果-那么”的关联：</p>
<blockquote>
<p>先行词 =》 后项</p>
</blockquote>
<p>一个先行词定义一个条件（condition），并且由一个标记（token）或一组由^连接的标记序列。</p>
<p>一个标记可以是一个单词，“？”表示一个专有名词，“#”表示一个目标术语。一个目标术语是一个表示文档集中出现的内容，例如一个政客的名字，一个政策主张，一个公司名称，一个产品平台或者电影标题。一个连续术语表示一个情感是术语积极或者消极的一种，并且条件最后的结果由先行词定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;token1 ^ token2 ^ . . . ^ tokenn&#125; =) &#123;+|−&#125;</span><br></pre></td></tr></table></figure>
<p>如下这两个简单的规则取决于两个情感支撑词，每个代表一个先行词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;excellent&#125; =) &#123;+&#125;  </span><br><span class="line">&#123;absurd&#125; =) &#123;−&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们有两个句子.</p>
<ol>
<li>Laptop-A is more expensive than Laptop-B.</li>
<li>Laptop-A is more expensive than Laptop-C.</li>
</ol>
<p>并且这些句子的目标词为Laptop-A ，有这些句子推导出的规则为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# ^ more ^ expensive ^ than^?&#125; =) &#123;−&#125;</span><br></pre></td></tr></table></figure>
<p>这个规则可以解释为：目标词：Laptop-A相对另两个laptops在价格方面相对更少受喜爱的，由以上规则表达，这里，聚焦在Laptop-A的价格特性上。</p>
<p>最为比对，假设目标此为Laptop-B和Laptop-C，有以上句子推导出的规则如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &#123;? ^ more ^ expensive ^ than ^ #&#125; =) &#123;+&#125;</span><br></pre></td></tr></table></figure>
<p>这个规则可以解释为：两个目标词，Laptop-B和Laptop-C相对价格方面比LaptopA更受欢迎。由以上规则表达。这里，聚焦在Laptop-B和Laptop-C的价格特性上。</p>
<p>很明显，一个目标词是一个决定情感中的先行词的一个重要因素。在这个程度上，我们可以关注在获取和定义先行词和后项集来形成一组规则集，反应一组代表文档集内容的目标词，评估4个不同的分类器，不同的都应用了一套规则。我们同样考虑否定在内，’not’, ‘neither nor’和‘no’,相对来说，我们扫描文档中的每一个句子，也就是，基于句子层级。每个先行词由句子推导出来。</p>
<h1 id="通用基于获取分类器（General-Inquirer-Based-Classifier-GIBC-）"><a href="#通用基于获取分类器（General-Inquirer-Based-Classifier-GIBC-）" class="headerlink" title="通用基于获取分类器（General Inquirer Based Classifier (GIBC)）"></a>通用基于获取分类器（General Inquirer Based Classifier (GIBC)）</h1><p>首先，简单的规则集是基于在General Inquirer Lexicon(Stone et al. 1966)中的3672个预先分类好的词，其中1598个预先归类为积极，另2074个预先归类为消极。这里，每个规则唯一取决于代表每个先行词的情感支撑词。我们应用General Inquirer Based Classifier (GIBC)到规则集，来分类文档集。</p>
<p>通用基于获取分类器其实也就是一些自动分类机的概念，大致为假定对应的文档中出现情感词的频率可以反映概括为文档总体情感。</p>
<h1 id="基于规则分类器（Rule-Based-Classifier-RBC-）"><a href="#基于规则分类器（Rule-Based-Classifier-RBC-）" class="headerlink" title="基于规则分类器（Rule-Based Classifier (RBC)）"></a>基于规则分类器（Rule-Based Classifier (RBC)）</h1><p>给定一个预先分类好的文档集，第二个规则集由将每个专有名词取代为“？”或“#”来形成一组先行词，并且为每个先行词赋予情感（规则的形成）。这样，基本的假设是为每一个先行词赋予的情感等同于为对应文档赋予情感。这样我们基于RBC实现第二种规则来对文档分类。</p>
<p>有争议的一点是，先行词表达的情感可能与文档的情感不同。因此，我们采用一个情感计算工具（Sentiment Analysis Tool (SAT)），可以以半自动方式来矫正情感。</p>
<p>如下步骤用来生成先行词集。</p>
<p>The Montylingua (Liu 2004) chunker用来解析文档集中句子，给定这些解析后的句子，一组专有名词，也就是，所有标有NNP和NNPS的术语，被自动鉴别出，并替换“？”，为了减少解析的错误率，我们自动的扫描，并测试所有由Montylingua识别出的专有名词，比对在WordNet 2.0 (Miller 1995)中的所有名词（NN，NNS），当Montylingua中的专有名词在WordNet中为标准名词，这个专有名词将被视为不正确的标注，将不会被“？”所替代。另外，所有目标词都被替代为“#”，这样，一组先行词由此生成。一个后缀数组(Manber &amp; Myers 1990)用来加速先行词匹配。</p>
<h1 id="基于统计分类器（SBC）"><a href="#基于统计分类器（SBC）" class="headerlink" title="基于统计分类器（SBC）"></a>基于统计分类器（SBC）</h1><p>基于统计分类机（SBC）使用一组规则集，基于如下假设：糟糕的表达式与词“poor”具有更高的<strong>共现率（co-occur frequency）</strong>，并且好的表达式与词语“excellent”具有更好个共现率(Turney 2002).</p>
<ol>
<li>我们计算一个由先行词组成的表达与情感支撑词集见的紧密度，如下步骤用来定义先行词的结果：</li>
<li>从General Inquirer Lexicon中挑选120个积极的词语，比如amazing, awesome, beautiful，以及120个消极词语，比如absurd, angry, anguish</li>
<li>为每一个先行词，分别与这240个词语组合一个查询，提交给搜索引擎，每个查询包含有一个先行词与情感支撑词。</li>
<li>收集所有提交给Google与Yahoo搜索引擎的查询结果中的命中数，两个搜索引擎用来分析命中数是或由搜索引擎各自的覆盖性与精确性所决定。对于每个查询，我们预期搜索引擎返回同时包含有先行词与情感支撑词的网页文档数目。这里，紧密程度计算是基于网页级别。一个更好的精确计算可能从基于句子级别获得。目前来说比较困难，我们需要从搜索引擎下载并存储每一篇网页以备分析。</li>
<li>为每个情感支撑词与先行词收集命中数</li>
<li>使用四种测量度来测量每个先行词分别于120个积极词（S+）以及消极词（S-）间的紧密度。</li>
</ol>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo07n4lp7j3072030wec.jpg" alt="sentiment analysis"></p>
<p>如果先行词共现率S+ > S- ,那么，以为这先行词为积极的，反之S+ &lt; S-则判定先行词为消极的，而S+ = S-则判定为中性，</p>
<p>紧密测量度涉及到如下概念：</p>
<h2 id="文档频率（Document-Frequency-DF-）"><a href="#文档频率（Document-Frequency-DF-）" class="headerlink" title="文档频率（Document Frequency (DF)）"></a>文档频率（Document Frequency (DF)）</h2><p>包含目标词的文档占总共文档的比率：如下：</p>
<p>一个包含N个文档的文档集集的共现矩阵</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0bovdxlj30cm03c3yf.jpg" alt="rbc"></p>
<h2 id="互信息（Mutual-Information-MI-）"><a href="#互信息（Mutual-Information-MI-）" class="headerlink" title="互信息（Mutual Information (MI)）"></a>互信息（Mutual Information (MI)）</h2><p>一个先行词与对应情感支撑词的互信息MI表示如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0c4h6lsj30cm01mjra.jpg" alt="mi"></p>
<p>更大的MI值，代表先行词与word见更高强度的关联，并且MI(antecedent,word)必须大于</p>
<p>0，意味着联合概率，P(antecedent,word)必须大于P(antecedent)与P(word)概率组合。在Conrad &amp; Utt(1994) 和Church &amp; Hanks (1989)两篇论文中均运用到MI测量术语间的关联度。</p>
<h2 id="卡方分布（Chi-square-χ2-）"><a href="#卡方分布（Chi-square-χ2-）" class="headerlink" title="卡方分布（Chi-square (χ2)）"></a>卡方分布（Chi-square (χ2)）</h2><p>给定2*2列联表，一个表包含观察到的频率，另一包含预期的频率，那么词语对应先行词的卡方值计算如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0cb9po8j304a01m742.jpg" alt="chi"></p>
<p>其中 i = {a . . . d} 表示2*2列联表中的每个方格值。<a href="http://www.nciku.cn/search/zh/detail/%E8%80%B6%E8%8C%A8%E8%BF%9E%E7%BB%AD%E6%80%A7%E6%A0%A1%E6%AD%A3/645089" target="_blank" rel="noopener">耶茨连续性校正</a>（The Yates continuity correction）被应用到每个开放计算中，并且自由度为1。更大的卡方值，意味着更有利证明来剔除虚假设，并排除之，意味着词语和先行词之间互相独立，对于卡方测试，为了可信接受或拒绝H0，预期的值应该大于5，否则，趋向于低于小概率可能性，将不正确的结果纳入H1(Cochran 1954).</p>
<h2 id="对数似然比（Log-Likelihood-Ratio）-−2-·-log"><a href="#对数似然比（Log-Likelihood-Ratio）-−2-·-log" class="headerlink" title="对数似然比（Log Likelihood Ratio）(−2 · log)"></a>对数似然比（Log Likelihood Ratio）(−2 · log)</h2><p>对数似然比计算如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0cnfay4j309u03jt8l.jpg" alt="log"></p>
<p>其中i = {a, b, c, d}并且 j = {c1, c2, r1, r2}. 对数似然比(Dunning 1993)与卡方假设类似，也就是，更大的对数似然比，意味着更有利证明来剔除虚假设。不同于卡方，对数似然比是比卡方更为精确的处理稀有事件。</p>
<p>举例说明，对于如下具体的数据：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0ctbv2ej308g02pjr9.jpg" alt="rbc"></p>
<ul>
<li>DF=40，也就是文档中同时出现先行词与词语的文档数。<img src="https://asset.vanjor.com/images/006tNbRwly1fyo0d31i1oj309h011dfn.jpg" alt="rbc"></li>
<li>为了计算卡方，预期的频率，E计算出如下: <img src="https://asset.vanjor.com/images/006tNbRwly1fyo0dbphmhj308g02rmx0.jpg" alt="rbc"> <img src="https://asset.vanjor.com/images/006tNbRwly1fyo0duzipej305k01a3ya.jpg" alt="rbc"></li>
<li>极大似然比为 <img src="https://asset.vanjor.com/images/006tNbRwly1fyo0ehviukj30bb018743.jpg" alt="rbc"></li>
</ul>
<h1 id="基于规则归纳分类器（Induction-Rule-Based-Classifier-IRBC-）"><a href="#基于规则归纳分类器（Induction-Rule-Based-Classifier-IRBC-）" class="headerlink" title="基于规则归纳分类器（Induction Rule Based Classifier (IRBC)）"></a>基于规则归纳分类器（Induction Rule Based Classifier (IRBC)）</h1><p>给定两组规则集RBC与SBC，我们应用已有的两种归纳算法ID3 (Quinlan 1986) 和由Weka (Witten &amp; Frank 2005)提供的RIPPER (Cohen 1995)的归纳算法。来生成两组归纳规则几，并建立一个分类器采用这两个归纳规则分类机来对文本集进行分类。</p>
<p>这两个归纳规则集可以表明归纳算法对于无控制的先行词集的效果，也就是这些先行词所表示的属性没有预定义，但是可以简单的从预先分类文档中归纳出。并且可以预期这种归纳规则集的效果将会拥有更好的准确率与召回率。</p>
<p>最后，论文中提出结合SVM等方法的一种组合分类方法流程图如下：<br><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0fpprsbj30ec08q3ys.jpg" alt="rbc"></p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Classifier</tag>
        <tag>Sentiment Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java界面开发工具WindowBuilder</title>
    <url>/2010/12/java-windowbuilder/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz8c4114g306s041746.gif" alt="windows-builder"></p>
<p>在项目要进行最终界面展示开发时，又得回到熟悉而久违的的SWT/JFACE，继而追寻那Eclipse的优秀的<a href="http://baike.baidu.com/view/6326.htm" target="_blank" rel="noopener">WYSIWYG</a>插件<a href="http://code.google.com/javadevtools/wbpro/index.html" target="_blank" rel="noopener">WindowBuilder</a>（没用WB之前都是手工敲代码，并界面排版），却惊喜的发现，不用再漫天搜查注册码，如今WindowBuilder的Java/Ajax工具开发商<a href="http://www.instantiations.com/" target="_blank" rel="noopener">Instantiations</a>已经于2010年8月被Google给收购了，WindowBuilder也作为免费工具开放，强大的Google！</p>
<p>并传闻Google这一收购用意不仅在GWT设计工具，更在于Ajax和Java方面，Google所有网页应用都部署了大量的Ajax，而Android应用则使用Java来创建。</p>
<a id="more"></a>
<h1 id="WindowBuilder简介"><a href="#WindowBuilder简介" class="headerlink" title="WindowBuilder简介"></a>WindowBuilder简介</h1><p>WindowBuilder是一款基于Eclipse平台的双向Java的GUI设计插件式的软件。具备SWT/JFACE开发、Swing开发及GWT 开发三大功能，是一款不可多得的Java体系中的WYSIWYG工具。</p>
<p>WindowBuilder目前最新版是8.1.0</p>
<p>WindowBuilder的主要用户界面构建为：</p>
<ul>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/design_view.html" target="_blank" rel="noopener">Design View</a></strong> - the main visual layout area.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/source_view.html" target="_blank" rel="noopener">Source View</a></strong> - write code and review the generated code</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/structure_view.html" target="_blank" rel="noopener">Structure View</a></strong> - composed of the <strong>Component Tree</strong> and the <strong>Property Pane.</strong><ul>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/component_tree.html" target="_blank" rel="noopener">Component Tree</a></strong> - shows the hierarchical relationship between all of the components.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/property_pane.html" target="_blank" rel="noopener">Property Pane</a></strong> - displays properties and events of the selected components.</li>
</ul>
</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/palette.html" target="_blank" rel="noopener">Palette</a></strong> - provides quick access to toolkit-specific components.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/toolbar.html" target="_blank" rel="noopener">Toolbar</a></strong> - provides access to commonly used commands.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/userinterface/context_menu.html" target="_blank" rel="noopener">Context Menu</a></strong> - provides access to commonly used commands</li>
</ul>
<h1 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h1><ul>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/bidirectional.html" target="_blank" rel="noopener">Bi-directional Code Generation</a> -</strong> read and write almost any format and reverse-engineer most hand-written code</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/internationalization.html" target="_blank" rel="noopener">Internationalization (i18n) / Localization</a> -</strong> externalize component strings, create and manage resource bundles.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/custom_composites.html" target="_blank" rel="noopener">Custom Composites &amp; Panels</a></strong> - create custom, reusable components.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/factories.html" target="_blank" rel="noopener">Factories</a></strong> - create custom factory classes and methods.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/visual_inheritance.html" target="_blank" rel="noopener">Visual Inheritance</a></strong> - create visual component hierarchies.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/event_handling.html" target="_blank" rel="noopener">Event Handling</a></strong> - add event handlers to your components.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/menu_editing.html" target="_blank" rel="noopener">Menu Editing</a></strong> - visually create and edit menubars, menu items and popup menus.</li>
<li><strong><a href="http://code.google.com/javadevtools/wbpro/features/morphing.html" target="_blank" rel="noopener">Morphing</a></strong> - convert one component type into another.</li>
</ul>
<h1 id="基于Eclipse-MyEclipse的安装"><a href="#基于Eclipse-MyEclipse的安装" class="headerlink" title="基于Eclipse/MyEclipse的安装"></a>基于Eclipse/MyEclipse的安装</h1><p>目前只能通过windowbuilder更新地址在线安装：  </p>
<ul>
<li><a href="http://dl.google.com/eclipse/inst/d2wbpro/latest/3.6" target="_blank" rel="noopener">Eclipse 3.6 (Helios)</a>  </li>
<li><a href="http://dl.google.com/eclipse/inst/d2wbpro/latest/3.5" target="_blank" rel="noopener">Eclipse 3.5 (Galileo)</a>  </li>
<li><a href="http://dl.google.com/eclipse/inst/d2wbpro/latest/3.4" target="_blank" rel="noopener">Eclipse 3.4 (Ganymede)</a></li>
</ul>
<p>具体详见：<a href="http://code.google.com/javadevtools/download-wbpro.html" target="_blank" rel="noopener">http://code.google.com/javadevtools/download-wbpro.html</a></p>
<h1 id="Window-builder开发介绍文档"><a href="#Window-builder开发介绍文档" class="headerlink" title="Window-builder开发介绍文档"></a>Window-builder开发介绍文档</h1><p>官方在线文档地址：<a href="http://code.google.com/javadevtools/wbpro/index.html" target="_blank" rel="noopener">http://code.google.com/javadevtools/wbpro/index.html</a></p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>使用window-builder快速开发的实验展示demo，熟练的话，差不多半个小时就可以完成。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzc4xns3j30ec08n74z.jpg" alt="window-builder demo"></p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Windows Builder</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows常用shell命令大全</title>
    <url>/2010/12/windows-shell-dos-command/</url>
    <content><![CDATA[<p>基于鼠标操作的后果就是OS界面外观发生改变，就得多花学习成本。更主要的是基于界面引导Path与命令行直达速度是难以比拟的。另外Geek很大一部分是键盘控，而非鼠标流的。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0rzdrrgj3072041749.jpg" alt="shell"></p>
<p>整理Windows的常用Shell命令，一方面帮助深入学习Mysql，另一方面准备尝试过渡到Linux家族来。</p>
<a id="more"></a>
<h1 id="Windows下Shell命令概述"><a href="#Windows下Shell命令概述" class="headerlink" title="Windows下Shell命令概述"></a>Windows下Shell命令概述</h1><p>Windows的Shell命令又是Windows的CMD命令。而cmd命令又是原来MS-DOS系统保留下来。</p>
<h2 id="Shell来源路径与配置"><a href="#Shell来源路径与配置" class="headerlink" title="Shell来源路径与配置"></a>Shell来源路径与配置</h2><p>对应的命令资源配置在windows的环境变量中：</p>
<p>Windows Shell命令是基于配置好的Path环境变量，对Shell命令在Path路径中依次从前至后搜寻到对应命名的可执行入口。</p>
<p>也就是可以自行编写一些Shell程序，C、Java、Perl等等，然后配置到环境变量中，就可以有自己的私有Shell命令了。大多数默认的Shell命令对应目标程序打多在“C:\Windows\”及“C:\Windows\System32”目录下。而基于Windows的一些应用程序（如Mysql）都会向Windows的Path中配置添加自己的目录。</p>
<h2 id="Shell命令的执行方式"><a href="#Shell命令的执行方式" class="headerlink" title="Shell命令的执行方式"></a>Shell命令的执行方式</h2><ul>
<li>一般的是通过调出CMD控制台执行</li>
<li>对于较熟悉的可以自行编写bat批处理Shell命令，然后保存为 .bat 后缀格式文件。</li>
<li>以Win7为例，可以通过Win键调出search 窗口，快捷执行，但不能全部使用</li>
<li>同时可以通过Win+R调出运行窗口来执行</li>
</ul>
<h1 id="常用Shell程序命令大全"><a href="#常用Shell程序命令大全" class="headerlink" title="常用Shell程序命令大全"></a>常用Shell程序命令大全</h1><p>下面分类列举那些调出Shell命令列表，通过使用对应命令可以大大节约时间：</p>
<h2 id="Windows常用工具类"><a href="#Windows常用工具类" class="headerlink" title="Windows常用工具类"></a>Windows常用工具类</h2><table>
<thead>
<tr>
<th>运行程序</th>
<th>运行命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>记事本</td>
<td>notepad</td>
</tr>
<tr>
<td>计算器</td>
<td>calc</td>
</tr>
<tr>
<td>画图</td>
<td>mspaint</td>
</tr>
<tr>
<td>写字板</td>
<td>write</td>
</tr>
<tr>
<td>Windows放大镜</td>
<td>magnify</td>
</tr>
<tr>
<td>辅助工具管理器</td>
<td>utilman</td>
</tr>
<tr>
<td>Telnet客户端</td>
<td>telnet</td>
</tr>
<tr>
<td>任务管理器</td>
<td>taskmgr</td>
</tr>
<tr>
<td>关闭Windows</td>
<td>shutdown</td>
</tr>
<tr>
<td>扫描仪与相机</td>
<td>sticpl.cpl</td>
</tr>
<tr>
<td>远程桌面</td>
<td>mstsc</td>
</tr>
<tr>
<td>可移动存储</td>
<td>ntmsmgr.msc</td>
</tr>
<tr>
<td>注册表编辑器</td>
<td>regedit</td>
</tr>
<tr>
<td>TrueType造字程序</td>
<td>eudcedit</td>
</tr>
<tr>
<td>打印机文件夹</td>
<td>printers</td>
</tr>
<tr>
<td>打印机和传真</td>
<td>control printers</td>
</tr>
<tr>
<td>控制面板</td>
<td>control</td>
</tr>
<tr>
<td>屏幕键盘</td>
<td>osk</td>
</tr>
<tr>
<td>网络连接</td>
<td>ncpa.cpl 或control netconnections</td>
</tr>
<tr>
<td>从Windows注销</td>
<td>logoff</td>
</tr>
<tr>
<td>字体文件夹</td>
<td>fonts 或control fonts</td>
</tr>
<tr>
<td>磁盘管理</td>
<td>diskmgmt.msc</td>
</tr>
<tr>
<td>快速查找</td>
<td>findfast.cpl</td>
</tr>
<tr>
<td>磁盘碎片整理程序</td>
<td>dfrg.msc</td>
</tr>
<tr>
<td>磁盘检查工具</td>
<td>chkdsk</td>
</tr>
<tr>
<td>磁盘清理工具</td>
<td>cleanmgr</td>
</tr>
<tr>
<td>命令行提示符</td>
<td>cmd</td>
</tr>
<tr>
<td>剪贴簿查看器</td>
<td>clipbrd</td>
</tr>
<tr>
<td>辅助功能选项</td>
<td>access.cpl</td>
</tr>
<tr>
<td>添加硬件向导</td>
<td>hdwwiz.cpl</td>
</tr>
<tr>
<td>添加或删除程序</td>
<td>appwiz.cpl</td>
</tr>
</tbody>
</table>
<h3 id="常用管理配置工具"><a href="#常用管理配置工具" class="headerlink" title="常用管理配置工具"></a>常用管理配置工具</h3><table>
<thead>
<tr>
<th>设备管理器</th>
<th>devmgmt.msc</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct X控制面板(如果已经安装)</td>
<td>directx.cpl</td>
</tr>
<tr>
<td>Direct X诊断工具</td>
<td>dxdiag</td>
</tr>
<tr>
<td>磁盘分区管理器</td>
<td>diskpart</td>
</tr>
<tr>
<td>显示属性</td>
<td>desk.cpl 或 control desktop</td>
</tr>
<tr>
<td>文件夹选项</td>
<td>control folders</td>
</tr>
<tr>
<td>显示属性的外观选项卡</td>
<td>control color</td>
</tr>
<tr>
<td>文件签名验证</td>
<td>sigverif</td>
</tr>
<tr>
<td>IP配置实用程序</td>
<td>ipconfig</td>
</tr>
<tr>
<td>键盘属性</td>
<td>control keyboard</td>
</tr>
<tr>
<td>鼠标属性</td>
<td>main.cpl 或 control mouse</td>
</tr>
<tr>
<td>Internet属性</td>
<td>inetcpl.cpl</td>
</tr>
<tr>
<td>密码属性</td>
<td>assword.cpl</td>
</tr>
<tr>
<td>电话与调制解调器选项</td>
<td>telephon.cpl</td>
</tr>
<tr>
<td>电源选项属性</td>
<td>powercfg.cpl</td>
</tr>
<tr>
<td>性能</td>
<td>perfmon</td>
</tr>
<tr>
<td>区域和语言选项</td>
<td>intl.cpl</td>
</tr>
<tr>
<td>系统属性</td>
<td>sysdm.cpl</td>
</tr>
<tr>
<td>用户帐户管理</td>
<td>nusrmgr.cpl</td>
</tr>
<tr>
<td>Windows防火墙</td>
<td>firewall.cpl</td>
</tr>
<tr>
<td>运行Windows更新</td>
<td>wupdmgr</td>
</tr>
<tr>
<td>系统配置实用程序</td>
<td>msconfig</td>
</tr>
<tr>
<td>声音和音频设备属性</td>
<td>mmsys.cpl</td>
</tr>
<tr>
<td>共享文件夹</td>
<td>fsmgmt.msc</td>
</tr>
<tr>
<td>服务</td>
<td>services.msc</td>
</tr>
<tr>
<td>Windows安全中心</td>
<td>wscui.cpl</td>
</tr>
<tr>
<td>任务计划</td>
<td>control schedtasks</td>
</tr>
<tr>
<td>游戏控制</td>
<td>joy.cpl</td>
</tr>
<tr>
<td>字符映射表</td>
<td>charmap</td>
</tr>
<tr>
<td>证书管理控制台</td>
<td>certmgr.msc</td>
</tr>
</tbody>
</table>
<h3 id="一些高级配置管理"><a href="#一些高级配置管理" class="headerlink" title="一些高级配置管理"></a>一些高级配置管理</h3><table>
<thead>
<tr>
<th>Windows管理体系结构</th>
<th>wmimgmt.msc</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows系统安全工具</td>
<td>syskey</td>
</tr>
<tr>
<td>系统配置编辑器</td>
<td>sysedit</td>
</tr>
<tr>
<td>策略的结果集</td>
<td>rsop.msc</td>
</tr>
<tr>
<td>可移动存储</td>
<td>ntmsmgr.msc</td>
</tr>
<tr>
<td>可移动存储操作请求</td>
<td>ntmsoprq.msc</td>
</tr>
<tr>
<td>ODBC数据源管理器</td>
<td>odbccp32.cpl</td>
</tr>
<tr>
<td>本地安全设置</td>
<td>secpol.msc</td>
</tr>
<tr>
<td>本地用户和组</td>
<td>lusrmgr.msc</td>
</tr>
<tr>
<td>索引服务</td>
<td>ciadv.msc</td>
</tr>
<tr>
<td>组策略编辑器</td>
<td>gpedit.msc</td>
</tr>
<tr>
<td>事件查看器</td>
<td>eventvwr.msc</td>
</tr>
<tr>
<td>Driver Verifier Manager</td>
<td>verifier</td>
</tr>
<tr>
<td>Dr. Watson系统诊断工具</td>
<td>drwtsn32</td>
</tr>
</tbody>
</table>
<h1 id="一些Shell程序命令详解"><a href="#一些Shell程序命令详解" class="headerlink" title="一些Shell程序命令详解"></a>一些Shell程序命令详解</h1><p>下面围绕第二章节以及更多高级shell操作命令进行详细描述：(陆续根据使用补充)</p>
<h2 id="网络配置Ipconfig命令"><a href="#网络配置Ipconfig命令" class="headerlink" title="网络配置Ipconfig命令"></a>网络配置Ipconfig命令</h2><p>默认Ipconfig为显示当前网络基本连接信息</p>
<ul>
<li>显示连接配置    ipconfig /all</li>
<li>显示DNS缓存内容    ipconfig /displaydns</li>
<li>去除DNS缓存内容    ipconfig /flushdns</li>
<li>释放全部(或指定)适配器的由DHCP分配的动态IP地址)    ipconfig /release</li>
<li>为全部适配器重新分配IP地址    ipconfig /renew</li>
<li>刷新DHCP并重新注册DNS   ipconfig /registerdns</li>
<li>显示DHCP Class ID   ipconfig /showclassid</li>
<li>修改DHCP Class ID    ipconfig /setclassid</li>
</ul>
<h2 id="关机操作shutdown命令"><a href="#关机操作shutdown命令" class="headerlink" title="关机操作shutdown命令"></a>关机操作shutdown命令</h2><p>Shutdown使您能够一次关闭或重新启动一台本地或远程计算机：</p>
<p>语法:：<br>shutdown [/i | /l | /s | /r | /a | /p | /h | /e] [/f] [/m //computername/] [/t XXX] [/d [p:]XX:YY/c”Comment”]</p>
<p>参数：</p>
<ul>
<li>/i : 显示“远程关机对话框”。/i 选项必须是键入的第一个参数，之后的所有参数都将被忽略。</li>
<li>/l : 立即注销当前用户，没有超时期限。不能将 /l 与 /m //computername/ 或 /t 一起使用。</li>
<li>/s : 关闭计算机。</li>
<li>/r : 关机后重新启动计算机。</li>
<li>/a : 取消关机操作（仅在超时期限内有效）。a 参数仅可以与 /m //computername/ 一起使用。</li>
<li>/p : 仅关闭本地计算机（而不是远程计算机），没有超时期或警告。/p 只能和 /d 一起使用。如果您的计算机不支持关闭电源功能，使用 /p 将关闭系统但不会切断您的计算机电源。</li>
<li>/h : 使本地计算机处于休眠状态（如果已启用休眠）。仅可将 h 与 /f 一起使用。</li>
<li>/e : 允许在目标计算机上记录意外关机原因。</li>
<li>/f : 强制关闭正在运行的应用程序而不提前警告用户。</li>
<li>/t：设置经过过长时间进行当次操作，定时功能，时间单位为秒</li>
</ul>
<p>举例：</p>
<ul>
<li>立即关机：shutdown -s -t 0</li>
<li>30秒后重启：shutdown -r -t 30</li>
<li>取消关机：shutdown -a</li>
</ul>
<h2 id="网络连接查看命令netstat"><a href="#网络连接查看命令netstat" class="headerlink" title="网络连接查看命令netstat"></a>网络连接查看命令netstat</h2><ul>
<li>netstat -a 查看开启了哪些端口,常用netstat -an</li>
<li>netstat -n 查看端口的网络连接情况，常用netstat -an</li>
<li>netstat -v 查看正在进行的工作</li>
<li>netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）</li>
<li>netstat -s 查看正在使用的所有协议使用情况</li>
</ul>
<h2 id="系统网络服务命令net"><a href="#系统网络服务命令net" class="headerlink" title="系统网络服务命令net"></a>系统网络服务命令net</h2><ul>
<li>netstat -a 查看开启了哪些端口,常用netstat -an</li>
<li>net use \\ip\ipc$ “ “ /user:” “ 建立IPC空链接</li>
<li>net use \\ip\ipc$ “密码” /user:”用户名” 建立IPC非空链接</li>
<li>net use h: \\ip\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:</li>
<li>net use h: \\ip\c$ 登陆后映射对方C：到本地为H:</li>
<li>net use \\ip\ipc$ /del 删除IPC链接</li>
<li>net use h: /del 删除映射对方到本地的为H:的映射</li>
<li>net user 用户名 密码 /add 建立用户</li>
<li>net user guest /active:yes 激活guest用户</li>
<li>net user 查看有哪些用户</li>
<li>net user 帐户名 查看帐户的属性</li>
<li>net localgroup administrators 用户名 /add 把”用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数</li>
<li>net start 查看开启了哪些服务</li>
<li>net start 服务名 开启服务；(如:net start telnet， net start schedule)</li>
<li>net stop 服务名 停止某服务</li>
<li>net time \\目标ip 查看对方时间</li>
<li>net time \\目标ip /set 设置本地计算机时间与”目标IP”主机的时间同步,加上参数/yes可取消确认信息</li>
<li>net view 查看本地局域网内开启了哪些共享</li>
<li>net view \\ip 查看对方局域网内开启了哪些共享</li>
<li>net config 显示系统网络设置</li>
<li>net logoff 断开连接的共享</li>
<li>net pause 服务名 暂停某服务</li>
<li>net send ip “文本信息” 向对方发信息</li>
<li>net ver 局域网内正在使用的网络连接类型和信息</li>
<li>net share 查看本地开启的共享</li>
<li>net share ipc$ 开启ipc$共享</li>
<li>net share ipc$ /del 删除ipc$共享</li>
<li>net share c$ /del 删除C：共享</li>
<li>net user guest 12345 用guest用户登陆后用将密码改为12345</li>
<li>net password 密码 更改系统登陆密码</li>
</ul>
<h2 id="系统服务命令sc"><a href="#系统服务命令sc" class="headerlink" title="系统服务命令sc"></a>系统服务命令sc</h2><p>SC来控制系统创建服务和管理服务。</p>
<p>SC使用这样的语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc &lt;server&gt; \[command\] \[service name\] &lt;option1&gt; &lt;option2&gt;...</span><br></pre></td></tr></table></figure>
<p>下面介绍各种参数。</p>
<ol>
<li>server ：可选，可以使用双斜线，如myserver，也可以是192.168.0.1来操作远程计算机。如果在本地计算机上操作就不用添加任何参数。</li>
<li>command：下面列出SC可以使用的命令<ul>
<li>config—-改变一个服务的配置。（长久的）</li>
<li>continue–对一个服务送出一个继续控制的要求。</li>
<li>control—-对一个服务送出一个控制。</li>
<li>create—-创建一个服务。（增加到注册表中）</li>
<li>delete—-删除一个服务。（从注册表中删除）</li>
<li>EnumDepend–列举服务的从属关系。</li>
<li>GetDisplayName–获得一个服务的显示名称。</li>
<li>GetKeyName–获得一个服务的服务键名。</li>
<li>interrogate–对一个服务送出一个询问控制要求。</li>
<li>pause—-对一个服务送出一个暂停控制要求。</li>
<li>qc—-询问一个服务的配置。</li>
<li>query—-询问一个服务的状态，也可以列举服务的状态类型。</li>
<li>start—-启动一个服务。</li>
<li>stop—-对一个服务送出一个停止的要求。</li>
</ul>
</li>
<li>service name：在注册表中为service key制定的名称。注意这个名称是不同于显示名称的（这个名称可以用net start和服务控制面板看到），而SC是使用服务键名来鉴别服务的。</li>
</ol>
<p>特别说明：<strong>SC create</strong>子命令<br>这个命令可以在注册表和服务控制管理数据库建立一个入口。使用语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> sc &lt;server&gt; create \[service name\] \[binPath= \] &lt;option1&gt; &lt;option2&gt;...</span><br></pre></td></tr></table></figure>
<p>这里的servername，servicename，optionname，optionvalues和上面的一样，这里就option描述，通常为键值对应：option name = option values 。</p>
<p>注：键值对应 name= value，等号后面应由一个空格，不能省略</p>
<p><strong>option</strong>详细描述如下：</p>
<ul>
<li>type=—-own, share, interact, kernel, filesys<br>  关于建立服务的类型，选项值包括驱动程序使用的类型，默认是share。</li>
<li>start=—-boot, sys tem, auto, demand, disabled<br>  关于启动服务的类型，选项值包括驱动程序使用的类型，默认是demand（手动）。</li>
<li>error=—-normal, severe, critical, ignore<br>  当服务在导入失败错误的严重性，默认是normal。</li>
<li>binPath=–(string)<br>  服务二进制文件的路径名，这里没有默认值，这个字符串是必须设置的。</li>
<li>group=—-(string)<br>  这个服务属于的组，这个组的列表保存在注册表中的ServiceGroupOrder下。默认是nothing。</li>
<li>tag=—-(string)<br>  如果这个字符串被设置为yes，sc可以从CreateService call中得到一个tagId。然而，SC并不显示这个标签，所以使用这个没有多少意义。默认是nothing</li>
<li>depend=—-(space separated string)有空格的字符串。<br>  在这个服务启动前必须启动的服务的名称或者是组。</li>
<li>obj=—-(string)<br>  账号运行使用的名称，也可以说是登陆身份。默认是localsys tem</li>
<li>Displayname=–(string)<br>  一个为在用户界面程序中鉴别各个服务使用的字符串。</li>
<li>password=–(string)<br>  一个密码，如果一个不同于localsys tem的账号使用时需要使用这个。</li>
<li>Optionvalues<br>  Optionname参数名称的数值列表。参考optionname。当我们输入一个字符串时，如果输入一个空的引用这意味着一个空的字符串将被导入。</li>
</ul>
<p>举例说明：在一台叫做（myserver）的计算机上为一个叫“NewService”的服务建立的一个注册表登记，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc myserver create MyService binpath= C:\\NewServ.exe</span><br></pre></td></tr></table></figure>
<p>待补充</p>
<p>参考：</p>
<ol>
<li><a href="http://tech.sina.com.cn/s/2006-04-27/0909920026.shtml" target="_blank" rel="noopener">http://tech.sina.com.cn/s/2006-04-27/0909920026.shtml</a></li>
<li><a href="http://yimok.f31.net/archives/2007/29711.shtml" target="_blank" rel="noopener">http://yimok.f31.net/archives/2007/29711.shtml</a></li>
<li><a href="http://wuhua.javaeye.com/blog/32374" target="_blank" rel="noopener">http://wuhua.javaeye.com/blog/32374</a></li>
<li><a href="http://blog.csdn.net/lryain/archive/2008/01/04/2026058.aspx" target="_blank" rel="noopener">http://blog.csdn.net/lryain/archive/2008/01/04/2026058.aspx</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>英文论文缩写</title>
    <url>/2010/12/some-abbrs-for-english/</url>
    <content><![CDATA[<p>最近看英文论文，总结一部分平时可能误用到的英文缩写，如i.e.与e.g.及etc.做一点总结，并做个小分析。</p>
<a id="more"></a>
<h1 id="i-e-与e-g-及etc-的区别"><a href="#i-e-与e-g-及etc-的区别" class="headerlink" title="i.e.与e.g.及etc.的区别"></a>i.e.与e.g.及etc.的区别</h1><p>首先简要说明各自的含义：</p>
<ul>
<li><strong>i.e.</strong>  -&gt; 约同于“<strong>that is</strong>“，对应中文”<strong>也就是</strong>“的意思</li>
<li><strong>e.g.</strong> -&gt; 约同于”<strong>for example</strong>“，对应中文”<strong>例如</strong>“的意思</li>
<li><strong>etc.</strong> -&gt; 约同于”<strong>and so on</strong>“，对用中文”<strong>等等</strong>“的意思</li>
</ul>
<p>具体来说：</p>
<ul>
<li>i.e. 是拉丁文 “ id est” 的缩写，它的意思就是“那就是说，换句话说”，等同于“that is，in other words” ，<strong>目的是用来进一步解释前面所说的观点</strong>。</li>
<li>e.g. 是拉丁文 “ exempli gratia “ 的缩写，它的意思是“举个例子，比如”，等同与“for example”,<strong>目的就是用几个例子来说明前面的观点。</strong></li>
<li>etc. 是英文 “etcetera” 的缩写，意思是“以及其他，等等”，相当于“and so on”，<strong>目的用来表示省略更多。</strong></li>
</ul>
<p>使用注意事项：</p>
<ul>
<li>e.g. 和 etc. 不能出现在同一句话中，因为 e.g. 是表示泛泛的举几个例子，并没有囊括所有的实例，其中就已经包含“等等”，如果再加一个 etc. 就画蛇添足了；</li>
<li>用它们的时候，都不要把“小点”给省略掉。</li>
</ul>
<h1 id="英文与中文对事物描述思维的差异"><a href="#英文与中文对事物描述思维的差异" class="headerlink" title="英文与中文对事物描述思维的差异"></a>英文与中文对事物描述思维的差异</h1><p>也顺便mark下在翻译论文再一次感受到一些差异，英文中对于一个事物事件描写，通常是从小到大来表述的，也就是通常首先说明目标事物，然后再对目标事物作出特征性限定描述，这个差异也直接影响了目前阅读英文的速度。</p>
<p>例如：</p>
<blockquote>
<p>Where have you put the green apples where I brought for u from the supermarket nearby the subway？</p>
</blockquote>
<p>对应中文的意思是：</p>
<blockquote>
<p>你把我昨天从地铁旁边那个超市给你买的青苹果放到哪里了？</p>
</blockquote>
<p>用红色标注语句的核心主体事物”青苹果“，而对应的特征限制”我昨天从地铁旁边那个超市给你买的“，英文中通常放置在主体的后面，而中文放置在前面。这个也可从英文中存在大量的界定词”of，which，where，by，for，from”等。</p>
<p>这一思维差异也很强烈的反应在中英文对与地址的描述的截然相反的顺序上：</p>
<p>例如：</p>
<blockquote>
<p>北京海淀区西土城路10号物联大厦10楼916号</p>
</blockquote>
<p>对应英文的地址确应该是：</p>
<blockquote>
<p>No.916，Wulian Plaza , No.10 , Xitucheng Road , Haidian District，Beijing</p>
</blockquote>
<p>中文地址由范围大到小最后锁定，英文地址范围由小到大，先锁定最终目标，然后描述它的范围特征。</p>
<p>因而，中英文在事物描述思路图差异如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0qi5uooj309u07rglr.jpg" alt="chinese english mind different"></p>
<p>其他的还有一些留心可以发现的差异：</p>
<p>例如：</p>
<blockquote>
<p>A：“You’re not feeling good，are you？” 你好像不太舒服，是么？<br>B：“Yes，I am．”                                     不，我很好。<br>     （or:“No，I am not．”）                    (或： 是的，有点）</p>
</blockquote>
<p>背后原因在：中国人对别人的问话，总是以肯定或否定对方的话来确定用“对”或者“不对”，英语中，对别人的问话，总是依据事实结果的肯定或否定用“Yes”或者“No”。</p>
<p>更多的一些有趣的差异详见：<a href="http://dongxi.net/b03dL" target="_blank" rel="noopener">英汉文化十大常见差异</a></p>
<p>参考：</p>
<ol>
<li><a href="http://blog.ednchina.com/ic_net66/43177/message.aspx" target="_blank" rel="noopener">http://blog.ednchina.com/ic_net66/43177/message.aspx</a></li>
<li><a href="http://www.meryl.net/2005/12/11/ie-etc-and-eg/" target="_blank" rel="noopener">http://www.meryl.net/2005/12/11/ie-etc-and-eg/</a></li>
<li><a href="http://dongxi.net/b03dL" title="http://dongxi.net/b03dL" target="_blank" rel="noopener">http://dongxi.net/b03dL</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>评论潜在方面观点计算</title>
    <url>/2010/12/latent-aspect-rating-analysis/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo032faiwj306s046t8u.jpg" alt="lara"></p>
<p>本文为国外09年的最新文本挖掘类别论文：</p>
<p>原文：Latent Aspect Rating Analysis on Review Text Data: A Rating Regression Approach</p>
<p>链接：<a href="http://scholar.google.com.hk/scholar?q=Latent+Aspect+Rating+Analysis+on+Review+Text+Data:+A+Rating+Regression+Approach&amp;hl=zh-CN&amp;btnG=%E6%90%9C%E7%B4%A2&amp;lr=" target="_blank" rel="noopener">原文Paper</a>，<a href="http://sifaka.cs.uiuc.edu/~wang296/paper/hongning-KDD10-v2.pptx" target="_blank" rel="noopener">展示PPT</a></p>
<p>个人三天时间完整翻译而成，本文对于理解话题识别，用户潜在观点挖掘，情感计算方面都有很好的借鉴意义。</p>
<p>目前在用户观点情感挖掘方面属于一个十分前沿的话题，广泛应用在产品研究，用户行为分析，推荐系统上。比现行的许多基于文本分类论文都是更为细致的研究，本文中大量运用统计概率学方面知识对话题识别，情感词的渐进识别，权重推断，以及结果估计验证，与应用探讨，值得深入学习。</p>
<p>个人认为一个最重要的不足的是，论文中还是主要通过挖掘文本中词语间的关联，类似tf/idf词频统计，先验概率推断等进行文本挖掘分析，而对于语义的理解，句法的解读分析仍然没有考虑在内，这样必然导致结果仍然存在很多偏差与误判，而鉴于语义理解，句法分析尚属一个十分困难的前沿研究领域。文本尤为可佳。</p>
<a id="more"></a>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在本文，定义观点评估分析（LARA： Latent Aspect Rating Analysis）问题并针对含有观点意见的文本进行分析。 旨在分析在线评论中的实体，基于话题方面（topical aspects）来挖掘每个评论者在实体的每一个方面(Aspect)的潜在观点，以及分析不同方面对于评价者形成关于实体的总体评价所占权重。我们提出一种新颖概率回归评估模型来尝试以通法来解决这类文本挖掘问题。</p>
<p>基于酒店评论数据的经验分析实验表明这种提论可以有效的解决 LARA 问题，并且基于评论的具体挖掘与分析具有广泛的应用价值，包括类别观点概括，基于方面的实体评分，分析评论者评分表现行为。</p>
<ul>
<li><strong>分类：</strong>信息搜索与检索：文本挖掘（<em>Text Mining</em>）</li>
<li><strong>主要形式：</strong>算法，实验</li>
<li><strong>关键词：</strong>意见与情感分析（<em>Opinion and sentiment analysis</em>），评论挖掘（<em>Review mining</em>），潜在评估分析（<em>Latent rating analysis</em>）</li>
</ul>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>随着 Web2.0 的发展，越来越多的人可以对各种各样的产品和服务自由的表达观点，这些评论信息对于其他用户做出决策以及产品服务的改进具有很大价值。然而，随着评论信息快速增长，海量的信息让用户难以快速查找到所需要的信息，很多工作就是来减轻这个评价文本信息抽取的问题[18,16,26],提炼总结用户的观点，根据意见的极性分类[20,6,7],并从评论中抽取相应的观点句。尽管如此，在现有的技术下，用户仍然难以方便的从海量的评论信息中挖掘与发现信息，来支撑实体主题方面的观点。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzf0co6cj30dg05kt94.jpg" alt="lara"></p>
<p>以一个典型的酒店评价信息为例，如上图（1） ，这个评论信息涉及到了酒店的多个方面特点，包括价格，房屋条件以及服务，但是评论者只给出了宾馆的总体评分，没有提供每个单独方面的评分，其他用户就难以方便的了解到这个评论者在方面上的评级（<em>latent rating</em>）。透过整体评价进一步挖掘每一方面的评价是十分重要的，因为不同的评论者对于同一家酒店会有相同的总体评价，但是因为不同的方面原因。比如：一个评论者可能喜欢酒店的位置，另一个喜欢房间条件。</p>
<p>为了帮助用户发现这些不同，十分有必要挖掘并分析评论者在酒店的几个大的方面上的评级。此外，即使我们可以挖掘发现方面上的评价信息诸如“价格”，但仍然不够充分，因为“便宜”对于不同评论者有着不同的价格标准。而且及时同一个评论者可能因为其他方面的条件因素的诉求高低不同，而对”便宜”产生的不同的标准。为了理解如此微妙的差别，十分有必要挖掘发现评价者每一方面的评价与总体评价之间的权重关系。</p>
<p>为了进行对评论的更深入具体的的理解，我们尝试来研究这种新颖的文本挖掘问题 (LARA).</p>
<blockquote>
<p><strong>LARA任务目的： 给定一个含有总体评价信息的评论数据集，LARA旨在分析每个评论在不同话题方面的评论信息，来挖掘个体用户在每一个方面上的评级，以及不同的方面的评级对于形成总体评级的权重大小。</strong></p>
</blockquote>
<p>LARA的广泛应用价值表现在：潜在方面的评级（aspect rating）可以用来进行面向方面的意见概述；每个方面的权重（aspect weight）可以方便于分析用户的评分行为；潜在方面评价与方面评分权重可以作为实体的个性化面向方面级别评估 - 通过汇集在对应方面具有相同权重的偏好的评论的评价信息。</p>
<p>现有的观点概括工作将 LARA 问题挖掘到一定程度，尚没有人在单个评论在方面层级上的潜在评价信息挖掘做过研究，也没有人考虑挖掘评论者在方面上的评级与总体评级间的权重关系。</p>
<p>在尝试解决这个新型文本挖掘时，我们提出一种基于新颖潜在评价回归模型的两阶段处理模型（<em>a novel latent rating regression model</em>）。</p>
<ol>
<li><strong>第一阶段</strong>: 我们采用 自引导算法（<em>bootstrapping-based algorithm</em>）来确定主要的方面（通过一些方面的特征词语做指引学习），并将评论集分段切割处理。</li>
<li><strong>第二阶段</strong>: 我们提出一个通用潜在评价回归模型（LRR：<em>Latent Rating Regression</em>），旨在通过分析每个评论的文本与对应评论的总体评级数据信息，来确定每个评论的方面的评级与权重。</li>
</ol>
<p>更具体的说：<strong>LRR 的基本思想 就是假定总体评价完全产生来自于每个方面的潜在评级的有权重的组合。</strong></p>
<p>而且我们假定每个方面的潜在评级取决于对应评价中的讨论涉及到这一方面的文本片段。换句话说，我们将挖掘这些方面的潜在评级演化为一组特性词语的权重组合，这些词语权重对应为情感极性(Sentimental Polarities)。而因为我们无法直接观察到每一个方面的评级数据，所以这个回归模型的输出 - 响应结果是挖掘潜在的信息。</p>
<p>我们基于从TripAdviser (<a href="http://www.tripadvisor.com" target="_blank" rel="noopener">www.tripadvisor.com</a>)爬取到的一组酒店评价数据集来评估 LRR 模型。实现结果表明 LRR 模型可以有效的从对应评价的总体评级中分析挖掘出方面上的评级，以及发现这些评论者者对于每个方面的评级相对于总体评级的权重。我们也将展示 LRR 模型中所分析到的结果说支持的不同应用，包括方面观点概括，个性化实体评级排序以及评论者的评级行为表现。</p>
<h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><p>在我们目前的调研中，还没有人做出关于LARA问题的研究，不过有些相关的工作。</p>
<p>分析评价文本的总体情感观点已经被广泛的研究。相关的研究基于文本的积极与消极的二元分类[6,7,20,5,14]。随后，这个定义被延伸到多元评级模型[10,9]。并且有提出的解决途径，包括监督，无监督，以及半监督的方法，但是他们都是尝试预测总体情感分类与评级，没有对潜在方面观点进行挖掘。</p>
<p>由于在线评论经常包含多个方面的的评价意见，一些近来工作开始挖掘基于方面层次的评级，来代替简单的总体评级。比如，Snyder et al.[23] 对于多元方面的建模，使用好的可信算法（<em>good grief algorithm</em>）可以改善对方面评级的预测。在[24]中，Titov et al. 尝试同时进行评论方面抽取与对应的评级计算：他们使用话题来描述方面，并且通过一个基于事实评级（ground-truth ratings）的回归模型。尽管如此，他们假定方面上的评级是明确包含在说提供的训练数据中。于此不同的是，我们假定方面评级是潜在的，并且是更普遍并面向现实场景的。</p>
<p>概括（<em>Summarization</em>）是一个十分广泛有用的应对信息过载的技术。一个最近的人类评估（<em>human evaluation</em>）[15] 指出情感与情绪概括具有很强的个体偏好性，相比于非情感方面，提出了情感建模以及方面观点概括的重要性。仍然，现有的基于方面的观点概括工作[10,21,18,26]只是目标停留在从评论集中聚合和展示话题上每个方面的主流观点。虽然聚合观点可以展现话题的概况信息，却导致个体评论的细节信息的丢失；此外，评论/评价者间的不同特性也没有在分析考虑范围内，这样情感的聚合是基于不同习性偏好的评论者间。Lu et al.[17]最近的一项工作是最接近于我们的，但是他们的目标仍然是从总体评级生成方面评级上的聚合概要。更为重要的是，没有已做工作考虑到评论者在不同方面上的强调程度的差异。</p>
<h1 id="三、问题定义"><a href="#三、问题定义" class="headerlink" title="三、问题定义"></a>三、问题定义</h1><p>在本章节里，我们规范定义潜在观点评级挖掘（LARA：<em>Latent Aspect Rating Analysis</em>）问题。划归为一个可计算的问题：</p>
<p><strong>LARA定义输入</strong>：一些有价值实体（如:酒店）的一组评价数据集，并且每一条评价数据都有对应的总体评级信息（这些数据在现在的web2.0中广泛存在，中国的如时光网中电影的评论，大众点评）</p>
<p><strong>公式化定义</strong>：假定  D={d1 , d2  , …，d|D|}  作为一个实体（entity）或话题（topic）的一组评论文本集，并且每个评论文本 d∈D 都关联一个总体评级 <strong>rd</strong> 。我们也假定有一个含有 n 个互异的词汇集V={w1 ,w2 , …, wn } 。</p>
<p><strong>定义：总体评级(<em>Overall Rating</em>)</strong></p>
<blockquote>
<p>一个评价文本 <strong>d</strong> 总体评级 <strong>rd</strong> 是按级别的量化数值，也就是 rd∈[rmin , rmax]，其中<strong>rmin</strong>和  <strong>rmax</strong> 是评级的最大值与最小值。</p>
</blockquote>
<p>最后我们假定我们已经知道给定 <strong>k</strong> 方面类别，并且每个方面评级都潜在影响给定话题的总体评级。例如：对于酒店的评级，可能的方面将包括“价格”和“位置”。每个方面都通过一组关键词界定关联，作为 LARA 问题的基础。</p>
<p><strong>定义：方面 (<em>Aspect</em>)</strong></p>
<blockquote>
<p>一个方面 <strong>Ai</strong> ，并包含有评论中一组能对评级产生影响的描述词（通常数目不大）。</p>
</blockquote>
<p>比如：词“price”，“value”和“worth”可以作为酒店实体的价格这个方面的特征词。我们把一个方面记做 <strong>Ai = { w|w∈V, A(w)=i}</strong> ,其中 A( . ) 是一个从词（word）到（aspect）的映射函数。</p>
<p><strong>定义：方面权重（<em>Acpect Weights</em>）</strong></p>
<blockquote>
<p>方面权重 <strong>αd</strong> 是一个 <strong>k</strong> 维向量，并且对于每一维 - 如第 <strong>i</strong> 维是一个数字量化刻度，指明对应评论文本 d 中的在方面 <strong>Ai</strong> 上的权重。</p>
</blockquote>
<p>我们定义αdi ∈[0,1] ，且∑i=1k αdi =1 使得权重更加容易理解并且在评论集中具有更好的可比性。一个高的权重意味对应方面的具有更加重要的强调与偏好。</p>
<p><strong>定义：潜在观点评级分析（<em>Latent Aspect Rating Analysis</em> (LARA))</strong></p>
<blockquote>
<p>给定一个关于话题 <strong>T</strong> 的评论集 <strong>D</strong> ，每个 评论 <strong>d</strong> 关联对应的总体评级 <strong>rd</strong> ，并且话题 <strong>T</strong> 涵盖 <strong>k</strong> 个待分析方面 {A1 , A2  , …，Ak} ，LRAR 问题目标在发现每个独立的评论文本在  <strong>k</strong>维方面的每一方面的评级 <strong>s**</strong>di<strong> ，以及对应的方面上的权重 **</strong>α<strong>di</strong></p>
</blockquote>
<p>LARA 问题也包含发现那些可能存在的未知方面，并挖掘潜在方面评级/权重的工作。在本篇论文中，我们假定，对某个实体（<em>entity</em>）类型的每一个方面都有一些关键词描述特征。这个假设对于任何实体类型都具有很好现实可操作性，它的寄语人工标注主要方面特性是可行的；另外，这种初始化模式让用户能够灵活控制他所想要分析的方面。</p>
<h1 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h1><p>LARA 问题的一个主要挑战在于，对于每个方面的评级，我们没有详细的监督学习方法，即使我们有对应方面的一组特征关键词。另一个挑战在于如何发现方面的权重。为了解决这些问题，我们提出LRR 模型，并且假定评论者对于实体的总体评级完全取决于他对于每个方面的潜在评级的权重聚合，以及每个方面的评级取决于他的评论中对应含有的一组具有权重的描述词。</p>
<p>在对这些评论数据采用这个二折回归模型后，我们便可以获取潜在方面评级与权重，以此解决LARA 问题。</p>
<p>因为 LRR 模型中界定了评论中初始词语集与方面的对应关系是已知的，我们按照给定的描述方面关键词对一个评论的基于方面进行分割，以此为每个方面提取对应的切割后的评论文本片段。这样，我们的总体方法包括两阶段，将在之后作详细介绍:</p>
<h2 id="4-1-基于方面的文本分割"><a href="#4-1-基于方面的文本分割" class="headerlink" title="4.1 基于方面的文本分割"></a>4.1 基于方面的文本分割</h2><p>第一步的目标是将评论中的句子与对应的方面建立映射关系。由于我们假定只有少部分的方面描述关键词指定出，我们设计出 自启动算法来为每个方面获取更多关联词语。</p>
<p>--------------------------------------------------------------------------------------</p>
<p>算法 : 基于方面的文本分割算法（<em>Aspect Segmentation Algorithm</em>）</p>
<p>--------------------------------------------------------------------------------------</p>
<ul>
<li><strong>输入：</strong>一个评论集合D={d1 , d2  , …，d|D|}  ，一组方面的关键词={T1 , T2  , …，Tk}，词汇表V，选定界限值 <strong>p</strong> 以及 迭代步骤上限 <strong>I</strong> .</li>
<li><strong>输出：</strong>评论集按照方面分割的句子组。</li>
<li><strong>步骤 0：</strong>把所有评论分割为句子，X={x1 , x2  , …，xM}；</li>
<li><strong>步骤 1：</strong>在每个句子 X 中匹配出方面关键词，并为每个记录匹配命中 i 计数 Count( i )；</li>
<li><strong>步骤 2：</strong>为句子与对应方面建立标记 αi =argmaxi Count( i ) 。如果得出有多个 i 值，则将对应句子关联到多个方面。【<strong>注：<a href="http://en.wikipedia.org/wiki/Arg_max" target="_blank" rel="noopener">argmax</a></strong>条件参数，αi 为使得Count( i )最大时的 i 值】</li>
<li><strong>步骤 3：</strong>对词汇表集合 V 中的每个词语计算 χ2 ；</li>
<li><strong>步骤 4：</strong>对与每个方面的词语按照计算出的 χ2 进行排序，并将前 p 个单词 加入到对应方面关键词集合 Ti 中；</li>
<li><strong>步骤 5：</strong>如果方面关键词不再变化，或迭代步数超过 I ，则转到 步骤 6 ，否则回到 步骤 1；</li>
<li><strong>步骤 6：</strong>输出带有方面标识的句子集合。</li>
</ul>
<p>--------------------------------------------------------------------------------------</p>
<p>具体来说，基于方面的文本分割算法 基本工作流程如下：给定每个方面的一组种子关键词 以及 所有评论文本作为输入，我们假定每个句子与对应方面共享一个最大量的形式重叠；基于这个初始方面标注，我们通过卡方统计（<em>Chi-Square</em> (χ2)）计算每个方面与词语的独立性，并将具有高独立性的词语加入到对应方面关键词列表中。这些步骤被重复执行知道方面关键词列表集收敛不在变化或者超出最大迭代步数。</p>
<p><strong>词语 w 与 方面 Ai 的独立性计算量 χ2 定义如下</strong>:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzk9ro9yj30dg01e0sl.jpg" alt="LARA"></p>
<p>其中:</p>
<ul>
<li>C1 为归属方面 Ai 的句子集中出现 w 次数总和</li>
<li>C2 为 <strong>不</strong> 归属方面 Ai 的句子集中 w 出现次数总和</li>
<li>C3 为归属方面 Ai 而没有包含 w 的句子集的 句子数目</li>
<li>C4 为 既 <strong>不</strong> 归属方面  Ai <strong>又</strong>没有包含 w 的句子集的 句子数目</li>
<li>C 为 w 在所有句子集中出现的总数 （C?）</li>
</ul>
<p>【思想类似于标准文本统计tf/idf】</p>
<p>在基于方面的文本分割后，我们可以得到对于每个评论 d 的 k 元分割子集，表示为 k × n 特性矩阵 Wd ，其中<strong>Wdij</strong> 是关键词 wj 在文本标记为方面Ai 上的频度（以对应方面的词语总数作为分母来标准化这个频度）。</p>
<h2 id="4-2-潜在观点评级回归模型（LRR）"><a href="#4-2-潜在观点评级回归模型（LRR）" class="headerlink" title="4.2 潜在观点评级回归模型（LRR）"></a>4.2 潜在观点评级回归模型（LRR）</h2><p>第二个环节是基于为文本按方面的分割后的延续，我们采用一种新颖的潜在观点评级回归（LRR）模型来同时分析方面评级 sd 与 方面评级权重 αd 。</p>
<h3 id="4-2-1-泛化假设（The-Generation-Assumption）"><a href="#4-2-1-泛化假设（The-Generation-Assumption）" class="headerlink" title="4.2.1 泛化假设（The Generation Assumption）"></a>4.2.1 泛化假设（The Generation Assumption）</h3><p>我们假设评价者的评级行为如下：</p>
<ul>
<li>为了形成一篇观点性的评论，评价者首先需要决定哪些方面她需要做出评论；</li>
<li>然后对于每个选定方面，评价者仔细的选择词语来表达她的观点。</li>
<li>评价者是基于她为所评论到的每一个方面所采用的情感词语进行评级。</li>
<li>最后评价者为实体进行总体评级，基于她所评论的方面按权重的加权聚合结果，这些权重反应了她在各自方面的强调重视程度。</li>
</ul>
<h3 id="4-2-2-LRR-模型"><a href="#4-2-2-LRR-模型" class="headerlink" title="4.2.2 LRR 模型"></a>4.2.2 LRR 模型</h3><p>LRR 模型是一个回归模型包含如下通用步骤：</p>
<p>对于基于方面分割后的评论文本，对于每个评论 d ，我们有一个频度矩阵 Wd 一个标准化的方面词频矩阵。 LRR 模型将 Wd 作为独立变量集（比如：评论 d 的特性），把对应总体评级 r 作为响应变量（比如：待预测变量）</p>
<p>为了进行不同方面的评级与权重建模，LRR模型进一步假定总体评级不是直接由词频特性决定，而是基于一组在潜在方面上的评级所决定，而这些潜在方面上的评级又直接的由词频特性所决定。</p>
<p>我们定义过，sd 和 αd 是一个 k 维方面对应的 权重向量  和方面评级向量。评价者对于文评价文本 d 会假定 先为每个方面 Ai 做出评级，基于线性组合 Wdi 和 βi ,比如下：公式(1)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzlehycsj304v01sdfm.jpg" alt="lara"></p>
<p>其中 βi ∈ R 暗示词语在对应方面Ai 的情感极性。</p>
<p>随后，这个评论者可以通过 sd 和 αd 的权重和来形成对实体的总体评价。</p>
<p>也就是：<img src="https://asset.vanjor.com/images/006tNbRwly1fynzlswpftj305900x3ya.jpg" alt="lara"></p>
<p>总体评级假定是一个采样服从高斯分布（<em>Gaussian distribution</em>），以αdTsd 和变量δ2 ,可以从这推断总体评级预测的不确定性。将这些汇合，我们得到如下公式(2)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzm52sfkj307j01sglf.jpg" alt="lara"></p>
<p>直观的核心思想是通过潜在观点权重 αd  与情感词权重 β ，为可观察到的总体评级与具体的文本描述建立关联，使得我们可以建立基于具体方面评级与总体评级关联模型。</p>
<p>进一步的观察评级行为，我们发现评价者在不同方面强调程度是一个复杂的行为：不同的评价者可能对不同方面就有不同的偏好程度，例如商业旅行者可能着重考虑互联网接入服务，相对正在度蜜月的夫妇可来说可能更加注重房屋环境。</p>
<p>方面之间不是独立的，尤其当方面之间有重叠，例如一个强调清洁（cleanliness aspect）的也可能表示偏向于间（room apect）</p>
<p>为了考虑评价者偏好的差异性，我们考虑每个评价文本 d 的方面权重 αd 作为从整个语料库的先验分布中产生一组随机变量。</p>
<p>接下来，为了计算不同方面的独立性，我们采用多变量的高斯分布（<em>Multivariate<br>Gaussian Distribution</em>）作为先验方面权重, 也就是如下公式(3)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzmknfu7j3043014we9.jpg" alt="lara"></p>
<p>其中 μ 与 ∑ 是平均值与方差参数。</p>
<p>结合公式(2)(3)，我们的得到贝叶斯回归问题，在给定评论中应用LRR模型后，总体评级的可能性为：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzmpdh4qj30dg02ka9z.jpg" alt="lara"></p>
<p>其中 rd 与 Wd 为评论文本 d 中可观察到的数据，θ =(μ，∑，σ2，β) 是一组基于语料库级别的模型参数。αd 是评论文本 d 潜在方面权重。注意到我们假定 σ2 与 β 不依赖于单个的评论者，同时它们也是语料库级别的模型参数。LRR 的一种图形化模型见下图(3)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzn7wm49j30b805qmx4.jpg" alt="lara"></p>
<p>图3：LRR图形化表示，外盒代表评论集，内盒代表单个评论文本的潜在观点评级和词语描述的组成。</p>
<p>假定我们已经有给定 LRR 模型参数 θ =(μ，∑，σ2，β) ，可以应用这个模型计算出每个评论文本的潜在观点评级与权重，步骤如下：</p>
<p>(1) 在给定评论文本 d 中的潜在观点评级sd 可以按照 公式(1) 进行计算；</p>
<p>(2) 我们采用最大后验证概率 (MAP：<em>Maximum a posteriori</em>）来计算评论文本中最可能的值 αd 。</p>
<p>评论文本d 的目标估计MAP函数定义为：公式(5)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynznjpnmej30bw01s745.jpg" alt="lara"></p>
<p>我们希望扩展这个公式，并为每个评论文本（记作_L_( ad )）关联这个所有方面的特征词 (terms) 到 αd 中,如下公式（6）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynznsxhn3j30dg028wed.jpg" alt="lara"></p>
<p>其中做出代换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">∑i=1k αdi = 1;  0&lt;=αdi &lt;=1 , i=1,2,....,k</span><br></pre></td></tr></table></figure>
<p>为了以下约束非线性优优化问题，我们应用conjugate-gradient-interior-point 方法，采用如下公式，对 αd 求倒数。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzo3235zj30cl01q3yd.jpg" alt="lara"></p>
<h4 id="4-2-3-讨论"><a href="#4-2-3-讨论" class="headerlink" title="4.2.3 讨论"></a>4.2.3 讨论</h4><p>LRR 既不是一个纯粹的监督模型也不是一个纯粹的无监督模型，但是它包含了一些已经已知的监督与无监督模型。</p>
<p>一方面，对于它的目标函数，LRR与监督回归模型类似，都是用来适应可观察到的总体评级（见 公式（2））。尽管如此，不同于一个通常的监督模型，LRR 没有为一个评论的总体评级建立学习预测模型；反而，在LRR 中，我们更加感兴趣于从可观察到的总体评级中推断分析出潜在方面评级与权重（虽然 LRR 可以用来预测总体评级）。从另外一方面来说，通过公式（1），包含另外一个回归模型(一方面评级作为响应变量)，而方面评级又不是可以直接观测到的，这样，唯一的监督在于我们有总体评级这个已有指标，并且我们假定他是这些方面评级的权重总和。这是我们 LRR 模型与传统监督回归模型的最大区别。</p>
<p>另外一方面，LRR模型也具有类似于无监督方法的特点，在于我们不需要训练集包含有方面评级数据，并且我们可以推断出这些潜在方面评级。具体来说，要分析一组评论集的潜在方面评级，我们首先需要为数据集找到最优模型参数集 θ =(μ，∑，σ2，β) ，然后运用这些参数预测潜在观点评级 αd , 另外，当加入新数据，我们需要对应更新这些参数集。然而，LRR 也不是一个传统的无监督方法，因为我们有从总体评级中的间接监督。</p>
<p>将我们的LRR模型与标准的话题模型做比较同样十分有趣，例如LDA[2]，在LDA模型中，我们对于那些能够刻画话题的潜在词语分布感兴趣，在 LRR 中，我们尝试发现能够的能刻画语言模型的关联方面评级的词语权重。这两个模型的一个有意义的区别在于 LDA 是完全无监督的，而 LRR 是半监督：虽然我们没有对每个方面的评级做出直接监督，而总体评级对于方面评级做出限制使得我们可以间接监督。</p>
<h3 id="4-3-LRR-模型估计"><a href="#4-3-LRR-模型估计" class="headerlink" title="4.3 LRR 模型估计"></a>4.3 LRR 模型估计</h3><p>在之前的章节里，我们讨论了如何通过 θ =(μ，∑，σ2，β) 应用LRR模型来为每个评论推断计算方面权重 αd 。在本章节中，我们讨论怎样去运用最大似然（ML :<em>Maximum<br>Likelihood</em>）估计量估计这些模型参数，也就是，如何找到最优的 θ’ =(μ，∑，σ2，β)来最大化所有观测总体评级的可能性。</p>
<p>在整个评论集中的对数似然（log-likelihood）函数是如下公式(7)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzohwcp2j30ax01s745.jpg" alt="lara"></p>
<p>这样，ML估计参量：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzop0ebyj30d101s3ye.jpg" alt="lara"></p>
<p>为了计算ML估计参量，我们首先随机初始化所有参数值来获取一个初始θ(0) ,然后用如下EM-style算法来迭代的更新于改进这些参量，通过在每轮迭代中二选一的执行 E-Step 和M-Step：</p>
<ul>
<li><strong>E-Step</strong>：对于语料库中每个评论文本 d ，基于现阶段的参量θ(t)（下标t指迭代轮次）通过运用公式（1）（6）计算方面评级 sd 和方面权重αd 。</li>
<li><strong>M-Step</strong>：运用基于现阶段的参量 θ(t) 推断的方面评级 sd 和方面权重 αd 来更新模型参量，通过最大化“complete likelihood”来获取 θ(t+1) ，也就是为所有评论文本推断出所有如下变量，包括 总体评级 rd 、推测出的方面评级 sd 与方面权重 αd 。</li>
</ul>
<p>首先，我们看方面权重 αd 的高斯先验分布（Gaussian prior distribution）参数更新。目的是在 M-Step 中最大化计算出的所有计算值 αd 的可能性 ：对于所有的评论，我们又如下基于高斯分布的ML估计更新公式。如下公式（8）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzp01riqj30cr036mx1.jpg" alt="lara"></p>
<p>∑ (t+1) 记为:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzp8hl34j30cr01na9w.jpg" alt="lara"></p>
<p>也就有公式（9）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzpjgfpvj30cr01na9w.jpg" alt="lara"></p>
<p>然后，我们在看怎么来更新 σ2 和 β 。又这步已经假定 αd 是可知的，我们可以更新σ2 和 β 来 最大化 P( rd | ad ，σ2，β，Wd )（参见公式（2））。</p>
<p>我们通过如下更新公式来解决这个求最优问题：公式（10）（11）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzpvb0avj30do03cwee.jpg" alt="lara"></p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzq3fbgij30do01xt8l.jpg" alt="lara"></p>
<p>这个对于 β 的逼近解决方法对 一个 |V| ×|V| 据矩阵进行转置，要直接计算的话代价开销很大。为了避免这个问题，我们采用基于梯度算法（gradient-based method）来寻找 β 的最优解，梯度偏导算子如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzqf8yw3j30ad01swec.jpg" alt="lara"></p>
<p>这样，E-Step 与M-Step交替进行，直到方程（7）的似然值收敛。</p>
<h1 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h1><p>在本章节中，我们首先描述我们在评估 LRR 模型中所使用的评论数据集，然后讨论实验结果。</p>
<h2 id="5-1-数据集与预处理"><a href="#5-1-数据集与预处理" class="headerlink" title="5.1 数据集与预处理"></a>5.1 数据集与预处理</h2><p>我们从<a href="http://www.tripadvisor.com" target="_blank" rel="noopener">TripAdvisor</a>站点爬取到一个月内的（从2009年2月14到2009年3月15号）235793条酒店评论数据。选择这套数据集目的在于，它们不仅包含有总体评级，而且还包含有评论者各自的针对 7 个方面的细节评级，它们是value，room，location，cleanliness, checkin/front desk, service, business service，这些方面评级范围从 1 星到 5 星，我们可以利用这些作为 LARA的可靠的定量评估。这些数据集从以下网址获得：<a href="http://times.cs.uiuc.edu/~wang296/Data." target="_blank" rel="noopener">http://times.cs.uiuc.edu/~wang296/Data.</a></p>
<p>首先，我们对这些评论数据进行简单的预处理：</p>
<p>（1）统一大写转换为小写；</p>
<p>（2）移除标点符号，停用词（在文献[1]中所提供）；</p>
<p>（3）运用Porter Stemmer[22]还原每个单词词形【by vanjor：英文单词的词性、词形变化，去掉前缀、后缀等】</p>
<p>既然我们已经有 7 个预定义方面的评级数据，我们也把这 7 个方面应用到我们的预测实验中。因此，我们人工为每个预定义的方面选定一组种子关键词，并把他们作为 4.1 章节中所描述的算法的输入，我们设定选择门槛值 p = 5 、迭代步数上限 I = 10 。我们所用到的这个初始化方面词集，如下表，表（1）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzrdodfkj30dg0520t1.jpg" alt="lara"></p>
<p>在基于方面分割评论集后，我们丢弃掉那些不与任何方面关联的句子。如果我们需要每条评论中都包含这 7 个方面的描述信息，那么数据集中只有 关于184个酒店 的 780个评论符合。为了避免评论中的数据过于贫乏，以及方面描述信息丢失，我们将关于每个对应的酒店的所有评论汇集起来合并成一个新的“评论”（称之为“h-review”），并按 总体评级/方面评级 的平均值作为可信评级。经过这些处理后，我们得到一个1850酒店的语料库，以及108891条评论，具体见下表：表（2）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzrjaqdoj30ao03i3yk.jpg" alt="lara"></p>
<h2 id="5-2-定性评估-Qualitative-evaluation"><a href="#5-2-定性评估-Qualitative-evaluation" class="headerlink" title="5.2 定性评估 (Qualitative evaluation)"></a>5.2 定性评估 (Qualitative evaluation)</h2><p>首先，我们展示 LRR 模型关于定性评估生成的 3 个样列数据。</p>
<h2 id="方面层次酒店分析-Aspect-level-Hotel-Analysis"><a href="#方面层次酒店分析-Aspect-level-Hotel-Analysis" class="headerlink" title="方面层次酒店分析(Aspect-level Hotel Analysis)"></a>方面层次酒店分析(Aspect-level Hotel Analysis)</h2><p>通过检查总体评级来判断给定酒店的质量是一个简单的方法。而这样粗糙的分析可能会丢失不同方面的质量的细节评估：没能指出具有相同方面评级的酒店的差异。为了检验 LRR 模型的这种甄别能力，我们随机选择 就有相同总体评级不同方面评级的的 3 个酒店，并运用 LRR 模型来预测他们的潜在方面评级。预测结果见表 3 ，其中预测值在括弧内(由于空间有限，我们只展示前四个方面数据结果)，见下表（3）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzsstueaj30dg04e3yo.jpg" alt="LARA"></p>
<p>可以从中发现，3 个酒店具有相同的总体评级，不同的方面细节区别：Grand Mirage 与 Resort and Gold Coast Hotel 都有更高的 price 评级，而 Eurostars Grand Marina Hotel 拥有更高的 location 与 room 评级。这个信息对于那些有着不同方面需求的的人具有很好价值。</p>
<h3 id="评论者层次酒店分析-Reviewer-level-Hotel-Analysis"><a href="#评论者层次酒店分析-Reviewer-level-Hotel-Analysis" class="headerlink" title="评论者层次酒店分析(Reviewer-level Hotel Analysis)"></a>评论者层次酒店分析(Reviewer-level Hotel Analysis)</h3><p>即使对于同一个酒店，不同的评论者对于同一个方面会有不同的观点意见。 LRR模型可以更进一步的通过独立评论者层次的预测方面评级来支持这种细节的分析。为了证实这一点，我们选取总数据集中的一个子集 - 那些同时具有7个方面描述评论（覆盖184个酒店的780个评论），在表4 中，两个评论者同时对 Hotel Riu Palace Punta Cana 给出 4 星的总体评级，但是他们对于具体的方面评级不同：评论者1 对于酒店的 cleanliness  评级高于其他方面，而 评论者2 认为其 value 与  location 应该是最好的两个方面。为了证实这种不同，提供如下证据（方面评级）会让用户更好的基于拥有评论进行决策。表（4）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzt1t5ahj30dg03k3yn.jpg" alt="lara"></p>
<h3 id="语料特定词语情感倾向-Corpus-Specifc-Word-Sentimental-Orientation"><a href="#语料特定词语情感倾向-Corpus-Specifc-Word-Sentimental-Orientation" class="headerlink" title="语料特定词语情感倾向(Corpus Specifc Word Sentimental Orientation)"></a>语料特定词语情感倾向(Corpus Specifc Word Sentimental Orientation)</h3><p>为了对真个评论文本进行预测潜在观点评级，LRR 同样可以风分析词语的情感倾向。与传统的无监督情感分类算法不同，它们依赖预先定义的词典，LRR 可以直接从给定数据中挖掘这些情感化的信息。在 表5 中展示一些 LRR 有趣的结果，我们按每个方面 展示前5个具有积极权重的单词与前5个具有消极权重的单词。将它们与观点标注词典SentiWordNet [8]进行比较（由于空间有限，我们只展示前四个方面数据结果）。如下表，表（5）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynztzp2h4j30dg05saah.jpg" alt="lara"></p>
<p>我们可以发现一些有趣的结果，单词“ok”在 SentiWordNet 定义为积极的，但在我们的语料库中，评论者使用这个单词表示 仅仅可以接受的；单词 “linen”,“walk”以及”beach” 在SentiWordNet中并没有标注具有观点，而他们也是名词，而 LRR 系统赋予它们积极的情感倾向，可能因为”lean”可能暗示”cleanliness”的状况是好的，”walk”与”beach”可能暗示酒店的位置是很便捷的。</p>
<p>这样，LRR可以为我们提供指定领域的词语倾向信息，这对于指定领域中的已有的情感字典的丰富扩大是很有帮助的。</p>
<h2 id="5-3-定量分析（Quantitative-Evaluation）"><a href="#5-3-定量分析（Quantitative-Evaluation）" class="headerlink" title="5.3 定量分析（Quantitative Evaluation）"></a>5.3 定量分析（Quantitative Evaluation）</h2><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>在我们所调研范围内，尚没有人做过解决类似问题的尝试，最接近我们的工作[17]，其中，作者提出两种方法，那就是Local prediction与Global prediction。因此，我们也把这两个方法作为我们基本算法予以比较。也采用其他的一些算法，比如，把评论的总体评级作为方面评级来训练监督模型。我们通过支持向量回归（SVR：<em>Support Vector Regression</em> ）模型[3]，并命名为 SVR-O 。另外，作为一个上限，我们同样也测试了一个完全监督算法 SVR-A，那就是喂有已知方面评级的训练数据的SVR模型做比较，以此找出什么样的 LRR 模型能够不需要监督而达到这一效果。我们使用libsvm包[4]中带有默认参数时间的RBF核心算法，进行SVR-O与SVR-A处理。所有的模型包括 LRR 以及这两个方法[17]都基于同一组数据集。我们采用四折交叉验证（<em><a href="/2010/10/cross-validation/">4-fold cross validation</a></em>），并给出处理性能的平均值。</p>
<h3 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h3><p>我们使用四个不同的测度来定量评估这些不同的方法，包括</p>
<ol>
<li>方面评级预测的均方误差（mean square error） <strong>△aspect 2</strong> ；</li>
<li>评论中的方面相关系数（ρaspect）;</li>
<li>评论间的方面相关系数（ρreview）;</li>
<li>平均准确率（MAP：<em>Mean Average Precision</em>）[11]，一个经常用来衡量信息检索中平局准确性的指标。</li>
</ol>
<p>正式的，假定s di<em> 是真实的方面评级Ai 。<strong>△aspect 2</strong> 直接测量预测方面评级sdi 与真实方面评级s di</em> 的差异，定义如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzv53yutj30ak01xmwz.jpg" alt="LARA">)</p>
<p>ρaspect 目的在于测量方面评级预测的性能，用于保存对应评论的按照真实评级的相关方面排序。例如，在一个评论中，评论者可能偏好 location大于cleanliness，ρaspect 会评估这个预测的评级与对应真实的偏好排序是否一致，ρaspect 定义如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzvbop3wj306701yjr6.jpg" alt="LARA"></p>
<p>其中 ρsd,sd 是两个向量 sd 与 sd 的皮尔森相关系数（Pearson correlation）。</p>
<p>类似的 ρreview 定义了如下皮尔森相关系数：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzvm2h7vj306j01wmwy.jpg" alt="LARA"></p>
<p>其中 si 与 si* 两向量为整个评论集中的关于方面 Ai 的预测值与真实值。它可以指出在整个评论集中，有关方面Ai 的方面预测值与真实值是否是一致的，这种排序可以回答如下问题：”那个酒店拥有最好的service？”</p>
<p>尽管如此，ρreview 对于所有的条目平等权重，并且不反应排名前几个的特性，直观来说从用户的视角来看更为重要。因此，我们也采用MAP来评估模型关于评论的的排序准确信。更准确的说，我们对真实评论站前十的评论子集作为一个相关评论集，以此来看如果我们通过预测方面评级，是否也能把这10个评论预测前十。我们对所有酒店按照7个方面排序，并计算 MAP 前10个评论作为临界值。</p>
<p>结果分析：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzwom1gqj30cw042weo.jpg" alt="LARA"></p>
<p>如上表，表（6）展示了所有5个算法在四个度量上的测量结果。因为SVR-A是完全监督算法，而其它均不是，我们把它单独列在最下一行。同时出SVR-A外的四个模型，粗体着重标注在四个度量上各自最高性能值。</p>
<p>总体观察来看在 LRR 的性能在<strong>△aspect 2</strong> 与 ρreview 这两个度量比其他的非 SVR-A 模型性能要好的多，但是它也不是在这两个方面表现性能最好的。较高的 ρreview 表明LRR可以更好的区分一个评论中的不同方面的评价。注意到这个在不同方面上的相对偏好信息不能仅从总体评级中获取。另外，高的 MAP@10 表明 LRR 相比其他方法也能更好的检测到 在各个方面排名前十的酒店，这些对于用户的直接排名也十分有用，因为高排名的结果将可能会最影响用户满意度。</p>
<p>注意到 <strong>△aspect 2</strong> 是独立的衡量每个预测方面评级与真实方面评级，也就无法反应方面关联排序性能如何。比如，有一个只有三个方面的实体，一个评论的整体评级为 4 而事实的方面评级为（3,4,5）。那么一个生涩的预测（4,4,4）没能辨别出方面的不同，将会有<strong>△aspect 2</strong> =0.67，而另外一个预测（2,3,4），能够辨别出方面上的不同，却有相对更高（效果更差）<strong>△aspect 2</strong> =1。却是，可以观察到Local prediction模型达到最好的<strong>△aspect 2</strong> =0.588，但是是在以最低的 ρaspect 指标性能为代价，而事实上 ρaspect 具有更重要的用途。</p>
<p>通过对基于方面评级预测的准确度排名深入研究，我们可以看到两个测度 <strong>△aspect 2</strong> 与 ρreview 产生不同结论。这个是在预期的，因为ρreview 测度这 1850 个 h-reviews 的相关性，而<a href="mailto:MAP@10" target="_blank" rel="noopener">MAP@10</a>只关心前十的，Local prediction 没有在 ρreview 指标上得分最高，却在<a href="mailto:MAP@10" target="_blank" rel="noopener">MAP@10</a>指标上表现糟糕。这说明了它比LRR的更出色与低排名而不是高排名的那些，而这些又是用户最为关心的。</p>
<p>注意到给 SVR 喂养总体评级并没有达到预期的性能，这也在一定程度上证实了我们的假设：总体评级与方面评级是有区别的。因此，光只看总体评级是不够充分的。最终，并不奇怪的是，LRR 没有基于事实方面评级数据训练模型 SVR-A 那样高的表现性能。尽管如此 LRR 不需要训练集包含有任何方面评级的标记，比 SVR-A 具有更显示的应用前景。</p>
<h3 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h3><p>在实际的应用中高效的挖掘算法是十分重要的。LRR 的主要计算工作在于解决非线性优化器问题，见公式（6）（11）。LRR的训练步骤中的收敛度取决于模型参量 Θ ,评论集 |D| 的数量 以及 迭代步骤上限 I，这个算法复杂度初步估计为O(k(n + k + 1)|D| I )，与评论集数目线性相关，对于我们的数据集，这个算法在奔腾4系列2.8CPU/2GB 内存的台式电脑上用时不到3分钟完成。</p>
<h2 id="5-4-应用"><a href="#5-4-应用" class="headerlink" title="5.4 应用"></a>5.4 应用</h2><p>运用 LRR 模型进行 具体的观点理解与获取对于许多应用都具有潜在的价值，我们列举如下三个样列应用.</p>
<h3 id="基于方面的概括"><a href="#基于方面的概括" class="headerlink" title="基于方面的概括"></a>基于方面的概括</h3><p>因为LRR可以为评论 sd 推断方面评级，我们就可以更为容易的对于酒店的各个方面上 聚合评论集的方面评级（例如：（1/|D| )∑d∈D sd）。这样酒店的方面评级可以被看做为基于方面观点的概括。基于这些，我们也可以对指定酒店通过公式（1）计算选择那些句子，这些在每个方面具有最高的和最低的评分，帮助用户更加理解每个方面的观点。</p>
<p>我们在 表7 中展示了一个基于方面的概括。我们可以看到评价者当考虑到酒店在西雅图这么好的位置时对于价格的容忍值就很高。尽管如此，还是有很多地方可以改进，不好的供暖系统，以及互联网接入需收费。这些细节信息将会对用户从海量评价信息中挖掘基本观点十分有用。如下表（7）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzza221uj30dg04i74p.jpg" alt="LARA"></p>
<h3 id="用户评价行为表现分析"><a href="#用户评价行为表现分析" class="headerlink" title="用户评价行为表现分析"></a>用户评价行为表现分析</h3><p>通过为每个独立的评论推断潜在方面权重ad，我们可以知道对应的评论者在不同方面的强调程度，可以视作为用户评级行为表现的理解。一个潜在的应用是挖掘用户在作出最终评价时，那些因素对于用户的判断具有最大影响。为了深入研究，我们选择了两组不同价格区间的酒店数据：一组的价格超过$800（称之为昂贵的酒店），另一组为价格低于$100（称之为廉价的酒店），对于每一组，我们选取平均整体评级排名前十与末十的酒店，最终形成四个酒店子集。我们展示这四个酒店子集的平均方面权重ad，结果见表（8）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzzgsjwwj30cw05g74k.jpg" alt="LARA"></p>
<p>我们发现一个有趣的现象是，评价者们为昂贵的酒店给出高评价主要是因为他们良好的service与locations，而对应给出低评价这是因为糟糕的房屋环境与过高价格。</p>
<p>作为对比，评价者为廉价的酒店给出高评价主要是因为好的price/value 以及良好的location，而相对给出低评是因为糟糕的cleanliness.</p>
<p>另外，这些量化的评级可能包含不同评价间的平均反应：低收入客户为便宜的酒店给出“value”方面的 5 星评价，而一些其他追求更好服务的客户可能给予昂贵的酒店在“value”方面的 5 星评价。仅仅为每个方面预测评级仍然不够以挖掘到用户间的微妙差异，但是这种方面权重的推断更好的便于我们理解为什么低收入客户相比“service”更倾向于“value”。为了深入了解这些，我们从四个城市：Amsterdam、Barcelona、Florence 以及 San Francisco中（这些地方的酒店在我们的语料库中大有所在），挑选出在“value”方面评级都具有5星评价的酒店，我们按照他们的方面权重比率 value/location、value/room、value/service 进行排序，相对应的，对于每个比率，计算出平均前十和末十的酒店。数据展现在表（9）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynzzpcmp9j30dg05s0t0.jpg" alt="LARA"></p>
<p>我们发现那些相对具有“value”上更高权重的酒店具有更低的价格，同时对“location”、“room”与“service”这些方面具有较高权重的酒店倾向于就有更高的价格，表明了即时这些酒店在“value”方面具有同样方面评价，偏好于“value”方面的客户可能更倾向于价格低廉的酒店，而那些对偏好于“location”或“service”（除了”price”）方面的则可能会接受更高的价格。这样推断出的方面权重αd 对于挖掘用户评级行为十分有用。</p>
<h3 id="个性化排序"><a href="#个性化排序" class="headerlink" title="个性化排序"></a>个性化排序</h3><p>对酒店按照各个方面推断出的评级对于用户十分有用。我们展示为每个独立的评论学习不同方面的评级权重，使得我们可以为一个当前用户挑选具有相同评价行为偏好的评论进行个性化排序。具体来说，给定一个用户的偏好权重作为查询条件，我们可以通过选择那些具有类似偏好权重的评论者，并且只基于这些评论者们的评论集做出酒店排名。</p>
<p>为了有效的展示 LRR 模型支持这种个性化牌型，考虑一个样例查询：Query= { value weight：0.9, others：0.016 }，暗示用户最看重偏好“value”，并不太关心其他方面。我们运用两用不同排名方法：</p>
<ul>
<li><strong>方法 1</strong>: 不考虑输入查询，通过按预测方面评级对酒店进行排序。</li>
<li><strong>方法 2</strong>: 挑选出与所给定查询具有最接近的方面权重（也就是 αd）的评论者前10%，并仅只根据他们的评论做出酒店排名。</li>
</ul>
<p>通过两种方法，我们基于查询中定义的方面权重对酒店进行排序，得到的前 5 的结果如下表：表（10）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo02siw85j30dg06jaai.jpg" alt="lara"></p>
<p>十分有趣的现象是尽管方法 1 中前5的结果都具有5星评价（并且大致也可推测道他们在“value”方面上也具有很高评级，因为排名主要是基于查询中的权重的），它们的价格倾向比方法2 中得到的前五酒店要高；的确，方法 1 中的前 5 酒店平均价格是$412.6 而方法2 中前5 酒店平均价格仅为$289.4，相对要低很多。（整个数据集中所有酒店的平均价格为$334.3）。直觉可以看到对于样列查询，方法 2 对于用户更有帮助。这也就意味着像方法2 这样，只从挑选类似偏好权重行为的用户的评论集进行排序，个性化排序对“value”方面偏好权重更大，确保排名前几的酒店真的具有相对较低的价格。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文中，我们定义了一种新颖文本挖掘算法问题-潜在方面观点评级分析（LARA：Latent Aspect Rating Analysis）来分析在线评论在话题方面级别的观点。LARA 通过分析一套带有整体评级的评论文本 以及 一组指定的方面作为输入，来挖掘每个独立的评论者在给定的这些方面的潜在评级，以及不同方面的相对权重大小。为了解决这个问题，我们提出一个新颖的潜在评级回归模型（LRR）。</p>
<p>我们对于一组酒店评论数据集的以经验为主的实验表明 LRR 模型能有效的解决 LARA 问题，挖掘那些方面评级的差异背后的有趣行为，即使总体评级相同。这个结果页表明基于话题方面的层级上的观点分析可以支持多种应用，包括方面观点概括，基于方面评级的实体排序 以及 用户评级行为分析。</p>
<p>我们的工作开启了一个文本挖掘的新颖方向，聚焦在分析带有观点性文本的潜在评级分析。再为来它将会有更多有趣的研究方向值得挖掘。列于，虽然我们是基于评论定义了LARA问题，LARA 也很明显可以应用于任何带有观点性的文本（比如网络日志），并带有总体评级以达到具体的理解文本观点。她可能在其他应用场景中就有有趣研究价值。另外,我们的LRR模型并没有严格的显示为词语特性，其他的类型特性也可以很容易的应用到此模型中。同样，在我们的LARA定义中，我们假定方面描述为一组关键词形式。这有利于用户灵活的把握控制他所想要研究的方面。</p>
<p>LARA问题 在未来关于潜在方面挖掘与方面评级及方面权重将是十分有趣的研究话题方向。</p>
<h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>感谢匿名评论者的十分有价值的评论。本文基于IBM Faculty Award -an Alfred P. Sloan Research Fellow-ship, and by the National Science Foundation under grants IIS-0347933, IIS-0713581, IIS-0713571, and CNS-0834709所支持下的工作。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>[1] Onix text retrieval toolkit stopword list. <a href="http://www.lextek.com/manuals/onix/stopwords1.html" target="_blank" rel="noopener">http://www.lextek.com/manuals/onix/stopwords1.html</a>.</li>
<li>[2] D. Blei, A. Ng, and M. Jordan. Latent dirichlet allocation. The Journal of Machine Learning Research, 3:993 - 1022, 2003.</li>
<li>[3] C. Burges. A tutorial on support vector machines for pattern recognition. Data mining and knowledge discovery, 2(2):121 - 167, 1998.</li>
<li>[4] C.C. Chang and C.J. Lin. LIBSVM: a library for support vector machines, 2001. Software available at <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a>.</li>
<li>[5] H. Cui, V. Mittal, and M. Datar. Comparative experiments on sentiment classifcation for online product reviews. In Twenty-First National Conference on Artificial Intelligence, volume 21, page 1265, 2006.</li>
<li>[6] K. Dave, S. Lawrence, and D. M. Pennock. Mining the peanut gallery: opinion xtraction and semantic classifcation of product reviews. In WWW ‘03, pages 519{528, 2003.</li>
<li>[7] A. Devitt and K. Ahmad. Sentiment polarity identifcation in fanancial news: A cohesion-based approach. In Proceedings of ACL’07, pages 984 - 991, 2007.</li>
<li>[8] A. Esuli and F. Sebastiani. SentiWordNet: A publicly available lexical resource for opinion mining. In Proceedings of LREC, volume 6, 2006.</li>
<li>[9] A. Goldberg and X. Zhu. Seeing stars when there aren , a¶rt many stars: Graph-based semi-supervised learning for sentiment categorization. In HLT-NAACL 2006 Workshop<br>  on Textgraphs: Graph-based Algorithms for Natural Language Processing, 2006.</li>
<li>[10] M. Hu and B. Liu. Mining and summarizing customer reviews. In W. Kim, R. Kohavi, J. Gehrke, and W. DuMouchel, editors, KDD, pages 168 - 177. ACM, 2004.</li>
<li>[11] K. Jarvelin and J. Kekalainen. IR evaluation methods for retrieving highly relevant documents. In Proceedings of SIGIR’00, pages 41 - 48. ACM, 2000.</li>
<li>[12] N. Jindal and B. Liu. Identifying comparative sentences in text documents. In Proceedings of SIGIR ‘06, pages 244 - 251, New York, NY, USA, 2006. ACM.</li>
<li>[13] H. Kim and C. Zhai. Generating Comparative Summaries of Contradictory Opinions in Text. In Proceedings of CIKM’09, pages 385 - 394, 2009.</li>
<li>[14] S. Kim and E. Hovy. Determining the sentiment of opinions. In Proceedings of COLING, volume 4, pages 1367 - 1373, 2004.</li>
<li>[15] K. Lerman, S. Blair-Goldensohn, and R. T. McDonald. Sentiment summarization: Evaluating and learning user preferences. In EACL, pages 514 - 522, 2009.</li>
<li>[16] B. Liu, M. Hu, and J. Cheng. Opinion observer: Analyzing and comparing opinions on the web. In WWW ‘05, pages 342 - 351, 2005.</li>
<li>[17] Y. Lu, C. Zhai, and N. Sundaresan. Rated aspect summarization of short comments. In Proceedings of WWW’09, pages 131 - 140, 2009.</li>
<li>[18] S. Morinaga, K. Yamanishi, K. Tateishi, and T. Fukushima. Mining product reputations on the web. In KDD ‘02, pages 341{349, 2002.</li>
<li>[19] B. Pang and L. Lee. Seeing stars: Exploiting class relationships for sentiment categorization with respect to rating scales. In Proceedings of the ACL, pages 115 - 124, 2005.</li>
<li>[20] B. Pang, L. Lee, and S. Vaithyanathan. Thumbs up? Sentiment classi¯cation using machine learning techniques. In EMNLP 2002, pages 79 - 86, 2002.</li>
<li>[21] A.-M. Popescu and O. Etzioni. Extracting product features and opinions from reviews. In Proceedings of HLT ‘05, pages 339 - 346, Morristown, NJ, USA, 2005. Association for Computational Linguistics.</li>
<li>[22] M. Porter. An algorithm for su±x stripping. Program, 14(3):130 - 137, 1980.</li>
<li>[23] B. Snyder and R. Barzilay. Multiple aspect ranking using the good grief algorithm. In Proceedings of NAACL HLT, pages 300 - 307, 2007.</li>
<li>[24] I. Titov and R. McDonald. A joint model of text and aspect ratings for sentiment summarization. In ACL ‘08, pages 308 - 316.</li>
<li>[25] Y. Yang and J. O.Pedersen. A comparative study on feature selection in text categorization. In Proceedings of ICML’97, pages 412 - 420, 1997.</li>
<li>[26] L. Zhuang, F. Jing, and X. Zhu. Movie review mining and summarization. In Proceedings of CIKM 2006, page 50. ACM, 2006.</li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>NLU</tag>
      </tags>
  </entry>
  <entry>
    <title>文本情感分析概述</title>
    <url>/2010/12/sentiment-analysis-brief/</url>
    <content><![CDATA[<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0h8l8vij307203dt8q.jpg" alt="nlu"></p>
<p>文本情感分析(Sentiment Analysis)： 又称意见挖掘,简单而言,是对带有情感色彩的主观性文本进行分析、处理、归纳和推理的过程.最初的情感分析源自前人对带有情感色彩的词语的分析。(右图参考论文[2])</p>
<p>应用背景与意义： 互联网(如博客和论坛以及社会服务网络如大众点评)上产生了大量的用户参与的、对于诸如人物、事件、产品等有价值的评论信息.这些评论信息表达了人们的各种情感色彩和情感倾向性,如喜、怒、哀、乐和批评、赞扬等. 基于此,潜在的用户就可以通过浏览这些主观色彩的评论来了解大众舆论对于某一事件或产品的看法。</p>
<p>本文主要介绍情感分析所要涉及的两个基础概念方面，情感分类主客观识别，情感信息提取，主客体的识别，与情感信息的计算。</p>
<a id="more"></a>
<h1 id="情感分析概述"><a href="#情感分析概述" class="headerlink" title="情感分析概述"></a>情感分析概述</h1><p>层次分类：</p>
<ul>
<li>按照处理<strong>文本的粒度</strong>不同,情感分析可分为词语级、短语级、句子级、篇章级以及多篇章级等几个研究层次</li>
<li>按照处理<strong>文本的类别</strong>不同,可分为基于新闻评论的情感分析和基于产品评论的情感分析等</li>
</ul>
<p>以下主要从情感分析的几个需要考虑的问题做阐述：<strong>情感信息的抽取</strong>、<strong>情感信息的分类</strong></p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0iar441j30cu06hjrw.jpg" alt="sentiment"></p>
<h1 id="情感信息的抽取"><a href="#情感信息的抽取" class="headerlink" title="情感信息的抽取"></a>情感信息的抽取</h1><p>情感分析的最底层的任务,它旨在抽取情感评论文本中有意义的信息单元.</p>
<p>其目的在于将无结构化的情感文本转化为计算机容易识别和处理的结构化文本,继而供情感分析上层的研究和应用服务。</p>
<p>有价值的情感信息单元主要有评价词语(如优秀、好用)、评价对象 (如GPS,屏幕分辨率)、观点持有者 (如国家政府、台湾当局)</p>
<p>总体三部分:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0imrjmcj30cs0233yf.jpg" alt="情感分析主客体结构"></p>
<h2 id="评价词语的抽取和判别"><a href="#评价词语的抽取和判别" class="headerlink" title="评价词语的抽取和判别"></a>评价词语的抽取和判别</h2><p>即为评价词语的识别和极性及度量判断，评价词语的抽取和判别往往是一个一体化的工作:</p>
<p>主要分为基于语料库和基于词典两种方法</p>
<h3 id="基于语料库的评价词语抽取和判别"><a href="#基于语料库的评价词语抽取和判别" class="headerlink" title="基于语料库的评价词语抽取和判别"></a>基于语料库的评价词语抽取和判别</h3><p>主要是利用大语料库的统计特性,观察一些现象来挖掘语料库中的评价词语并判断极性.</p>
<p>优缺点： 基于语料库的方法最大的优点在于简单易行,缺点则在于可利用的评论语料库有限,同时评价词语在大语料库中的分布等现象并不容易归纳</p>
<h3 id="基于词典的评价词语抽取及判别方法"><a href="#基于词典的评价词语抽取及判别方法" class="headerlink" title="基于词典的评价词语抽取及判别方法"></a>基于词典的评价词语抽取及判别方法</h3><p>主要是使用词典中的词语之间的词义联系来挖掘评价词</p>
<p>优缺点：难度较大，词典的更新程度决定词义分析</p>
<h2 id="评价对象的抽取"><a href="#评价对象的抽取" class="headerlink" title="评价对象的抽取"></a>评价对象的抽取</h2><p>评价对象是指某段评论中所讨论的主题, 具体表现为评论文本中评价词语所修饰的对象</p>
<p>可参考一下两种</p>
<h3 id="基于规则-模板的方法抽取评价对象"><a href="#基于规则-模板的方法抽取评价对象" class="headerlink" title="基于规则/模板的方法抽取评价对象"></a>基于规则/模板的方法抽取评价对象</h3><p>规则的制定通常要基于一系列的语言分析与预处理过程,如词性标注、命名实体识别、句法分析等.相应地,制定的规则也包括词序列规则、词性规则以及句法规则等形式</p>
<p>优缺点：在于针对性强,可以直接针对待解决的问题或特定的语言现象制定规则/模板;而其缺点则在于规则/模板的可扩展性差,人工编写的工作量大,成本较高.</p>
<h3 id="基于对象归属"><a href="#基于对象归属" class="headerlink" title="基于对象归属"></a>基于对象归属</h3><p>一个角度诠释了评价对象的抽取.他们将评价对象看作产品属性的一种表现形式(如对数码相机领域而言,“相机的大小”是数码相机的一个属性,而“相机滑盖”是数码相机的一个组成部分),继而考察候选评价对象与领域指示词(如“整体-部分”关系指示词“scanner has”)之间的关联度来获取真正的评价对象.</p>
<p>优缺点：实验效果超过了基于规则/模板的方法,但难点在于领域指示词的获取.</p>
<p>评价对象在产品服务专栏评论，如大众点评评论中，一般可以以默认当前产品作为用户的评价对象。</p>
<h3 id="观点持有的抽取"><a href="#观点持有的抽取" class="headerlink" title="观点持有的抽取"></a>观点持有的抽取</h3><p>观点持有者的抽取目的在于辨别情感文本的意见主体是谁，比如在美国大选中，需要甄别，那一部分群体支持，那一部分群体赞成，</p>
<ul>
<li>借助于命名实体识别技术来获取观点持有，类似于词典分析法者<ul>
<li>优缺点：较为依赖自然语言处理的基础技术,有较低的语言覆盖现象和较差的领域适应性.</li>
</ul>
</li>
<li>将所有名词短语都视为候选观点持有者<ul>
<li>使用ME(maximum entropy)模型来进行计算.</li>
</ul>
</li>
<li>将观点和观点持有者的识别作为一个任务同时解决<ul>
<li>在抽取出情感句中的观点单元(多是由一些短语组成)之后,分析句中观点和动词的句法关系,即可同步获取观点持有者.</li>
</ul>
</li>
</ul>
<p>产品评论中一般默认观点持有者是用户本身,因此很少有研究者在产品评论领域研究这一任务。</p>
<h3 id="组合观点持有的抽取"><a href="#组合观点持有的抽取" class="headerlink" title="组合观点持有的抽取"></a>组合观点持有的抽取</h3><p>组合观点主要考虑到现实情形中，用户的评价存在领域方向的针对性，以及存在多个评价客体的比较等更复杂也普遍存在的场景考虑。</p>
<p>评价词语在情感分析中的作用是不言而喻的.然而在某些情况下,单独的评价词语存在一定的歧义性,如评价词语“高”在以下3 个句子中的使用:</p>
<ul>
<li>Sen 1:凯越的油耗真高.</li>
<li>Sen 2:捷达的性价比相当高.</li>
<li>Sen 3:这辆车有1米多高.</li>
</ul>
<p>Sen 1 和Sen 2 是情感句,但是评价词语“高”在修饰不同的评价对象时表现出不同的极性.如,“高”在Sen 1 中表示贬义,而在Sen 2 中则表示褒义.</p>
<p>此外,评价词语往往也会出现在非情感句中,如Sen 3.</p>
<p>因此,仅考虑单独的评价词语在情感分析中的应用是远远不够的.研究者们发现,有些包含评价词语的“组合评价单元”(如组合“油耗-高”、“性价比-高”)对于处理情感分析的上层任务更有帮助. 另一考虑途径是对产品的子类别划分，按照油耗节能，总体性价比，等分别进行用户情感评估。</p>
<p>可以由以下两方面考虑</p>
<p><strong>主观表达式的抽取</strong>:</p>
<p>从不同的语料中扩充了大量的主观表达式,主要包括手工收集的一部分主观表达式以及自动从标注/未标注语料中学习而来的一部分主观表达式</p>
<p><strong>评价短语的抽取</strong>:</p>
<p>评价短语表现为一组连续出现的词组,但不同于主观表达式,该词组往往是由程度副词和评价词语组合而 成,如“very good”等.因此,这种组合评价单元不仅顾及了主观表达式的情感极性,还考察了其修饰成分.这些修饰成分或加强或减弱或置反了主观表达式的情感极性,使得评价短语成为一种情感色彩丰富的组合评价单元。</p>
<h1 id="情感分类"><a href="#情感分类" class="headerlink" title="情感分类"></a>情感分类</h1><p>情感分类首要的是对文本的主客观性进行甄别，在新闻，个人博客，以及电影评论中都会涉及到一些客观是事物描述，比如电影评论中涉及到对电影中的剧透，这些客观的描述潜在会包含情感词，而不能作为用户的情感计算。</p>
<p>主、客观信息的分类可以参考如下两种方式：</p>
<ol>
<li>通过考察文本内部是否含有情感知识(具体表现为情感信息抽取的结果)来完成主客观信息分类</li>
<li>将情感文本单元的主客观分类定义为一种二元分类任务,即对任意给定的情感文本单元,由分类器协助判断其主客观性.这种方法的关键在于分类器和分类特征的选取.</li>
</ol>
<h2 id="主观信息最简化分类"><a href="#主观信息最简化分类" class="headerlink" title="主观信息最简化分类"></a>主观信息最简化分类</h2><p>一般而言,情感最简化建模为将主观本文的极性分为褒义和贬义两类(thumbs up? thumbs down?).</p>
<p>两种方法基于情感知识的方法以及基于特征分类的方法</p>
<ol>
<li>基于情感知识：主要是依靠一些已有的情感词典或领域词典以及主观文本中带有情感极性的组合评价单元进行计算</li>
<li>基于特征分类：主要是使用机器学习的方法,选取大量有意义的特征来完成分类任务.将情感文本单元的主客观分类定义为一种二元分类任务,即对任意给定的情感文本单元,由分类器协助判断其主客观性.这种方法的关键在于分类器和分类特征的选取.</li>
</ol>
<p>注: 全本主要针对文献[1]按个人观点整理补充而成，仅供学习参考</p>
<p>参考文献：</p>
<ol>
<li>赵研研等，《<a href="http://scholar.google.com.hk/scholar?q=文本情感分析" target="_blank" rel="noopener">文本情感分析</a>》，Journal of Software，2010</li>
<li>Hongning Wang, Y.L.C.Z. , <a href="http://scholar.google.com.hk/scholar?hl=zh-CN&amp;q=Latent+Aspect+Rating+Analysis+on+Review+Text+Data" target="_blank" rel="noopener">Latent Aspect Rating Analysis on Review Text Data</a>. 2009.</li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Classifier</tag>
        <tag>NLU</tag>
        <tag>Sentiment Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>十一探乂</title>
    <url>/2010/11/november-peace-unrest/</url>
    <content><![CDATA[<p>不经意的抬手看看时间，恰好手表那分针挡住了日期，多么希望看到时间为我所停驻，却已不由感觉只下徒劳，这是十一月的最后一天啊。</p>
<a id="more"></a>
<p>月首寄语已悄然变换为月末的那尚未及回味完的丝丝的留恋，为一件事前前后后忙碌了一月，已孵化成型，颇有些欣慰，莞尔也暂多了一份担忧。从没想过曾经看似久远的时代，如今那么贴近，平滑的过渡，转身。</p>
<p>就如同时光的消逝，动荡中求得安逸，却从来没有忘记过忧患的存在，就如同总是感觉到它静悄悄的沉寂在你身边的一个角度，待得你足够遗忘它时，悄然现身之时，即是被其吞噬时。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynu48jkgbj30ec090glz.jpg" alt="november-for-peace"></p>
<p>看过<a href="http://www.youku.com/show_page/id_zac398d46a47011df97c0.html" target="_blank" rel="noopener">11度青春系列电影</a>之《<a href="http://v.youku.com/v_show/id_XMjE4MDU1MDE2.html" target="_blank" rel="noopener">老男孩</a>》的视频，在命运变幻的河流里，青春如同奔流的江河，一去不回来不及道别。生活像一把无情刻刀，改变了我们模样，未曾绽放就要枯萎吗 ，我有过梦想，青春如同奔流的江河，一去不回来不及道别，只剩下麻木的我没有了当年的热血，看那漫天飘零的花朵，在最美丽的时刻凋谢，有谁会记得这世界她曾经来过。深刻感受到时间的那把无情刻刀，也感觉一种未来得及把握时度未作为的深深的遗憾与危机感。</p>
<p>同样也看过《<a href="http://movie.mtime.com/108953/" target="_blank" rel="noopener">社交网络</a>》，感受到电影中的主角原型马克·扎克伯格的那种人生理想与创业历程同时，也得到内在的一种启迪与深思，在想法与实施间也只是一念之间，在坚持与妥协间也只差一步。无论何种形式的发展，都需要自身的超强领域能力为基础，外加优良的综合品质付诸于行动。</p>
<p>越来越清晰所要做的事，也越来明晓时光易逝，在一件一件琐碎之事轮流压栈出栈时，或许早已忘记当初下的断点再也回不到起初的路，或许已经疲惫不堪，再也无力继续航行，或许，所要做之事已如堵塞的交通，走走停停，没有个明了的前方。因而也感觉到很多事情应该顺着好的状态追击下去，而不能纵然耽搁。</p>
<p>在程式的编织之路上也遇到一些困惑，或许是先进的一个瓶颈，也是一个急需汲取新知识的时期，经常权衡不定是自己是否有些重造车轮，还是该寻找前人的框架作为基础，但是也没有完全能够符合自身的需求的框架，消化并修改复用前人框架与自己重新制造总是有些权衡的痛苦。同时基于程序复用，代码究竟该抽象到什么一个程度上，仍然是不断的探索，也是与自身能力，事务的分析，抽离合理性挂钩，作坊的试验品与发布的构件之间其实是一个巨大的鸿沟。</p>
<p>在这一个月，其实是几个月内感触的另一点是，没有经过完全消化掉的东西从来不归属与自己，就如同没有经过消化过的食物一样，那些每天所认识，学习到的杂碎的知识都急需要整理归纳，否则一大堆的夹生的知识都只会局促在一起腐败。有时看似方便快捷，为了省时，任由离散的资料，知识散布在脑海，PC中的每一个快捷文件夹中，最终这些膨胀不可掌控的东西由如鸡肋，拾之困难，弃之可惜。除去每天需要更加清晰的划分任务外，不至于过于盲目乐观，总是未完了。也需要留下一段时间，不是去学习新的东西，而是去整理当天的那些夹生的知识。同时，也进一步规范行为，辅之以工具，如Notepress等，增强对周边的知识的可达性与掌控能力。</p>
<p>也正与一次在论坛中讨论引发感悟，对于自身未亲自实验证实或想法阶段的，也未尝不可形式化提出来，从脑子里到书面的整理加工也是进一步的学习与思考，也是一个Tag作为待做事项的存根，而避免了为暴露的问题会遗留成更大的潜在障碍与灾难。</p>
<p>所以后会尝试更加活跃的写文章，同时会减少一些细节的注意力，如格式(其实已于中旬为Windows-Live-Writer结合Wordpress定制一个学科总结文模板，大大减少以后写作书面排版的工作)，拼写（不会写完一篇文章要来回几遍只为审查拼写与语法通顺）。会更加注重条理的整理，问题，观点，原因，解决方案式的条理陈述。方面会涉及到一些领域概念学习，个人想法，技术hacks，problem solve&amp;bug fix与软件使用心得等，篇幅会更加长短不定。</p>
<p>如同已到月末都不知如何凝练这个月的情感，却在百度的手写输入法中随手得到此字-乂(yì)，其一义是安稳的意思，而十一这个月不真是动荡中雕琢探求一片乂居么。</p>
<p>十一探乂的思语，探乂之时，勿忘居安思危，众多尚需改进与执行</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机SVM</title>
    <url>/2010/11/support-vector-machine/</url>
    <content><![CDATA[<p>支持向量机 Support Vector Machine, 简称<strong>SVM</strong>（或SV机），是一种监督是学习的方法，广泛应用于统计分类及回归分析中。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxkke2xtj306s04hjrg.jpg" alt="SVM"></p>
<p>其中, <strong>机</strong>（machine,机器）实际上是一个算法。在<a href="http://zh.wikipedia.org/zh/机器学习" target="_blank" rel="noopener">机器学习</a>(ML)领域里，常把一些算法看做是一个机器。</p>
<a id="more"></a>
<h1 id="SVM定义"><a href="#SVM定义" class="headerlink" title="SVM定义"></a>SVM定义</h1><p>参考WIKI定义：</p>
<blockquote>
<p><strong>支持向量机</strong> 将向量映射到一个更高维的空间裡，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。</p>
</blockquote>
<h1 id="SVM目的"><a href="#SVM目的" class="headerlink" title="SVM目的"></a>SVM目的</h1><p>分类是机器学习的一个常用手法，假设给定数据点（这些点不一定是R2 纬度集合中，可以是任意Rn 纬度中的店），每个都归属于某一个或几个类别，我们希望能够把这些点通过一个n-1维的<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">超平面</a>分开，通常这个被称为<a href="http://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8" target="_blank" rel="noopener">线性分类器</a>。</p>
<p>有很多分类器都符合这个要求，但是我们还希望找到分类最佳的平面，即使得属于两个不同类的数据点间隔最大的那个面，该面亦称为<strong>最大间隔超平面</strong>。如果我们能够找到这个面，那么这个分类器，就称为最大间隔分类器。<strong>支持向量机目的也就是一种最大间隔分类器。</strong></p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxll809ej307i05kmx0.jpg" alt="Svm_separating_hyperplanes"></p>
<p>（有很多个分类器(超平面)可以把数据分开，但是只有一个能够达到最大分割。H3不能准确分割，H1能分割但不能做到最大分割，H2则是最大分割）</p>
<h1 id="SVM推理引入"><a href="#SVM推理引入" class="headerlink" title="SVM推理引入"></a>SVM推理引入</h1><p>我们考虑以下形式的样本点<strong>D</strong>（n个数量的如下形式点集）：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxnrltecj309u0163ya.jpg" alt="svm"></p>
<p>其中:</p>
<ul>
<li><strong>_ci_</strong> 为1或−1 ,用以表示数据点属于哪个类.</li>
<li><strong>xi</strong> 是一个 <strong>_p_ 维向量</strong> ，其每个元素都被缩放到 [0, 1] 或 [-1, 1]. 缩放的目的是防止方差大的随机变量主导分类过程。</li>
</ul>
<p>我们可以把这些数据称为“训练数据”，希望我们的支持向量机能够通过一个超平面正确的把他们分开。超平面的数学形式可以写作:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxoerb4gj303s012gld.jpg" alt="svm"></p>
<p>根据几何知识，我们知道<strong>w</strong>向量垂直于分类超平面。<strong>w</strong>与<strong>x</strong>为<strong>内积</strong>，加入位移<strong>b</strong>的目的是增加间隔。如果没有<strong>b</strong>的话，那超平面将不得不通过原点，限制了这个方法的灵活性</p>
<p><strong>由于我们要求最大间隔</strong>，因此我们需要知道支持向量以及（与最佳超平面）平行的并且离支持向量最近的超平面。我们可以看到这些平行超平面可以由方程族：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxp8wykcj303n00zdfl.jpg" alt="svm"> and <img src="https://asset.vanjor.com/images/006tNbRwly1fynxpfvqh9j304600zdfl.jpg" alt="svm"></p>
<p>如果这些训练数据是线性可分的，那就可以找到这样两个超平面，在它们之间没有任何样本点并且这两个超平面之间的距离也最大。通过几何不难得到这两个超平面之间的距离是2/|<em><strong>w</strong></em>|，因此我们需要最小化 |<em><strong>w</strong></em>|。同时为了使得样本数据点都在超平面的间隔区以外，我们需要保证对于所有的<em><strong>i</strong></em> 满足其中的一个条件：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxq27ufqj303j00h741.jpg" alt="svm">对于第一类 <strong>xi</strong></p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxqoac9pj303x00h741.jpg" alt="svm"> 对于第二类 <strong>xi</strong></p>
<p>通过类别二元量 <strong>Ci</strong> 可以合并为：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxr5ih9wj309k00pwe9.jpg" alt="svm"></p>
<p>现在寻找最佳超平面这个问题就变成了在上式这个约束条件下最小化|<em><strong>w</strong></em>|. 这是一个<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92" target="_blank" rel="noopener">二次规划</a>(QP：Quadratic Programming)最优化中的问题。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxrj1i0uj308w08mt8n.jpg" alt="Svm_max_sep_hyperplane_with_margin(最大间隔超平面，两类分割数据集)"></p>
<p>更清楚的表示</p>
<p>求最小化<img src="https://asset.vanjor.com/images/006tNbRwly1fynxs8u77yj3013010741.jpg" alt="svm">，并且满足限定条件<img src="https://asset.vanjor.com/images/006tNbRwly1fynxsi4kdbj309g00lq2p.jpg" alt="svm"><br><em>(1/2这个因子是为了数学上表达的方便加上的)</em></p>
<p><strong>解如上问题通常的想法可能是使用非负</strong><a href="http://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0" target="_blank" rel="noopener"><strong>拉格朗日乘数</strong></a> <strong>α_i_ 于下式</strong></p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxt27qdaj30a3023gle.jpg" alt="svm"></p>
<p>不过这样可能出错. 原因是：假如我们能找到一族超平面将这些点分割开来；那么所有的 <img src="https://asset.vanjor.com/images/006tNbRwly1fynxzw4kqgj305000lgld.jpg" alt="svm">. 因此我们可能通过将所有α_i_趋向正无穷大得到最小值, 此最小值对这一族内所有成员都有效，而不是解决原问题的最优解。</p>
<p><strong>但是可以将约束问题表示为：</strong>（注：这一部分没弄得十分明白..）</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny2cdc72j30ai01jmwz.jpg" alt="svm"></p>
<p><strong>从而化解问题为寻找一个鞍点（saddle point）</strong>.</p>
<p>这样所有可以被<img src="https://asset.vanjor.com/images/006tNbRwly1fyny3a4sq3j304z00ldfl.jpg" alt="svm">分离的点就无关紧要了，因为我们必须设置相应的 αi 为零。</p>
<p><strong>这个问题现在可以用标准二次规划技术标准和程序解决</strong>。结论可以表示为如下<strong>训练向量的线性组合</strong></p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny0q17c3j303f01jjr5.jpg" alt="svm"></p>
<p>只有很少的 <strong>αi</strong> 会大于0. 相应的 <strong>xi</strong> 就是<strong>支持向量</strong>, 这些支持向量在边缘上并且满足 <img src="https://asset.vanjor.com/images/006tNbRwly1fyny5134vfj304z00ldfl.jpg" alt="svm">. 由此可以推导出支持向量也满足: <img src="https://asset.vanjor.com/images/006tNbRwly1fyny5so8bpj30a000l3ya.jpg" alt="svm">因此允许定义偏移量_b_. 实际上此支持向量比一般<em>N__S__V</em>的支持向量鲁棒性更强:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny77l52ej305w01na9u.jpg" alt="svm"></p>
<h2 id="SVM改进模型-软间隔（Soft-margin）"><a href="#SVM改进模型-软间隔（Soft-margin）" class="headerlink" title="SVM改进模型-软间隔（Soft margin）"></a>SVM改进模型-软间隔（Soft margin）</h2><p>1995年, <a href="http://zh.wikipedia.org/w/index.php?title=Corinna_Cortes&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Corinna Cortes</a>与Vapnik提出了一种改进的最大间隔区方法，这种方法可以处理标记错误的样本。如果可区分正负例的超平面不存在，则“软边界”将选择一个超平面尽可能清晰地区分样本，同时使其与分界最清晰的样本的距离最大化。这一成果使术语“支持向量机”（或“SVM”）得到推广。这种方法引入了松驰参数 <strong>ξ</strong><em><strong>i</strong></em> 以衡量对数据 <strong>x</strong> <strong>_i_</strong> 的误分类度。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyny815832j308k00pt8h.jpg" alt="svm"></p>
<h1 id="SVM特性"><a href="#SVM特性" class="headerlink" title="SVM特性"></a>SVM特性</h1><p>SVM的特点可以总结为：</p>
<ol>
<li>SVM学习问题可以表示为凸优化问题，因此可以利用已知的有效算法发现目标函数的全局最小值。而其他分类方法（如基于规则的分类器和人工神经网络）都采用一种基于贪心学习的策略来搜索假设空间，这种方法一般只能获得局部最优解。</li>
<li>SVM通过最大化决策边界的边缘来控制模型的能力。尽管如此，用户必须提供其他参数，如使用核函数类型和引入松弛变量等。</li>
<li>通过对数据中每个分类属性引入一个哑变量，SVM可以应用与分类数据。</li>
<li>SVM不仅可以用在二类问题，还可以很好的处理多类问题，比如通过引入决策树模型。</li>
</ol>
<h1 id="SVM实现"><a href="#SVM实现" class="headerlink" title="SVM实现"></a>SVM实现</h1><h2 id="SVM实现难点与核心"><a href="#SVM实现难点与核心" class="headerlink" title="SVM实现难点与核心"></a>SVM实现难点与核心</h2><p>SVM的关键在于核函数。低维空间向量集通常难于划分，解决的方法是将它们映射到高维空间。但这个办法带来的困难就是计算复杂度的增加，而核函数正好巧妙地解决了这个问题。</p>
<p>也就是说，只要选用适当的核函数，就可以得到高维空间的分类函数。在SVM理论中，采用不同的核函数将导致不同的SVM算法。</p>
<h2 id="SVM开源实现工具LIBSVM"><a href="#SVM开源实现工具LIBSVM" class="headerlink" title="SVM开源实现工具LIBSVM"></a>SVM开源实现工具LIBSVM</h2><p><strong>LIBSVM</strong>工具主页：<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" title="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/libsvm/</a></p>
<p>是由台湾大学林智仁(Lin Chih-Jen)副教授等开发设计的一个简单、易于使用和快速有效的SVM模式识别与回归的软件包.</p>
<p>项目不但提供了编译好的可在Windows系列系统的执行文件，还提供了源代码，方便改进、修改以及在其它操作系统上应用；该软件对SVM所涉及的参数调节相对比较少，提供了很多的默认参数，利用这些默认参数可以解决很多问题；并提供了交互检验(Cross Validation)的功能。该软件可以解决C-SVM、ν-SVM、ε-SVR和ν-SVR等问题，包括基于一对一算法的多类模式识别问题</p>
<p>LIBSVM拥有Java、Matlab、C#、Ruby、Python、R、Perl、Common LISP、Labview等数十种语言版本。最常使用的是Matlab、Java和命令行的版本。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li>WIKI-SVM: <a href="http://en.wikipedia.org/wiki/Support_vector_machine" title="http://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Support_vector_machine</a></li>
<li>WIKI-支持向量机：<a href="http://zh.wikipedia.org/zh/支持向量机" title="http://zh.wikipedia.org/zh/支持向量机" target="_blank" rel="noopener">http://zh.wikipedia.org/zh/支持向量机</a></li>
<li>CSIE：<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" title="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~cjlin/libsvm/</a></li>
<li>百科-SVM：<a href="http://baike.baidu.com/view/960509.html" title="http://baike.baidu.com/view/960509.html" target="_blank" rel="noopener">http://baike.baidu.com/view/960509.html</a></li>
<li>百科-支持向量机：<a href="http://baike.baidu.com/view/541845.htm" title="http://baike.baidu.com/view/541845.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/541845.htm</a></li>
<li>百科-LIBSVM: <a href="http://baike.baidu.com/view/598089.htm" title="http://baike.baidu.com/view/598089.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/598089.htm</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Classifier</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2010/11/linear-regression/</url>
    <content><![CDATA[<h1 id="线性回归-Linear-regression"><a href="#线性回归-Linear-regression" class="headerlink" title="线性回归-Linear regression"></a>线性回归-Linear regression</h1><blockquote>
<p>在统计学中，线性回归是利用称为线性回归方程的<a href="http://zh.wikipedia.org/zh-cn/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="noopener">最小二乘</a>函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合[1]</p>
</blockquote>
<a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynsw1b1adj30b807tdfu.jpg" alt="一元线性回归-Linear_regression"></p>
<p>带一个自变量的的线性回归：一元线性回归</p>
<p>通俗来说：所谓线性回归模型就是指因变量和自变量之间的关系是直线型的。</p>
<h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><p><a href="http://wiki.mbalib.com/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90" target="_blank" rel="noopener">回归分析</a>是对客观事物数量依存关系的分析．是<a href="http://wiki.mbalib.com/wiki/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1" target="_blank" rel="noopener">数理统计</a>中的一个常用的方法．是处理多个变量之间相互关系的一种数学方法[3]</p>
<blockquote>
<p>回归分析是一种统计学上对数据进行分析的方法，主要是希望探讨数据之间是否有一种特定关系。回归分析是建立因变量Y（或称依变量response variables, dependent variables）与自变量X（或称独变量，predictors, independent variables）之间关系的模型。目的在于了解两个或多个变量间是否相关、相关方向与强度，并建立数学模型以便观察特定变量来预测研究者感兴趣的变量[4]</p>
</blockquote>
<p>而线性回归是回归分析中的首要的一种分析研究方法，并广泛应用在各项实践分析领域。</p>
<h1 id="多元线性回归预测模型"><a href="#多元线性回归预测模型" class="headerlink" title="多元线性回归预测模型"></a>多元线性回归预测模型</h1><p>给定一个n组统计单元样本数据集 <img src="https://asset.vanjor.com/images/006tNbRwly1fynthkoen3j304g00la9t.jpg" alt="math">，一个线性回归模型假设因变量yi与p纬回归变量xi之间近似线性关系，这个近似关联模型建立通过引入一个误差项_εi_ (也是一个随机变量），来捕获除了x自变量之外任何对<em>Y__i</em>的影响。这样模型可以建立为：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntirsan6j30dc00nq2q.jpg" alt="math"></p>
<p>以向量方式可以表示为如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntqatoh5j302w00i0sh.jpg" alt="math"></p>
<p>其中：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntoav203j30ho031jrc.jpg" alt="math"></p>
<p>一般在科学论文研究中，做如下统一：</p>
<p>yi 称为因变量或从属变量（<em>regressand</em>）, xii称为回归量，自变量（<em>regressor</em>）</p>
<p>注：其中X通常会包含一个常数项,(不同于误差项_εi_ )，这时，观测值矩阵为[1] ：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynts0r0ksj305z031dfn.jpg" alt="math"></p>
<p>(如果_X_列之间存在线性相关，那麽参数向量β就不能以最小二乘法估计除非β被限制，比如要求它的一些元素之和为0)</p>
<h1 id="古典假设"><a href="#古典假设" class="headerlink" title="古典假设"></a>古典假设</h1><p>在线性回归模型理论中，样本是在总体之中随机抽取出来的。因变量在实直线上是连续的，误差项是独立同分布的，也就说，残差是i.i.d.(独立同分布，independent and identically distributed)且服从高斯分布。这些假设意味着残差项不依赖自变量的值，所以和自变量（预测变量）之间是相互独立的。</p>
<p>在这些假设下，建立一个显示线性回归作为条件预期模型的简单线性回归，可以表示为：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynttlwcykj306100lq2p.jpg" alt="math"></p>
<h1 id="最小二乘法估计-OLS"><a href="#最小二乘法估计-OLS" class="headerlink" title="最小二乘法估计(OLS)"></a>最小二乘法估计(OLS)</h1><p>最小二乘法(<a href="http://en.wikipedia.org/wiki/Ordinary_least_squares" target="_blank" rel="noopener">Ordinary least squares</a>[6])，是一种简洁并且常用的线性回归估计方法，回归分析的最初目的是估计模型的参数以便达到对数据的最佳拟合。在决定一个最佳拟合的不同标准之中，普通最小二乘法是非常优越的。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyntvejl8sj30ab00tjr7.jpg" alt="math"></p>
<p>其中，最小二乘法是建立在无偏一致估计，建立在古典假设，认为<img src="https://asset.vanjor.com/images/006tNbRwly1fyntwxaae1j302u00k3y9.jpg" alt="math">之上。</p>
<p>在得到参数的最小二乘法的估计值之后，需要进行必要的检验与评价，以决定模型是否可以应用。关于最小二乘法估计的回归推断见<a href="http://zh.wikipedia.org/zh-cn/線性回歸" target="_blank" rel="noopener">线性回归</a>[1] ，多元回归模型的检验见多元线性回归分析预测法[3]</p>
<p>其他估计方法有：<a href="http://en.wikipedia.org/wiki/Generalized_least_squares" target="_blank" rel="noopener">Generalized least squares</a> (GLS)，<a href="http://en.wikipedia.org/wiki/Iteratively_reweighted_least_squares" target="_blank" rel="noopener">Iteratively reweighted least squares</a> (IRLS)等[2]</p>
<p>具体一元线性回归分析预测法分析见<a href="http://wiki.mbalib.com/wiki/一元线性回归预测法" target="_blank" rel="noopener">一元线性回归预测法</a>[5]</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://zh.wikipedia.org/zh-cn/線性回歸" title="http://zh.wikipedia.org/zh-cn/線性回歸" target="_blank" rel="noopener">http://zh.wikipedia.org/zh-cn/線性回歸</a></li>
<li><a href="http://en.wikipedia.org/wiki/Linear_regression" title="http://en.wikipedia.org/wiki/Linear_regression" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Linear_regression</a></li>
<li><a href="http://wiki.mbalib.com/w/index.php?title=%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%E6%B3%95" title="http://wiki.mbalib.com/wiki/线性回归预测法" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/线性回归预测法</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/迴歸分析" title="http://zh.wikipedia.org/zh-cn/迴歸分析" target="_blank" rel="noopener">http://zh.wikipedia.org/zh-cn/迴歸分析</a></li>
<li><a href="http://wiki.mbalib.com/wiki/一元线性回归预测法" title="http://wiki.mbalib.com/wiki/一元线性回归预测法" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/一元线性回归预测法</a></li>
<li><a href="http://en.wikipedia.org/wiki/Ordinary_least_squares" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ordinary_least_squares</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Linear Regression</tag>
        <tag>Classifier</tag>
      </tags>
  </entry>
  <entry>
    <title>向量空间模型VSM</title>
    <url>/2010/11/vector-space-model/</url>
    <content><![CDATA[<p><strong>向量空间模型 (VSM：Vector Space Model)</strong> 是一个应用于资讯过滤, 资讯撷取, 索引以及评估相关性的代数模型。由Salton等人于60年代提出，并成功地应用于著名的SMART文本检索系统。</p>
<a id="more"></a>
<h1 id="VSM概念"><a href="#VSM概念" class="headerlink" title="VSM概念"></a>VSM概念</h1><p>文件(语料)被视为索引词(关键字)形成的多次元向量空间， 索引词的集合通常为文件中至少出现过一次的词组。在文本检索中，文档与查询词可以表示为以下向量空间模型[1] :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dj = (w1,j,w2,j,...,wt,j)</span><br><span class="line"></span><br><span class="line">q = (w1,q,w2,q,...,wt,q)</span><br></pre></td></tr></table></figure>
<p>搜寻时，输入的检索词q会被转换成类似于文件的向量，这个模型假设，文件和搜寻词的相关程度，可以经由比较每个文件(向量)和检索词(向量)的夹角偏差程度而得知。 由此两个文档向量空间的夹角余弦为:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz2hn4byj304s01pmwx.jpg" alt="向量空间模型（VSM）"></p>
<p>而对应检索词q与文档集中文档d2的向量空间夹角余弦为 :</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz2tu1ddj304k01umwx.jpg" alt="vector"></p>
<p>在坐标系中如图:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynz35rqdlj306805emx1.jpg" alt="向量空间模型-Vector Space Model"></p>
<p>(余弦为零表示检索词向量垂直于文件向量，即没有符合，也就是说该文件不含此检索词)</p>
<h1 id="VSM优势"><a href="#VSM优势" class="headerlink" title="VSM优势"></a>VSM优势</h1><p>向量空间模型相对标准布尔模型，优势在于:</p>
<ol>
<li>基于线性代数的简单模型</li>
<li>权重非简单的二值化</li>
<li>可以在查询与文档集见计算一个连续的相似度</li>
<li>可以按照文档集间的关联度做排序</li>
<li>可以进行局部匹配</li>
</ol>
<h1 id="VSM局限性"><a href="#VSM局限性" class="headerlink" title="VSM局限性"></a>VSM局限性</h1><ol>
<li>不适合处理过长的文件，因为近似值不理想（过小的<a href="http://zh.wikipedia.org/zh-cn/%E6%A0%87%E9%87%8F%E7%A7%AF" target="_blank" rel="noopener">标量积</a>以及过高的次元)。</li>
<li>检索词组必须要完全符合文件中出现的词组；不完整词组(子字串)会会生<a href="http://zh.wikipedia.org/w/index.php?title=False_positive&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">false positive</a>。</li>
<li>语言敏感度不佳；情境相同但使用不同语汇的文件无法被关连起来，这产生所谓的<a href="http://zh.wikipedia.org/w/index.php?title=False_negative&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">false negative</a></li>
<li>无法反应词语见的出现的顺序关联性</li>
<li>模型假设在词语特性均各自独立上</li>
<li>权重计算比较偏直觉经验上，而非十分正式</li>
</ol>
<p><strong>VSM通俗来说缺点</strong>:</p>
<ul>
<li>它的缺点是相似度的计算量大，当有新文档加入时，则必须重新计算词的权值；</li>
<li>不适合处理过长的文件，因为近似值不理想；</li>
<li>检索词组必须要完全符合文件中出现的词组，不完整词组(子字串)会会生false positive；</li>
<li>语言敏感度不佳，情境相同但使用不同语汇的文件无法被关联起来，这产生所谓的false negative。</li>
</ul>
<h1 id="VSM中的关键词-Term"><a href="#VSM中的关键词-Term" class="headerlink" title="VSM中的关键词(Term)"></a>VSM中的关键词(Term)</h1><p>向量空间模型是基于关键词标量模型的，关键词对于区分文档的作用是不同的。例如一些虚词对于区分文档的内容与查询是否相关并没有多大的意义。</p>
<p>对于概率模型而言，可以有完备的理论来估计每篇文档生成某个词的概率，因而其主要工作集中于如何确定较好的概率估计方法。而对于向量 空间模型来说，确定关键词权重在很大程度上依赖于研究者的经验及对文档特性的分析。</p>
<p>目前，对关键词权重的确定方法一般都需要获取一些关于关键词的统计量，而后根据这些统计量，应用某种认为规定的计算公式来得到权重。 最常用的统计量包括：</p>
<ul>
<li><strong>tf</strong>，(Term Frequency), 表示某个关键词在某个文档中出现的频率。</li>
<li><strong>qtf</strong>，(Query Term Frequency). 表示查询中某关键词的出现频率。</li>
<li><strong>N</strong>，(Num), 集合中的文档总数</li>
<li><strong>df</strong>，(Document Frequency), 的缩写，表示文档集合中，出现某个关键词的文档个数。</li>
<li><strong>idf</strong>，(Inversed Document Frequency), 的缩写。</li>
<li><strong>dl</strong>，(Document Length), 文档长度</li>
<li><strong>adl</strong>，(Average Document Length), 平均文档长度</li>
</ul>
<h1 id="VSM指导思想"><a href="#VSM指导思想" class="headerlink" title="VSM指导思想"></a>VSM指导思想</h1><p>在向量空间模型下，构造关键词权重计算公式有三个基本原则：</p>
<ol>
<li>如果一个关键词在某个文档中出现次数越多，那么这个词应该被认为越重要。</li>
<li>如果一个关键词在越多的文档中出现，那么这个词区分文档的作用就越低，于是其重要性也应当相应降低。</li>
<li>一篇文档越长，那么其出现某个关键词的次数可能越高，而每个关键词对这个文档的区分作用也越低，相应的应该对这些关键词予以一定的折扣。</li>
</ol>
<h1 id="扩展模型"><a href="#扩展模型" class="headerlink" title="扩展模型"></a>扩展模型</h1><p>基于向量空间模型上的扩展模型有</p>
<p>Models based on and extending the vector space model include:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Generalized_vector_space_model" target="_blank" rel="noopener">Generalized vector space model</a></li>
<li><a href="http://en.wikipedia.org/wiki/Topic-based_vector_space_model" target="_blank" rel="noopener">(enhanced) Topic-based Vector Space Model</a></li>
<li><a href="http://en.wikipedia.org/wiki/Latent_semantic_analysis" target="_blank" rel="noopener">Latent semantic analysis</a></li>
<li><a href="http://en.wikipedia.org/wiki/Latent_semantic_indexing" target="_blank" rel="noopener">Latent semantic indexing</a></li>
<li><a href="http://en.wikipedia.org/w/index.php?title=DSIR_model&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">DSIR model</a></li>
<li><a href="http://en.wikipedia.org/wiki/Term_Discrimination" target="_blank" rel="noopener">Term Discrimination</a></li>
<li><a href="http://en.wikipedia.org/wiki/Rocchio_Classification" target="_blank" rel="noopener">Rocchio Classification</a></li>
</ul>
<p><strong>参考:</strong></p>
<ol>
<li>WIKI, Vector Space Model：<a href="http://en.wikipedia.org/wiki/Vector_space_model" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Vector_space_model</a></li>
<li>SEO-VSM: <a href="http://www.dugutianjiao.com/post/vector-space-model-seo.html" target="_blank" rel="noopener">http://www.dugutianjiao.com/post/vector-space-model-seo.html</a></li>
<li>COGSYS,VSM:<a href="http://cogsys.imm.dtu.dk/thor/projects/multimedia/textmining/node5.html" target="_blank" rel="noopener">http://cogsys.imm.dtu.dk/thor/projects/multimedia/textmining/node5.html</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Information Retrieval</tag>
        <tag>Vector Space Model</tag>
      </tags>
  </entry>
  <entry>
    <title>TF-IDF统计</title>
    <url>/2010/11/tf-idf/</url>
    <content><![CDATA[<p><strong>TF-IDF</strong>（Term Frequency – Inverse Document Frequency）</p>
<p>TF-IDF是一种用于<a href="http://zh.wikipedia.org/zh-cn/%E8%B3%87%E8%A8%8A%E6%AA%A2%E7%B4%A2" target="_blank" rel="noopener">资讯检索</a>与<a href="http://zh.wikipedia.org/zh-cn/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98" target="_blank" rel="noopener">文本挖掘</a>的常用加权技术。TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度，也是建立在<a href="/2010/11/vector-space-model/">向量空间模型理论</a>中的一种统计技术。</p>
<p>字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了TF-IDF以外，互联网上的搜寻引擎还会使用基于链接分析(PR)的评级方法，以确定文件在搜寻结果中出现的顺序。</p>
<a id="more"></a>
<h1 id="公式概念"><a href="#公式概念" class="headerlink" title="公式概念"></a>公式概念</h1><p>在一个文本集中，对于一份给定的文件</p>
<p><strong>词频</strong>（Term Frequency，TF）指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被正规化，以防止它偏向长的文件。（同一个词语在长文件里可能会比短文件有更高的词频，而不管该词语重要与否。）对于在某一特定文件里的词语 <em>t__i</em> 来说，它的词频(重要性)可表示为：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynys23fwdj303v01qmwx.jpg" alt="tfidf"></p>
<p>(以上式子中 ni,j 是该词在文件dj中的出现次数，而分母则是在文件dj中所有字词的出现次数之和)</p>
<p><strong>逆向文件频率</strong>（Inverse Document Frequency，IDF）是一个词语普遍重要性的度量。某一特定词语的IDF，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynysdlg06j305t01vwe9.jpg" alt="tfidf"></p>
<p>(其中:</p>
<ul>
<li>| D |：语料库中的文件总数</li>
<li><img src="https://asset.vanjor.com/images/006tNbRwly1fynyuhu0g4j302t00k3y9.jpg" alt="tfidf">包含词语<em>t__i</em>的文件数目（即 <strong>ni,j != 0</strong>的文件数目）,如果关键词不在语料库中，这会导致除零错误，这种情况通常用1+<img src="https://asset.vanjor.com/images/006tNbRwly1fynyvjgwckj302t00k3y9.jpg" alt="tfidf">来代替。</li>
</ul>
<h1 id="TF-IDF权重："><a href="#TF-IDF权重：" class="headerlink" title="TF-IDF权重："></a>TF-IDF权重：</h1><p>由此，TF，IDF权重为TF，IDF的乘积</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynyzr2vxuj30g402gt8l.jpg" alt="tfidf"></p>
<p>为在整个文档集中，关键词Term i（最小单元）在文档j中的权重。某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于过滤掉常见的词语，保留重要的词语。</p>
<h1 id="基于TF-IDF余弦相似度"><a href="#基于TF-IDF余弦相似度" class="headerlink" title="基于TF-IDF余弦相似度"></a>基于TF-IDF余弦相似度</h1><p>查询q与文档dj的余弦相似度可以表示为:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynyphga3bj30ci02g0sj.jpg" alt="tf-idf-cosine"></p>
<p>其中，i为q与文档dj 把q视作一个文档向量，i为dj 与q中的每一个元关键词标量。</p>
<h1 id="TF-IDF的理论依据与不足"><a href="#TF-IDF的理论依据与不足" class="headerlink" title="TF-IDF的理论依据与不足"></a>TF-IDF的理论依据与不足</h1><p>TF-IDF算法是建立在这样一个假设之上的:</p>
<blockquote>
<p>对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取TF词频作为测度，就可以体现同类文本的特点。</p>
<p>另外考虑到单词区别不同类别的能力，TF-IDF法认为一个单词出现的文本频数越小，它区别不同类别文本的能力就越大。因此引入了逆文本频度IDF的概念，以TF和IDF的乘积作为特征空间坐标系的取值测度，并用它完成对权值TF的调整，调整权值的目的在于突出重要单词，抑制次要单词。</p>
</blockquote>
<p>但是在本质上IDF是一种试图抑制噪音的加权 ，并且单纯地认为文本频数小的单词就越重要，文本频数大的单词就越无用，显然这并不是完全正确的。IDF的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以TF-IDF法的精度并不是很高。</p>
<p>此外，在TFIDF算法中并没有体现出单词的位置信息，这也是空间向量模型的不足点。对于Web文档而言，权重的计算方法应该体现出HTML的结构特征。特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>WIKI,TF-IDF: <a href="http://en.wikipedia.org/wiki/Tf–idf" title="http://en.wikipedia.org/wiki/Tf–idf" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Tf–idf</a></li>
<li>BAIDU,TF-IDF: <a href="http://baike.baidu.com/view/1228847.html" title="http://baike.baidu.com/view/1228847.html" target="_blank" rel="noopener">http://baike.baidu.com/view/1228847.html</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Information Retrieval</tag>
        <tag>TF-IDF</tag>
      </tags>
  </entry>
  <entry>
    <title>信息检索基本评价指标-P·R·F</title>
    <url>/2010/11/recall-precision/</url>
    <content><![CDATA[<p>任何研究都需要有一个客观的评价体系，信息检索系统也不例外。但是对于一项需要在实际生产生活中应用的系统，其评价导向又必须包含一定的主观性。</p>
<p>信息检索系统性能的两个基本客观指标是 <strong>召回率(Recall Rate)</strong> 和 <strong>准确率(Precision Rate)</strong> 这与绝大多数的模式识别技术相同。</p>
<a id="more"></a>
<p>召回率和精度是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中召回率是是检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率。精度是检索出的相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率。</p>
<h1 id="概念公式"><a href="#概念公式" class="headerlink" title="概念公式"></a>概念公式</h1><blockquote>
<p>召回率 =  系统检索到的相关文件 / 系统所有相关的文件总数</p>
<p>准确率 = 系统检索到的相关文件 / 系统所有检索到的文件总数</p>
</blockquote>
<p>运用图示表示如下<br><img src="https://asset.vanjor.com/images/006tNbRwly1fynu9mb0drj30d70800sq.jpg" alt="召回率，准确率，F-measure"></p>
<h1 id="召回率，准确率关系"><a href="#召回率，准确率关系" class="headerlink" title="召回率，准确率关系"></a>召回率，准确率关系</h1><p>由于信息检索系统返回的是一个排序的文档集合，因此召回率与准确率是互补的。设定不同的相关性得分门限就能够得到相应的准确率与 召回率。如果我们在以准确率为Y轴，召回率为X轴的图上画出不同门限下的准确率与召回率，一般它会程下面的形状：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxal1hldj309u07jjrb.jpg" alt="召回率 准确率关系"></p>
<p>那么，对于系统的评价指标就存在一个问题，如果一个系统偏重与给用户最准确的结果，那么高的准确率是必要的，反之，如果系统 希望包括尽可能多的相关结果，又会偏好召回率。系统如果简单的用召回率或准确率对系统性能作评价，无法评估系统的理想性能的。</p>
<h1 id="F-meause值"><a href="#F-meause值" class="headerlink" title="F-meause值"></a>F-meause值</h1><p>模式识别中常用F值作为性能的评价指标，其定义为以召回率R与准确率P为基础：F=2PR/P+R。</p>
<p><strong>F值以平衡地反映召回率与准确率，但是在信息检索中仍然不是非常实用，因为它仍然是一个单点的指标，没有反映全局特性</strong>。</p>
<p><strong>平均准确率(mean Average Precision, mAP):</strong></p>
<p>mAP是为解决P，R，F-measure的单点值局限性的。为了得到 一个能够反映全局性能的指标，可以看考察下图，其中两条曲线(方块点与圆点)分布对应了两个检索系统的准确率-召回率曲线。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyo0z9bzkmj309u07it8p.jpg" alt="Mean-avg-prec"></p>
<p>可以看出，虽然两个系统的性能曲线有所交叠但是以圆点标示的系统的性能在绝大多数情况下要远好于用方块标示的系统。</p>
<p>从中我们可以 发现一点，如果一个系统的性能较好，其曲线应当尽可能的向上突出。更加具体的，曲线与坐标轴之间的面积应当越大。最理想的系统， 其包含的面积应当是1，而所有系统的包含的面积都应当大于0。这就是用以评价信息检索系统的最常用性能指标，</p>
<h1 id="平均准确率mAP"><a href="#平均准确率mAP" class="headerlink" title="平均准确率mAP"></a>平均准确率mAP</h1><p>其规范的定义如下:(其中P，R分别为准确率与召回率)</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynxgyan35j304w019t8h.jpg" alt="mAP"></p>
<p>一般在做评价时取得的准确率与召回率都是离散值，因此一般在计算时都采用求和而非积分.</p>
<p>mAP是一个较好的客观评价指标，但是它也有一个缺陷，那就是</p>
<p><strong>缺乏直观性,是一个系统的总体性能评价指标，但无法反应区段间的变化。因此在系统评测时常常还是要附带上准确率-召回率曲线</strong>。</p>
<h1 id="单值评价指标N-Best"><a href="#单值评价指标N-Best" class="headerlink" title="单值评价指标N-Best"></a>单值评价指标N-Best</h1><p>在实际应用中，还有一些单值评价指标，能够反映系统的主观性能。其中最常用的是N-Best准确率。一般系统的返回结果都采用分页显示，用户一般 不会翻看太多页，从实际应用的角度看，前几个结果在检索中是最为重要的。N-Best准确率可以很好的反映这个性能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>高勤,《汉语语音文档检索技术研究及系统实现》. 北京大学硕士研究生学位论文 <a href="http://geek.kyloo.net/public/master-thesis.pdf" target="_blank" rel="noopener">http://geek.kyloo.net/public/master-thesis.pdf</a></li>
<li>WIKI: <a href="http://zh.wikipedia.org/zh/%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2" target="_blank" rel="noopener">http://zh.wikipedia.org/zh/%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2</a></li>
<li>互动百科 <a href="http://www.hudong.com/wiki/%E5%8F%AC%E5%9B%9E%E7%8E%87" target="_blank" rel="noopener">http://www.hudong.com/wiki/%E5%8F%AC%E5%9B%9E%E7%8E%87</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Information Retrieval</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开源自然语言处理-LingPipe</title>
    <url>/2010/11/lingpipe/</url>
    <content><![CDATA[<p><a href="http://alias-i.com/lingpipe/" target="_blank" rel="noopener">LingPipe</a> 是<a href="http://alias-i.com/" target="_blank" rel="noopener">Alias-i</a>公司开发的一款自然语言处理开源Java软件包，目前最高版本是4.0.1</p>
<a id="more"></a>
<h1 id="LingPipe的优势"><a href="#LingPipe的优势" class="headerlink" title="LingPipe的优势"></a>LingPipe的优势</h1><ul>
<li>比较全面的覆盖自然语言处理的各个分支，文本分词，聚类，语义情感分析，领域知识学习等等</li>
<li>具有全套在research上免费的源码，样列代码，测试代码(商业与非商业均同一套代码)，并且文档详细，对于其中模型所参考的论文都引用出来，适合研究学习.</li>
<li>作为相对开源资源缺少的领域，项目一直持续更新中.</li>
</ul>
<h1 id="LinePipe包含的模块"><a href="#LinePipe包含的模块" class="headerlink" title="LinePipe包含的模块"></a>LinePipe包含的模块</h1><ul>
<li><strong>主题分类（Top Classification）</strong>: 基于文本语言模型训练，归类</li>
<li><strong>命名实体识别（Named Entity Recognition）</strong>: 基于first-best, n-best and per-entity confidence modes识别，以及训练与评估识别器</li>
<li><strong>聚类（Clustering）</strong>: 基于single-link and complete-link多层聚类，包裹一些聚类评估技术</li>
<li><strong>词性标注（Part-of Speech Tagging）</strong></li>
<li><strong>句题检测（Sentence Detection）</strong></li>
<li><strong>拼写更正（Spelling Correction）</strong>:基于”你要找的是” 风格的检查引擎</li>
<li><strong>数据库文本挖掘（Database Text Mining）</strong></li>
<li><strong>字符串比较(String Comparison)</strong>: 基于距离与相似度测量，包括权重距离，TF/IDF距离，Jaccard distance, Jaro-Winkler distance, 等</li>
<li><strong>兴趣短语检测（Interseting Phrase Detection）</strong></li>
<li><strong>字符语言建模（Character Language Modeling）</strong></li>
<li><strong>中文分词（Chinese Word Segmentation）</strong>: 基于空格分割类似训练库，机器学习，发现认知新词</li>
<li><strong>数据库文本挖掘（Database Text Mining）</strong></li>
<li><strong>情感分析（Sentiment Analysis）</strong>: 基于文本聚类</li>
<li><strong>断字识音（Hyphenation and Syllabification）</strong></li>
<li><strong>语言辨别（Language Identification）</strong></li>
<li><strong>奇异值分解（Singular Value Decomposition）</strong></li>
<li><strong>逻辑回归 （Logistic Regression）</strong></li>
<li><strong>期望最大化（Expectation Maximization）</strong></li>
<li><strong>词义排歧（Word Sense Disambiguation）</strong></li>
</ul>
<h1 id="LingPipe包含资源"><a href="#LingPipe包含资源" class="headerlink" title="LingPipe包含资源"></a>LingPipe包含资源</h1><ul>
<li>Source： <a href="http://alias-i.com/lingpipe/web/download.html" target="_blank" rel="noopener">http://alias-i.com/lingpipe/web/download.html</a></li>
<li>API Docs: <a href="http://alias-i.com/lingpipe/docs/api/index.html" target="_blank" rel="noopener">http://alias-i.com/lingpipe/docs/api/index.html</a></li>
<li>Tutorials: <a href="http://alias-i.com/lingpipe/demos/tutorial/read-me.html" target="_blank" rel="noopener">http://alias-i.com/lingpipe/demos/tutorial/read-me.html</a></li>
<li>Papaer&amp;language material : source，介绍中均包含有所引用资源</li>
</ul>
<p>目前个人应用LingPipe包中的中文分词，结合情感分析模块研究中文情感检测与辨别。API接口均已高度概括化，便于快速实现，不过所运用的算法需要详尽的分析。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://alias-i.com/lingpipe/" target="_blank" rel="noopener"><strong>LingPipe</strong></a>: <a href="http://alias-i.com/lingpipe" target="_blank" rel="noopener">http://alias-i.com/lingpipe</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>NLU</tag>
        <tag>LingPipe</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板方法</title>
    <url>/2010/11/template-method/</url>
    <content><![CDATA[<p><strong>Java Design Pattern - Template Method ( 模板方法 )</strong>.</p>
<a id="more"></a>
<h1 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h1><ul>
<li><strong>归类</strong>: 操作性模式</li>
<li><strong>目标</strong>: 在一个方法中实现一个算法，把算法中的某些步骤定义进行抽象，推迟到子类中去重新定义，或具体实现。</li>
<li><strong>实现方法</strong>: 准备一个抽象类，定义一个操作中的算法的骨架，将一些步聚声明为抽象方法迫使子类去实现。不同的子类可以以不同的方式实现这些抽象方法。</li>
<li><strong>样列</strong>: 以<a href="http://zh.wikipedia.org/zh/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">WIKI</a>中的的样列代码为列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An abstract class that is common to several games in</span></span><br><span class="line"><span class="comment">* which players play against the others, but only one is</span></span><br><span class="line"><span class="comment">* playing at a given time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> playersCount;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initializeGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makePlay</span><span class="params">(<span class="keyword">int</span> player)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">endOfGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWinner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A template method : */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">playOneGame</span><span class="params">(<span class="keyword">int</span> playersCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.playersCount = playersCount;</span><br><span class="line">        initializeGame();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!endOfGame())&#123;</span><br><span class="line">            makePlay(j);</span><br><span class="line">            j = (j + <span class="number">1</span>) % playersCount;</span><br><span class="line">        &#125;</span><br><span class="line">        printWinner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Now we can extend this class in order to implement actual games:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monopoly</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Implementation of necessary concrete methods */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePlay</span><span class="params">(<span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">endOfGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWinner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Specific declarations for the Monopoly game. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Implementation of necessary concrete methods */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePlay</span><span class="params">(<span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">endOfGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWinner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Specific declarations for the chess game. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于具有公用的程式，通过抽象类Game定义模板方法与对外行为步骤，明确对外行为规范，具体实现子类，ChessGame按照父类接口程式实现各自方法内部逻辑功能。</p>
<p>不同的子类游戏通过共同父类，实现统一接口，消除代码重复，与混乱不一致，并做到代码即是文档接口，方便他人扩展与实现。</p>
<p>模板方法不要求定义子类前编写具体模板方法，而是抽象算法框架，上移至超类，简化和组织代码，作为开发者间的一种约束。</p>
<p>这就是：</p>
<p>通常我们会遇到这样的一个问题：我们知道一个算法所需的关键步聚，并确定了这些步聚的执行顺序。但是某些步聚的具体实现是未知的，或者是某些步聚的实现与具体的环境相关。</p>
<p>模板方法模式把我们不知道具体实现的步聚封装成抽象方法，提供一些按正确顺序调用它们的具体方法(这些具体方法统称为模板方法),这样构成一个抽象基类。子类通过继承这个抽象基类去实现各个步聚的抽象方法，而工作流程却由父类来控制。</p>
<p><strong>JDK中样列</strong>:</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynygm0dzuj30dz053aa1.jpg" alt="template method"></p>
<p>JDK类：Arrays和Collections提供的sort(）方法</p>
<h1 id="深入模式"><a href="#深入模式" class="headerlink" title="深入模式"></a>深入模式</h1><p><strong>模式中两种角色</strong>:</p>
<ul>
<li><strong>抽象模版（AbstractClass</strong>: 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。定义并实现了一个模版方法。这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
<li><strong>具体模版（ConcreteClass）</strong>: 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。每一个抽象模版角色都可以有任意多个具体模版角色与之对应，而每一个具体模版角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<p>在高级语言中，模板方法通过多态，继承，封装而灵活的应用，总之模板类适用于以下场景：</p>
<ul>
<li><strong>延迟具体实现</strong>: 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li><strong>公用行为归纳</strong>: 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。其实这可以说是一种好的编码习惯了。</li>
<li><strong>控制子类扩展</strong>: 模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。如果不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做：一是在API中不体现出你的模板方法；二将模板方法置为final组织被覆盖。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Javaeye: <a href="http://www.javaeye.com/topic/78611" target="_blank" rel="noopener">http://www.javaeye.com/topic/78611</a></li>
<li>cnBlog: <a href="http://www.cnblogs.com/zhenyulu/articles/79894.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhenyulu/articles/79894.html</a></li>
</ol>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉验证</title>
    <url>/2010/10/cross-validation/</url>
    <content><![CDATA[<blockquote>
<p><strong>交叉验证(Cross-Validation):</strong> 有时亦称循环估计， 是一种统计学上将数据样本切割成较小子集的实用方法。于是可以先在一个子集上做分析， 而其它子集则用来做后续对此分析的确认及验证。 一开始的子集被称为训练集。而其它的子集则被称为验证集或测试集。<a href="http://zh.wikipedia.org/zh-sg/%E4%BA%A4%E5%8F%89%E9%A9%97%E8%AD%89" target="_blank" rel="noopener">WIKI</a></p>
</blockquote>
<p>交叉验证对于人工智能，机器学习，模式识别，分类器等研究都具有很强的指导与验证意义。<br>基本思想是把在某种意义下将原始数据(dataset)进行分组,一部分做为训练集(train set),另一部分做为验证集(validation set or test set),首先用训练集对分类器进行训练,在利用验证集来测试训练得到的模型(model),以此来做为评价分类器的性能指标.</p>
<a id="more"></a>
<h1 id="三大CV的方法"><a href="#三大CV的方法" class="headerlink" title="三大CV的方法"></a>三大CV的方法</h1><h2 id="Hold-Out-Method"><a href="#Hold-Out-Method" class="headerlink" title="Hold-Out Method**"></a>Hold-Out Method**</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>将原始数据随机分为两组,一组做为训练集,一组做为验证集,利用训练集训练分类器,然后利用验证集验证模型,记录最后的分类准确率为此Hold-OutMethod下分类器的性能指标.。Hold-OutMethod相对于K-fold Cross Validation 又称Double cross-validation ，或相对K-CV称 2-fold cross-validation(2-CV)</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>优点</strong>: 好处的处理简单,只需随机把原始数据分为两组即可</li>
<li><strong>缺点</strong>: 严格意义来说Hold-Out Method并不能算是CV,因为这种方法没有达到交叉的思想,由于是随机的将原始数据分组,所以最后验证集分类准确率的高低与原始数据的分组有很大的关系,所以这种方法得到的结果其实并不具有说服性.(主要原因是 训练集样本数太少，通常不足以代表母体样本的分布，导致 test 阶段辨识率容易出现明显落差。此外，2-CV 中一分为二的分子集方法的变异度大，往往无法达到「实验过程必须可以被复制」的要求。)</li>
</ul>
<h2 id="K-fold-Cross-Validation-记为K-CV"><a href="#K-fold-Cross-Validation-记为K-CV" class="headerlink" title="K-fold Cross Validation(记为K-CV)"></a>K-fold Cross Validation(记为K-CV)</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p><strong>作为</strong>1)**的演进，将原始数据分成K组(一般是均分),将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标.K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2. 而K-CV 的实验共需要建立 k 个models，并计算 k 次 test sets 的平均辨识率。在实作上，k 要够大才能使各回合中的 训练样本数够多，一般而言 k=10 (作为一个经验参数)算是相当足够了。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynsizoaylg30bp07xdfv.gif" alt="K-fold Cross Validation - A 5-fold cross validation method"></p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>优点</strong>: K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性.</li>
<li><strong>缺点</strong>: K值选取上</li>
</ul>
<h2 id="Leave-One-Out-Cross-Validation-记为LOO-CV"><a href="#Leave-One-Out-Cross-Validation-记为LOO-CV" class="headerlink" title="Leave-One-Out Cross Validation(记为LOO-CV)"></a>Leave-One-Out Cross Validation(记为LOO-CV)</h2><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>如果设原始数据有N个样本,那么LOO-CV就是N-CV,即每个样本单独作为验证集,其余的N-1个样本作为训练集,所以LOO-CV会得到N个模型,用这N个模型最终的验证集的分类准确率的平均数作为此下LOO-CV分类器的性能指标.</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>优点</strong>: 相比于前面的K-CV,LOO-CV有两个明显的优点：<strong>a.</strong>每一回合中几乎所有的样本皆用于训练模型,因此最接近原始样本的分布,这样评估所得的结果比较可靠。   <strong>b.</strong> 实验过程中没有随机因素会影响实验数据,确保实验过程是可以被复制的.</li>
<li><strong>缺点</strong>: 计算成本高,因为需要建立的模型数量与原始数据样本数量相同,当原始数据样本数量相当多时,LOO-CV在实作上便有困难几乎就是不显示,除非每次训练分类器得到模型的速度很快,或是可以用并行化计算减少计算所需的时间.</li>
</ul>
<p>在模式识别与机器学习的相关研究中，经常会将 数据集分为 训练集与测试集 这两个子集，前者用以建立 模式，后者则用来评估该 模式对未知样本进行预测时的精确度，正规的说法是 generalization ability(泛化能力)</p>
<h1 id="交叉验证核心原则"><a href="#交叉验证核心原则" class="headerlink" title="交叉验证核心原则"></a>交叉验证核心原则</h1><p>Cross-validation 是为了有效的估测 generalization error 所设计的实验方法</p>
<blockquote>
<p>只有训练集才可以用在 模式的训练过程中，测试集 则必须在模式完成之后才被用来评估 模式优劣的依据。</p>
</blockquote>
<h2 id="常见的错误运用"><a href="#常见的错误运用" class="headerlink" title="常见的错误运用"></a>常见的错误运用</h2><p>许多人在研究都有用到 Evolutionary Algorithms(EA,遗传算法)与 classifiers，所使用的 Fitness Function (适应度函数)中通常都有用到 classifier 的辨识率，然而把Cross-Validation 用错的案例还不少。前面说过，只有 training data 才可以用于 model 的建构，所以只有 training data 的辨识率才可以用在 fitness function 中。而 EA 是训练过程用来调整 model 最佳参数的方法，所以只有在 EA结束演化后，model 参数已经固定了，这时候才可以使用 test data。</p>
<ul>
<li><strong>EA 与 CV结合研究方法：</strong> Cross-Validation 的本质是用来估测某个 classification method 对一组 dataset 的 generalization error，不是用来设计 classifier 的方法，所以 Cross-Validation 不能用在 EA的 fitness function 中，因为与 fitness function 有关的样本都属于 training set，那试问哪些样本才是 test set 呢？如果某个 fitness function 中用了Cross-Validation 的 training 或 test 辨识率，那么这样的实验方法已经不能称为 Cross-Validation .</li>
<li><strong>EA 与 k-CV 正确的搭配方法</strong>: 是将 dataset 分成 k 等份的 subsets 后，每次取 1份 subset 作为 test set，其余 k-1 份作为 training set，并且将该组 training set 套用到 EA 的 fitness function 计算中(至于该 training set 如何进一步利用则没有限制)。因此，正确的 k-CV 会进行共 k 次的 EA 演化，建立 k 个classifiers。而 k-CV 的 test 辨识率，则是 k 组 test sets 对应到 EA 训练所得的 k 个 classifiers 辨识率之平均值.</li>
</ul>
<h1 id="数据集分割原则"><a href="#数据集分割原则" class="headerlink" title="数据集分割原则"></a>数据集分割原则</h1><p>交叉验证在，原始数据集分割为训练集与测试集，必须遵守两个要点：</p>
<blockquote>
<ol>
<li>训练集中样本数量必须够多，一般至少大于总样本数的 50%。</li>
<li>两组子集必须从完整集合中均匀取样。</li>
</ol>
</blockquote>
<p>其中第 <strong>2</strong> 点特别重要，均匀取样的目的是希望减少 训练集/测试集 与完整集合之间的偏差(bias)，但却也不易做到。一般的作法是随机取样，当样本数量足够时，便可达到均匀取样的效果。然而随机也正是此作法的盲点，也是经常是可以在数据上做手脚的地方。举例来说，当辨识率不理想时，便重新取样一组训练集 与测试集，直到测试集的辨识率满意为止，但严格来说便算是作弊。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>MATLAB中文: <a href="http://www.ilovematlab.cn/viewthread.php?tid=49143" target="_blank" rel="noopener">http://www.ilovematlab.cn/viewthread.php?tid=49143</a></li>
<li>SHAMO: <a href="http://www.shamoxia.com/html/y2010/2245.html" target="_blank" rel="noopener">http://www.shamoxia.com/html/y2010/2245.html</a></li>
<li>ProClassify: <a href="http://genome.tugraz.at/proclassify/help/pages/XV.html" target="_blank" rel="noopener">http://genome.tugraz.at/proclassify/help/pages/XV.html</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Cross Validation</tag>
      </tags>
  </entry>
  <entry>
    <title>幸福，忧伤，生活</title>
    <url>/2010/10/mv-neyanbhbin/</url>
    <content><![CDATA[<p>忙累之中，看到朋友发来一个mv链接,听到这个钢琴萨克斯小曲neyanbhbin(中文：悲伤天使), 听到一种流畅，恬然的指尖旋律，又不失激起心中的一阵阵的涟漪，这不正是内心所寻找的一种感觉么?</p>
<a id="more"></a>
<p>坐在窗台边的作曲家，外在的闲暇与内在的淡泊的凝视窗外，感受品味世井中人与人之间那种最微妙的信息传递，也在体味那种事态万千，生命流水的私语。也激起内心的一阵阵涟漪，幸福，忧伤，生活，手指不由舞动在畅想的琴键里。</p>
<p>每个人都应该能拥有一片这样的时间，静静的在角落观察这个世界，不受干扰确又能有所内心搅动，这也是指尖中的舞蹈的一个主题。指尖中的舞蹈，却传动至心底。</p>
<ol>
<li>Note：此曲为俄国作曲家，钢琴家 伊戈尔. 克鲁托伊 的 neyanbhbin钢琴曲(中文：悲伤天使)</li>
<li>MP3：<a href="http://www.gougou.com/search?search=neyanbhbin&amp;restype=-1&amp;id=10000001&amp;ty=0&amp;pattern=0&amp;xmp=0" target="_blank" rel="noopener">http://www.gougou.com/search?search=neyanbhbin</a></li>
</ol>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title>云端十月</title>
    <url>/2010/10/cloud-as-life-oct/</url>
    <content><![CDATA[<h1 id="在云端"><a href="#在云端" class="headerlink" title="在云端"></a>在云端</h1><blockquote>
<p>生活到底有多重？假设你背着一个背包，感受勒在你肩上的背带，感受到了么？</p>
</blockquote>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynsek5jt5j30m80dwdi3.jpg" alt="up in the air ,see the sunshines"></p>
<a id="more"></a>
<blockquote>
<p>我要你把生活中的一切都装入这个背包，从最小的物件开始，书架上的，抽屉里的，零食，一切乱七八糟的东西，感受重量不断增加。</p>
<p>现在开始往里面装大点的物件，衣服，桌上的东西，台灯，毛巾枕头，电视机。 现在它应该不小了，再往里面放更大的东西，你的沙发，床，餐桌，汽车，你的家，把他们统统装进去，现在，试着走走，是不是很沉重？</p>
<p>这就是我们每天做的事情，我们不断的给自己增重直到寸步难行，我们绝不容许一个失误。现在我决定把你的背包烧了，你决定从里面拿出什么？照片？照片是给那些记不住事儿的人准备的，告诉你们，把所有的东西都烧了吧，想象一下，明天早上起来，孑然一身，轻装上阵吧！</p>
<p>今晚大多数人都将回到自己的温暖的小家，迎接家里闹腾的小狗，吵闹的孩童，他们的伴侣会关切的打听白天发生的事情，晚上，他们在夜幕中安然入睡…</p>
<p>星星从白天隐藏的角落 慢慢的爬升出来，而那些天边的微光中会有一个更为明亮的 它就是我的冀翼 ，祝福着其他人，悄然拂过…</p>
</blockquote>
<p>这是电影《<a href="http://movie.douban.com/subject/3077791/" target="_blank" rel="noopener">Up in the air</a>》中一段独白，时常会想，自己每天的背包究竟又装些什么呢？抑或想起<a href="http://www.zreading.cn/archives/1984.html" target="_blank" rel="noopener">左岸</a>中提到了：<strong>世界上最浪费时间的是三个单词：WORRY, BLAME, &amp; JUDGEMENT</strong>. 那么究竟该怎么平衡呢，让云端生活不过于轻松浮夸又不至于沉重压抑。</p>
<h1 id="分治人生"><a href="#分治人生" class="headerlink" title="分治人生"></a>分治人生</h1><p>经济学建立的基石是资源的稀缺性，以至于因为时间是那么最公正般的播撒至我们，让我们有些无法感受到它的稀缺，我们每天斤斤计较的不应是任何外在的物质和情感，而是时间，就像这个世界建立在空间与时间的交叉中，如果抹掉时间，世界也将不复曾在。</p>
<p>最近翻到一本《<a href="http://book.douban.com/subject/1139244/" target="_blank" rel="noopener">编程高手箴言</a>》中提到一点很有道理：</p>
<blockquote>
<p>计算机技术没有任何时候是突变的。它的今年和去年相差不会很大，但是回过头来看三年以前的情况，和现在的距离就很大。所以说，如果你每年都跟着技术进步的话，你的压力就很小，因为你时刻都能掌握最新的技术。但是，如果你落下来，别说十年，就是三年，你就赶不上了。</p>
<p>如果你一旦赶不上，就会觉得非常吃力；如果你赶不上，你就会迷失方向；如果你迷失了方向，你就觉得计算机没有味道，越做越没劲。当你还只是有个思路的时候，别人的产品都做出来了，因为你的水平跟别人相差太远，人家早就想到的问题，你现在才开始认识。水平越高，他就看得越远，那么他的思维就越开阔；水平越低，想的问题就越窄。</p>
</blockquote>
<p>如不更上时代领域的节奏，一味惘然之追最终只会疲于劳累，更加看不到前方的道路，时代与领域的快速更新变化，我们是无法控制，我们能够控制的是将这种万里长跑划分为一小段一小段，与节奏同舞，洞察变迁，不渝的更新扩充自身的知识能力，那纵使万里也不再是不可跨越。就像中国原来普及2G网络，国外3G研究应用就已近很成熟了，现在中国全盘布局3G网络，国外4G网络研究正热火朝天，中国近代的落后导致很多领域上的步步落后的被动，也往往警醒着我们不要麻木与习惯着做一个追赶者，每一个人都可以努力博得自己的一片浪潮之巅。</p>
<p>做科研，研究问题，在很多合适的场合都会讲究分而治之，分系统，分模块，分流程，分场景。而小时候老师经常讲起的，每天回家带回一块小石头，坚持下来，不经意间的小石山将会是那么容易。这也不正是分而治之最好的列子么，将堆积一座小山的任务划分为无数个天里，每一天的任务是那么清楚，便于执行。</p>
<h1 id="时间账单"><a href="#时间账单" class="headerlink" title="时间账单"></a>时间账单</h1><p>上周五，正好微软2011《<a href="http://www.joinms.com/" target="_blank" rel="noopener">智在未来</a>》校园在学校会场举行，便去听了，印象最深的不是微软精心布置的会场，不是张亚勤博士的云计算演讲，不是微软的xbox 360的体验展示，而是会前的一位同学的话，他谈到他们实验室公司之前来的一个manager(因为说与我比较像，才引起这个话题)执掌了两个月，走了什么都没留下，就留下了一本“工作日志”，上面记录了每天的工作预期与完成状况，包括管理之下的每一个成员的每天安排与总结，从不间断。这种将每天的时间账给书面明确下来，不间断的执行力，就是那位manager的一种难得素质与能力，也是自身魄力所在，想想自己潜在的多少糊涂账。就像理财一样，如果那样的对时间的付出做出评估，又将会看到多少惋惜，不应该的浪费，也会探到碌碌无为之底症。也想到之前IBM的项目组，对于项目的管理安排，更看重是对人的分配规划，对人/天的分配安排，公司会在每年底对于作出绩效考核，那么我们每个人是否也应该为自己理一笔账呢?</p>
<h1 id="Coding而想"><a href="#Coding而想" class="headerlink" title="Coding而想"></a>Coding而想</h1><p>上周末的<a href="http://www.morganstanleychina.com/" target="_blank" rel="noopener">摩根</a>的Coding比赛弄的两天天昏地暗，当题目确认好后(比赛题目文档:<a href="https://asset.vanjor.com/documents/2010/Morgan_Stanley_Coding_Competition.pdf" target="_blank" rel="noopener">Morgan Stanley Coding Competition</a>)，得知所时间也是24小时整，起初看起来仍然是比较充足，然后不知不觉就已近开始计时了，走上这24小时急速征程：</p>
<ul>
<li>9:00 开题与疑问咨询，因为我们外校，协助主办方解决网络问题，而这前后花了3小时,也为此两个人一人award了一件衣服:*。</li>
<li>12:00 开始讨论着题目的系统构建模块，从网络传输，数据获取，到数据预处理，决策系统模块，发现样例中构建了基本模型通路，这些都可以不做考虑。然后开始讨论核心所需要做的环节模块：决策分析。</li>
<li>13:00 讨论影响决策的可能因素，各种算法模型，虽有所明确，但依然在云端，没有落实明确具体，因为想法一段很美好，把一切该考虑的都考虑进来，勾画也就难了。</li>
<li>19:00 定义数据模型，构建数据库，能够将原始数据规整到数据库中进行分析。</li>
<li>23:00 我们各种方式分析源数据，分析做出曲线走向后的规律，依然因为决策模型想的太复杂，考虑的因素过去多(一方面也是因为在这么相对有限的时间内，去想做的完美)，掌握了一些规律后，依然不得具体模型，也因此依然没有进入coding</li>
<li>2:00 各自都疲劳了，轮流换班睡了将近1小时</li>
<li>4:00 在队友睡中，自己睡醒更加紧迫思考，一些环节从简，完美的奢求在有限的时间资源内都是一个次优解，提出一个三阶段渐进完善模型，当然在最后的三小时，也只能完成一个阶段的模型。</li>
<li>7:00 虽然只是做出一个十分简单的模型，但是如果有时间的话，第二阶段，第三阶段，会是很快的。</li>
<li>9:00-12:00 最终结果预估仍然可以占到中上游，而且我们还是稳健的操盘手，更加能理解更优异的成绩其实都不难,现在是剩下一点不小的遗憾了。</li>
</ul>
<p>细致的描述，目的在于总结经验与教训，话说很多完美主义者又是行动拖延症患者，很多时候想法都是很好的，但是如何去控制，在最有限的时间资源内尽快做出明确的决策，外在的逼迫做出一些现实的舍弃，最先跨越那从无到有的一步，便最有可能是胜者。同时最终简单的模型依然work很好，有些时候复杂不一定都是好的，简单不一定都是不好，some case: no code is better code.</p>
<h1 id="云端十月"><a href="#云端十月" class="headerlink" title="云端十月"></a>云端十月</h1><p>云端十月，似云端里腾游，感触万头簇发竟得以哽咽，依然的回归于平实，时光更是马不停蹄的越跑越快，容不得半点迟疑与停顿，也不到一年了，明年此时正值闯荡初，更应周密而备。</p>
<p>云端十月的寄语: 云自心来，透晓如心，明晓当下，智探未来</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>九月秋语</title>
    <url>/2010/09/autumn-whisper/</url>
    <content><![CDATA[<h1 id="时间胶卷"><a href="#时间胶卷" class="headerlink" title="时间胶卷"></a>时间胶卷</h1><p>依然是八月，在返回北京的途中，尚还如沉浸在如痴如幻中，一幕一景，细腻、奇幻，曾过的每一刻光阴，都要用无尽的时间来尽情回味。</p>
<a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynsbawgehj30sg0lcmyx.jpg" alt="fisher"></p>
<p>归来的当天中午，和同组的女生一起吃饭，问她一个曾经重复了几次的问题，周末过的怎么样，从她的一丝茫然的眼光，依然在家休息的回答中。</p>
<p>不禁畅怀，时间虽说是线性的同等对待着我们，没有丝毫偏袒，但我们却不是同等线性的对待时间，同样的天空底下，奔波在各自的梦想中。</p>
<p>当我们懂得珍视时，会毫不犹豫的不自主的选择那最清晰的画面，最丰富的色泽，来记录下那度过一切，难忘每一个珍视的笑脸与话语,将成为人生永恒的一笔财富。</p>
<p>而当我们漠然相待时，时间变也变得黯淡，也将被抹成一卷简陋的胶卷，模糊的画面，灰暗的视野，很快随着时间推移而彻底消逝，而那段时间也将无痕的从生命中蒸发。</p>
<p>而我将会为今心一直持留那份最为厚重的胶卷，不落下一片风景，不褪一丝颜色。</p>
<h1 id="生死之歌"><a href="#生死之歌" class="headerlink" title="生死之歌"></a>生死之歌</h1><p>依然是八月，当各种灾难事件频发之时，人依然是那么的脆弱，世间依然是那么变幻无测，在奈何一种无力之时，也会默默牵挂各自的远方亲人，也是那时，看到一朋友的签名上贴下这段话：</p>
<blockquote>
<p>我们每天都在准备，准备这个，准备那个，却从来没有准备过死亡。</p>
</blockquote>
<p>一阵遐想，起笔写了一段回复：</p>
<blockquote>
<p>其实我们一直都在努力并准备奔向着死亡，只不过是我们更多的是甚至是惘然关注死亡之前的如何更好的生，以至于有时忽略了死亡可以幽灵一般那么快的闪现到我们面前，甚至容不下最后哪怕一点点仅有的思考。</p>
</blockquote>
<p>有时候很难发现熟因熟果，我们是在演奏那生之未央歌，还是死之伤殇曲？亦不得知，唯一知道的是，我们已经怀揣着各自的时间胶带，坐上了那生命列车，却早已刹不住了。</p>
<p>在那悼念缅怀之中，也愿今心能够感受到我的同在与同感，时间教诲我们去珍视亲友，也让我们更加坚强的一路走来。</p>
<h1 id="物尽其用"><a href="#物尽其用" class="headerlink" title="物尽其用"></a>物尽其用</h1><p>九月初，一次偶然，在单位看到到一个鱼缸，养着一群小金鱼，很有些可爱，在细致观察各自的性格，神情时，不禁注意到地下鹅卵石地下吸附着一个死鱼，一动不动，黑黑而又干枯的身子，不禁为那些尚还畅欢游曳的金鱼们有些怅然，随即问道负责人：鱼缸里有条死鱼，怎么不清理掉？</p>
<p>经过负责人一阵说明，这才知道，那不是一条死鱼，而是特地放进去一条“清道夫”，清洗鱼缸壁随时可能积累起来的绿苔，养鱼的人只知道那条特殊而有些难看的鱼就是负责清理的，以至于不知道它的真名了。</p>
<p>回来后查了下，这种鱼的学名叫吸盘鱼或称吸石鱼、琵琶鱼，也就是常说的清道夫，这种鱼体格健壮，适应性强，易养，可与大型鱼混养。其经常吸绿苔，是鱼缸中的最好的清道夫。才意识到那条最为安静的鱼原来是如此的可爱。</p>
<p>还记得看过《岁月神偷》那种大大鱼缸中安详游曳的鱼儿，在水中大口大口的呼吸，鱼儿水中游，鸟儿蓝天遨，何时都不是我们的一个梦想。而再一次发现，存在即是合理，世间万物存在必然有它原由，稳态趋向，互补互利的一面。简单点就如同，我们期望看到美丽外形的鱼儿，也需要哪些兢兢业业的看似丑鱼儿作为后盾，有很多时候不能单纯从一个角度看待问题，人性的力量在人性之外，爱情的保证也不在爱情之中，换位思考看起蛮简单，但是能一直警觉的去把握体会到它则是一个睿智的人生学问，因为汝欲得知，必先知之。</p>
<h1 id="心诚化石"><a href="#心诚化石" class="headerlink" title="心诚化石"></a>心诚化石</h1><p>九月的教师节，在我的主动推动促使下，用心准备的礼物最终赢得老师内心的感动，以致于凌晨导师群发邮件给每一个人致谢，也很高兴导师感慨我们的礼物会珍藏一生。师兄们都表示一起从没有收到导师这么深情感谢，我想，那是因为他们也未曾真心相对而已。只是很有些遗憾差点都忘记了给父母表示祝贺，那也是父母共同的节日啊。</p>
<h1 id="秋语传奇"><a href="#秋语传奇" class="headerlink" title="秋语传奇"></a>秋语传奇</h1><p>九月北京已经是步入秋的绸缎里，秋风丝语般的佛沙着一切，一丝静谧，一丝幻影，弥漫一阵阵怒放之歌，娇艳不失稳重。</p>
<p>九月秋语的寄语：幸福就像身后影子，大踏步向前走，便会一直伴你而行，dream is not a suspicion，but a profound discover。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Web三层体系架构</title>
    <url>/2010/08/web-3-tires/</url>
    <content><![CDATA[<p>就像是OSI说提出的网络七层协议模型用来规范与界定开放性的通行系统互连参考模型。在现代Web服务开发时，如何构建灵活可伸缩，扩展的Web体系架构，人们概括总结出一个比较成熟的模型，那就是Web的层次体系架构。</p>
<a id="more"></a>
<h1 id="Web三层体系结构概念"><a href="#Web三层体系结构概念" class="headerlink" title="Web三层体系结构概念"></a>Web三层体系结构概念</h1><p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnqf4wa3j307t0a3wei.jpg" alt="3-tiers application"></p>
<p>上图中为通用Web 3-tiers application architecture，从上到下主要职责：</p>
<ul>
<li>Presentation Layer(表现层)：用于用户接口的展示，以及用业务层的类和对象来“驱动”这些接口，对应的有视图JSP，HTML，等等</li>
<li>Business Logic Layer(业务逻辑层)：用于访问数据层，从数据层取数据、修改数据以及删除数据，并将结果返回给表现层。</li>
<li>Data Access layer(数据访问层):改成封装对Data Souce的增添修改，对BLL层提供透明数据读写存储。</li>
</ul>
<p>基于层次体系的优缺点：</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>是的开发人员可以只关注整个结构中的其中某一层，当然这里是在铺设界定好了各层接口的前提下；</li>
<li>可以很容易的用新的实现来替换原有层次的实现，也就是各层间的服务透明性，层内部可以进行灵活的替换；</li>
<li>可以降低层与层之间的依赖；</li>
<li>有利于标准化，这里明确各层的职责范围，成为开发人员共同的背景语言，也利于各种技术接口的界定；</li>
<li>利于各层逻辑的复用，Web的开发将会针对之前的案例灵活的复用已有的单元。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成，本来是数据可以直接通过DataSource穿透到表现层，现在必须通过层次包装上下传递，牺牲了暂时的灵活性，实际上还是赢的了长远的灵活性。</li>
<li>有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码，这也是在设计时需要注意的，如何在早期的模型架构阶段考虑周全来避免。</li>
</ul>
<h2 id="层次架构通用规则"><a href="#层次架构通用规则" class="headerlink" title="层次架构通用规则"></a>层次架构通用规则</h2><ul>
<li>Presentation Layer只能作为一个数据展现, 最好不要包含任何BLL或DAO的处理过程</li>
<li>设计时最好先从BLL出发, 而不是PL出发. BLL层在API上应该实现所有Business Logic, 以面向对象的方式</li>
<li>DAL层最好能够最大化降低与Data Source 物理层的耦合，做到抽象程度上做到系统无关，以支持Data Source的环境更变与水平替换。</li>
<li>三层架构中，不管使用COM+(Enterprise Service), 还是Remoting, 还是WebService之类的远程对象技术, 不管部署的时候是不是真的分别部署到不同的服务器上, 最起码在设计的时候要做这样的考虑, 更远的, 还得考虑多台服务器通过负载均衡作集群。</li>
</ul>
<h1 id="三层体系结构的细致深入"><a href="#三层体系结构的细致深入" class="headerlink" title="三层体系结构的细致深入"></a>三层体系结构的细致深入</h1><p>作为一个对三层体系的细化考量，一种细致的规划架构方案如下：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnsexyksj30j60hv0tk.jpg" alt="3-tier application extension by vanjor"></p>
<p>这种是一种在实际应用中细化的架构模型</p>
<ul>
<li>配置初始化模块：对系统增加底层的配置初始化模块，所以上层的初始化，决策选择均可以通过底层配置来灵活更改，如日子的开启范围，数据库连接配置，数据库模式配置，以及模块的开启等等</li>
<li>Data Source部分：对数据物理存储包含很多方式，此处列举了DB与FS物理数据存储系统.</li>
<li>Data Access Layer: 部分依然是基于上层业务需求，对上层提供数据访问接口，屏蔽底层物理数据层细节</li>
<li>Business Logic Layer: 业务层着灵活的根据模块水平划分，最大化在层间垂直水平二维方向降低耦合度</li>
<li>Presentation Layer : 同样依据模块划分，建立在不用的BLL上</li>
<li>系统的依赖关系已经变成了一个树形链结构，层见依赖关系明确，便于切割开发与发布部署，比如，如果只想对用户发布View A模块，或者是单独测试View A模块，web服务打包ear，war等，可以有如下打包方式：</li>
</ul>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnszvvwxj30ja0i1ab0.jpg" alt="make a individual release"></p>
<p>通过依赖关系链，打包发布内容只包含所需要的模块，这样最大化达到灵活快捷，降低并检验系统内部的耦合度。</p>
<h1 id="Web三层体系与MVC的异同"><a href="#Web三层体系与MVC的异同" class="headerlink" title="Web三层体系与MVC的异同"></a>Web三层体系与MVC的异同</h1><p>同样是架构级别的，相同的地方在于他们都有一个表现层，但是他们不同的地方在于其他的两个层。</p>
<p>在三层架构中没有定义Controler的概念。这是我认为最不同的地方。而MVC也没有把业务的逻辑访问看成两个层，这是采用三层架构或MVC搭建程序最主要的区别。当然了。在三层中也提到了Model，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层”中典型的Model层是已实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。</p>
<p>MVC（模型Model-视图View-控制器Controller）是一种设计模式，我们可以用它来创建在域对象和UI表示层对象之间的区分。</p>
<p>总之在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或成为领域层）、表示层。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>三层体系结构：<a href="http://blog.chinaunix.net/u2/67893/showart_2040448.html" target="_blank" rel="noopener">http://blog.chinaunix.net/u2/67893/showart_2040448.html</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Webservice</tag>
      </tags>
  </entry>
  <entry>
    <title>Web2.0之Mashup初探</title>
    <url>/2010/08/web2-0-mashup/</url>
    <content><![CDATA[<p>当今信息社会里，信息数据作为一种比较核心价值所在，人们面对如此众多庞杂分散的信息数据时，信息组织与呈现方式并不能让人们满意，许多地方都需要进一步来细化挖掘与完善， 比如，如今纷繁的团购网雨后春笋似的诞生时，那些团购聚合网也就随之出现了，从而满足用户一站式浏览各个团购网的信息，这一方面是为用户提供一个便捷的信息整合检索服务。</p>
<a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnwlff7jj30lb0fgdi5.jpg" alt="基于纷纭的团购网站而生的团购聚合网"></p>
<p>另外的一种场景，城市的交通部门拥有路况监控设备与路况事实信息数据，每天会有各种显示街区道路的路况数据报表，但是由于人眼视觉原因，不可能很好的快速去理解消化这些条条框框里的数据，如果作为Web平台服务提供给大众的话，这些一大堆表格与查询控件所带来无疑是一种比较糟糕的用户体验度。</p>
<p>一种可能的方式是结合Web-GIS相关服务数据平台，将路况信息与Map-GIS系统进行糅合-Mashup，那么这个结合后的信息呈现方式更直观更快捷的为人们所理解和便于做出快速决策。下图为</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnwyh62kj30sg0f4jud.jpg" alt="搜狗北京城区实时交通流量"></p>
<h1 id="Mashup概念"><a href="#Mashup概念" class="headerlink" title="Mashup概念"></a>Mashup概念</h1><p>那么什么是Mashup，参考<a href="http://www.programmableweb.com/" target="_blank" rel="noopener">programmableweb</a>的定义：</p>
<blockquote>
<p>A web Mashup is a web page or application that combines data from two or more external online sources. The external sources are typically other web sites and their data may be obtained by the Mashup developer in various ways including, but not limited to: APIs, XML feeds, and screen-scraping.</p>
</blockquote>
<p>Mashup作为一种新型的基于 Web 的数据集成应用程序的统称，它们的流行萌芽于对交互式用户参与和集成第三方数据的类似于科学怪人方式的重视。使用萌芽一词是有一定原因的；Mashup Web 站点的特点就表现为它正在 Web 上扎根发芽，它们利用了从组织边界之外的数据源获取的内容和功能。</p>
<p>Mashup单词的起源：它源于流行音乐，Mashup 是从两首不同的歌曲（通常属于不同的流派）中混合演唱和乐器的音轨而构成的一首新歌。与那些 “bastard pop” 歌曲类似，Mashup 也是内容的一种不常见的创新组合（通常都源自于无关的数据源），这都是人工进行合成的（而不是通过计算机来合成的）。</p>
<p>个人认为Mashup实际上是属于概念范畴，是对各种数据，信息，系统，乃至服务的一种分析，关联，组合与重新展现的方案，而这个数据信息不在仅仅来自服务方，而已是WWW上所有能够获得到的数据与信息，包括众多的第三方服务。</p>
<h1 id="Mashup相关技术"><a href="#Mashup相关技术" class="headerlink" title="Mashup相关技术"></a>Mashup相关技术</h1><p>Mashup与服务整合，内容信息聚合具有类似的范畴，而Mashup不仅仅是对同类信息的整合，比如将不同RSS源信息糅合，可以是Google Map的Google Map APIFrame结合大众点评网对商家的点评信息Atom等跨技术跨领域范畴里的数据信息整合与服务。</p>
<p>Mashup作为一种概念来说，支撑它的技术牵扯到各个领域，作为Web2.0中的方方面面的技术都可以为之所用，不再只是Web服务编程REST/SOAP, XML/JSON,AJAX, RDF/URI organizeFlex, 数据缓存，语义分析等等。</p>
<p>另外对于核心的数据源处理，异构数据之间的抽取，清洗，分析，规整，聚类，重整都是Mashup涉及到的问题与技术，在之后的篇章中，我将会介绍分享自身的一些经验与思路。</p>
<h1 id="Mashup分类"><a href="#Mashup分类" class="headerlink" title="Mashup分类"></a>Mashup分类</h1><p>这里以目前应用范畴与Mashup信息分类来看，有以下一些：</p>
<h2 id="地图GIS与多媒体内容信息Mashup"><a href="#地图GIS与多媒体内容信息Mashup" class="headerlink" title="地图GIS与多媒体内容信息Mashup"></a>地图GIS与多媒体内容信息Mashup</h2><p>毫无疑问，Google在这个阶段的信息技术中，人们搜集大量有关事物和行为的数据，二者都常常具有位置注释信息。所有这些包含位置数据的不同数据集均可利用地图通过令人惊奇的图形化方式呈现出来。Mashup 蓬勃发展的一种主要动力就是 Google 公开了自己的 <a href="http://code.google.com/apis/maps/index.html" target="_blank" rel="noopener">Google Maps API</a>，打开了一道大门，让 Web 开发人员（包括爱好者、修补程序开发人员和其他一些人）可以在地图中包含所有类型的数据。</p>
<p>Google也充分在地图上整合的商家信息，大众评论，Picasa等用户上传的地理地貌图片信息这里Map已经成为其他相关信息的一种载体，甚至Google也充分发挥自己能动性，拍摄各国城市街景图像数据，通过A+B=C式的Mashup诞生各种各样新式的服务。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynrzwcnphj30sg0h5q4q.jpg" alt="Google map与图片，文字，评论等信息的Mashup"></p>
<h2 id="基于社交网络SNS等产生内容元数据抽取关联的Mashup"><a href="#基于社交网络SNS等产生内容元数据抽取关联的Mashup" class="headerlink" title="基于社交网络SNS等产生内容元数据抽取关联的Mashup"></a>基于社交网络SNS等产生内容元数据抽取关联的Mashup</h2><p>分析内容提供者所提交的图像文字音像资料，从中抽出大量相关的元数据（例如谁提供的，内容中关联主体，地点，时间，事件），SNS设计者充分利用这些抽取元数据重新组织管关联，显示一个个丰富社交网络图。如大家熟悉的人人网，在日志中提供关联他人的元数据的管理点，相册服务提供人像圈定关联他人。甚至是现在通用的新闻网站在新闻中通过照片匹配而将照片中的内容以文字的形式呈现出来，也是一种Mashup。</p>
<p>这一点其实Google的Picasa相册服务已经做得前沿探索了也很成熟，它可以从用户提供的相册按照所属主人，相册，分享范围，时间，拍照地图地点关联地图，图片自动人像识别关联Google Mail中的联系人等等将大量的用户信息自动关联识别到一起，为用户提供了更加人性智能化的使用体验。</p>
<h2 id="商业社会化服务Mashup"><a href="#商业社会化服务Mashup" class="headerlink" title="商业社会化服务Mashup"></a>商业社会化服务Mashup</h2><p>搜索和购物 整合在 Mashup 这个术语出现之前就已经存在很长时间了。在 Web API 出现之前，有相当多的购物站点与工具，就诞生了众多的针对购物的垂直搜索引擎，整合了各大购物网站的信息数据，而现在社会商业各个方面，只要能有目标用户的特定需求，像团购，求职，房屋，中介，二手，等等都会存在大量的Mashup，而之前的Mashup大多是不太完善的，是Mashup设计者通过第三方从信息源挖掘抽取数据，常见于运用信息抽取采集系统大量搜寻相关信系重新整理为规整元数据集并展现。</p>
<p>而如今，淘宝已经为其平台不断的开放第三封那个数据访问API接口平台与服务，这也会成为未来的一种发展趋势，百度的框计划，在搜索结果中直接聚合了图片信息，常用天气，计算结果，网站登录入口等服务也是广义上一种Mashup的思路。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyns2eha79j30s30fmmz2.jpg" alt="Google - shopping ，meta data mashup"></p>
<h2 id="基于新闻源分享的文本图像信息聚类Mashup"><a href="#基于新闻源分享的文本图像信息聚类Mashup" class="headerlink" title="基于新闻源分享的文本图像信息聚类Mashup"></a>基于新闻源分享的文本图像信息聚类Mashup</h2><p>例如纽约时报、BBC 或路透社 已从 2002 年起使用 RSS 和 Atom 之类的联合技术来发布各个主题的新闻提要。以联合技术为基础的 Mashup 可以聚集一名用户的提要，并将其通过 Web 呈现出来，创建个性化的报纸，从而满足读者独特的兴趣。Diggdot.us 正是这样的一个例子，它合并了 Digg.com、Slashdot.org 和 Del.icio.us 上与技术有关的内容，还有抓虾，Google阅读器等等。随着文本语义挖掘，图像音视频识别到等技术的成熟与实现，个性化信息内容服务也将越来越精准而人性化。</p>
<h1 id="Mashup相关"><a href="#Mashup相关" class="headerlink" title="Mashup相关"></a>Mashup相关</h1><p>有的文章以社会挑战，技术挑战等方面来说明，个人主要从以几个角度来探讨：</p>
<h2 id="健康性"><a href="#健康性" class="headerlink" title="健康性"></a>健康性</h2><p>既然Mashup是基于数据服务的一种三方的整合，任何人都可以发布自己的WebService服务接口等，在构建自己的Mashup服务中，如何确保开发人员需要面对类似源自于在异构数据集之间共享语义的挑战。如何确保这些异构数据源的完整性，正确性，避免过时的信息源，错误信息源，宕机暂不可用等等所带来负面影响。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>对于所发布这些大量的服务接口API，如何界定合适访问权限，以防止非法目的的收集，比如前些时针对有黑客针对Facebook系统通过网页采集或许多大几百万个公开资料的人的个人页面资料，以及如何防止数据源被污染，如植入人为干扰，广告信息，等等。对与敏感数据也可能要求一定的机密性（即加密），我们必须要清楚何时将它们与其他资源集成在一起，而不会带来风险。身份对于审计和法规遵从性来说也非常重要。另外，由于数据集成是在服务器和客户端同时发生的，因此从用户到 mashup 服务进行的身份和证书委托也可能会成为一个需要去注意是实现的问题。</p>
<h2 id="盈利模式"><a href="#盈利模式" class="headerlink" title="盈利模式"></a>盈利模式</h2><p>不能带来一种可持续盈利的模式的技术是难以长久的，在Mashup所赖以生成的三方数据服务接口提供者如何能通过自己所发布的服务获取盈利呢，目前的很多Mashup三方服务接口，平均每几秒就有一个诞生，大部分是基于免费的提供，这些服务质量和稳定上良莠不齐，难以转为收费模式而获取盈利，而Google通过其发布的Google Map Api吸引的不少的开发者，他的质量和稳定性收到大家的青睐，在一些第三方商业需求Google Map服务时，就需要想Google缴纳一定费用索取API key，这也是一个成功的模式，另外会有一些类似百度推广，植入广告等可以作为一种盈利模式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>IBM development works: <a href="http://www.ibm.com/developerworks/cn/xml/x-mashups.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/xml/x-mashups.html</a></li>
<li>查看最新的Mashup内容：<a href="http://www.programmableweb.com/mashups" target="_blank" rel="noopener">http://www.programmableweb.com/Mashups</a></li>
<li>SOAP/REST: <a href="http://www.ibm.com/developerworks/cn/webservices/0907_rest_soap/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/webservices/0907_rest_soap/</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Webservice</tag>
        <tag>Mashup</tag>
      </tags>
  </entry>
  <entry>
    <title>最佳实践-Java资源路径定位</title>
    <url>/2010/08/java-resources-locate/</url>
    <content><![CDATA[<p>Java编程中经常会涉及到其他文件资源对位查找，比如类反射，配置文件，数据文件读写，如何更准确灵活的定位好资源保证程序移植健壮性，也是一个值得关注的问题。</p>
<a id="more"></a>
<h1 id="Java资源标识符"><a href="#Java资源标识符" class="headerlink" title="Java资源标识符"></a>Java资源标识符</h1><p>关键词：<strong>URI、URL、URN</strong></p>
<ul>
<li>URI: Uniform Resource Identifier,(see RFC1630)，有两大子类型URL与URN</li>
<li>URL: Uniform Resource Locator,(see URC1738)</li>
<li>URN:Uniform Resource Name</li>
</ul>
<p>它们的Scheme都是[scheme:]scheme-specific-part</p>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>URI以scheme和冒号开头。Scheme用大写/小写字母开头，后面为空或者跟着更多的大写/小写字母、数字、加号、减号和点号。冒号把scheme与scheme-specific-part分开了，并且scheme-specific-part的语法和语义（意思）由URI的名字空间决定。</p>
<p>SAMPLE：</p>
<ul>
<li>绝对URI：<ul>
<li><a href="http://g.cn" target="_blank" rel="noopener">http://g.cn</a></li>
<li><a href="ftp://vanjor@vanjor.com:90/demo" target="_blank" rel="noopener">ftp://vanjor@vanjor.com:90/demo</a></li>
<li>mailto:<a href="mailto:vanjor@vanjor.org" target="_blank" rel="noopener">vanjor@vanjor.org</a></li>
</ul>
</li>
<li>相对URI：demo/a.doc （作为相对资源引用依赖于运行环境）</li>
</ul>
<p>API：</p>
<ul>
<li>URI(String arg); (return URI)</li>
<li>toURL(); (return URL)</li>
</ul>
<p>API中解析：</p>
<p>uri.getFragment()、uri.getHost()、uri.getPath()、uri.getPort()、uri.getQuery()、uri.getScheme()、uri.getSchemeSpecificPart()、uri.getUserInfo()、uri.isAbsolute()、uri.isOpaque();</p>
<p><a href="http://download.oracle.com/javase/1.4.2/docs/api/java/net/URI.html" target="_blank" rel="noopener">扩展阅读</a></p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。</p>
<p>API:</p>
<ul>
<li>URL(String arg);(return URL)</li>
<li>toURI;(return URI);</li>
</ul>
<p>API中初步分析：getAuthority()、getDefaultPort()、 getFile()、 getHost()、 getPath()、getPort()、getProtocol()、getQuery()、getRef()、getUserInfo()、getDefaultPort()</p>
<p><a href="http://www.jar114.com/jdk6/zh_CN/api/java/net/URL.html" target="_blank" rel="noopener">扩展阅读</a></p>
<h2 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h2><p>URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。</p>
<h1 id="Java中相对路径"><a href="#Java中相对路径" class="headerlink" title="Java中相对路径"></a>Java中相对路径</h1><p>Java中对资源定位是基于1中的统一资源定位符，主要有相对路径与绝对路径，其中相对路径是依赖于系统运行环境， 绝对路径：如</p>
<blockquote>
<p>File a = new File(“C://a.txt”);</p>
</blockquote>
<p>相对路径</p>
<blockquote>
<p>File b = new File(“a.txt”);System.getProperty(“user.dir”);</p>
</blockquote>
<p>user.dir为当前OS当前用户的默认目录</p>
<h2 id="几种java本地应用程序路径获取方式"><a href="#几种java本地应用程序路径获取方式" class="headerlink" title="几种java本地应用程序路径获取方式"></a>几种java本地应用程序路径获取方式</h2><p> <strong>Scenario</strong>：对应某个demo程序MyClass.java编译后的MyClass.class输出路径为</p>
<blockquote>
<p>“C://dev/demo/bin/org/vanjor/demo/MyClass.class”</p>
</blockquote>
<p>那么运用下述方法得到路径分别为：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Notes</th>
<th>Result for demo</th>
</tr>
</thead>
<tbody>
<tr>
<td>MyClass.class.getResource(“”)</td>
<td>获得当前类MyClass。class文件的URI目录，不包括class文件名</td>
<td>“file:/C:/dev/demo/bin/org/</td>
</tr>
<tr>
<td>vanjor/demo”</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MyClass.class.getResource(“/”)</td>
<td>得到当前classpath的绝对基准URI路径</td>
<td>“file:/C:/dev/demo/bin/”</td>
</tr>
<tr>
<td>Thread.currentThread().getContextClassLoader().getResource(“”)</td>
<td>通过java SDK中类得到当前classpath的绝对基准URI路径</td>
<td>“file:/C:/dev/demo/bin/”</td>
</tr>
<tr>
<td>MyClass.class.getClassLoader().getResource(“”)</td>
<td>得到当前classpath的绝对基准URI路径</td>
<td>“file:/C:/dev/demo/bin/”</td>
</tr>
<tr>
<td>ClassLoader.getSystemResource(“”)</td>
<td>通过java.lang.ClassLoader的静态方法，得到当前classpath的绝对基准URI路径</td>
<td>“file:/C:/dev/demo/bin/”</td>
</tr>
</tbody>
</table>
<p>推荐使用Thread.currentThread().getContextClassLoader().getResource(“”);来得到当前的classpath的绝对路径的URI表示法。对于在classpath路径外的资源定位，可以通过先获取classpath绝对路径路径，再运用../等方法解析路径外的资源的绝对位置。</p>
<h2 id="Web应用程序中资源的寻址"><a href="#Web应用程序中资源的寻址" class="headerlink" title="Web应用程序中资源的寻址"></a>Web应用程序中资源的寻址</h2><p>Web中运行环境可能有差异，在JavaSE程序中，我们一般使用classpath来作为存放资源的目的地。但是，在Web应用程序中，我们一般使用classpath外面的WEB-INF及其子目录作为资源文件的存放地。 Eclipse中Web中class输出环境默认配置为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classpathentry</span> <span class="attr">kind</span>=<span class="string">"output"</span> <span class="attr">path</span>=<span class="string">"WebRoot/WEB-INF/classes"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>而应用程序一般是相对src同级别有一个bin目录，配置为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classpathentry</span> <span class="attr">kind</span>=<span class="string">"output"</span> <span class="attr">path</span>=<span class="string">"bin"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Web中，通常可以用在Web应用程序中，我们一般通过ServletContext.getRealPath(“/“)方法得到Web应用程序的根目录的绝对路径。 但是在Junit测试中也会面临没有ServletContext所需Web容器环境的问题，这里依然可以通过ClassLoader类来获得路径。</p>
<p>参考</p>
<ul>
<li>URI，URL，URN详解：<a href="http://eastsun.javaeye.com/blog/37013" target="_blank" rel="noopener">http://eastsun.javaeye.com/blog/37013</a></li>
<li>Java路径解决方案：<a href="http://studyroom.ccut.edu.cn/article.php?articleid=8765&amp;pagenum=-1" target="_blank" rel="noopener">http://studyroom.ccut.edu.cn/article.php?articleid=8765</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>运用图式分析抽取业务逻辑</title>
    <url>/2010/08/swimlane-bl/</url>
    <content><![CDATA[<p>从最早的电话交换网络，人们打电话需要由接线员在机房负责搭建两段通话桥梁，传统的纯纸介质财务记账已渐渐演化为电子记账，纸介质的已更多是负责存根与报表打印。随同时代科技的进步，许多企业单位在进行自己的传统业务与时，还依赖于一种人工手动处理阶段，有些也在开始尝试运用电子信息化构建自己的自动化协助处理平台，以支持日趋扩大的规模，各种横向的业务扩展以及纵向的业务数据分析辅助决策。这种电子信息化的需求将依然保持旺盛发展。</p>
<a id="more"></a>
<p>在面向领域的商业解决方案中，这里侧重于面对企业信息化建设，一大重点在于理清领域业务逻辑，生命周期，与职权范围，其他的大致也都是存储，获取，更新，分析，展示几大部分的BS或CS结构，自身的一点体验是运用合理的流程图去明确话领域业务逻辑。</p>
<p>通常，面向那些围业务与数据的流程处理案例，如信用卡申请审批流程，一方面牵扯到用户角色Role的界定（确定权限与职责），另一方面牵着业务进行到的阶段（确定数据状况与Role的关联）。确定好了这二维交叉关系，基本可以初步勾勒业务处理逻辑了。</p>
<p>下图为一个实际案例中的状态图，其中圆形标识了在整个业务流程中的所处状态，而箭头及标识标明影响对应状态变迁的时间与说指向的下一状态。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnguyfdlj30iz0770sy.jpg" alt="State Logic Flow"></p>
<p>这种图展现在一种程式状态机，尽量从纷繁错杂的业务逻辑中抽取归纳出明确的状态，和变迁的时间，事实上这也是将现实中逻辑事务转交给机器解决的一重大关键之处，机器实际上是不能自动理解人的思维，机器为什么能够“智能”的解决一些问题，是因为已经把所有可变因素与程式给加载与程序内部。也就是说，理清业务逻辑也就是要明晰那些是变的，那些事不变的，消灭掉模菱两可的状态间一对多或多对多的关系，让我们集中注意力处理那些可变因素，做量化条理化，在业务开发中提供一个可达路径。</p>
<blockquote>
<p>状态图(Statechart Diagram)：是描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的时间做出反应的。通常我们创建一个UML状态图是为了以下的研究目的：研究类、角色、子系统、或组件的复杂行为。</p>
</blockquote>
<p>但是状态图中主要是反映业务状态上的这个维度变迁，另外一维度用户角色Role并没有展现出来，那么泳道图则是一个很好的表达方式了：</p>
<blockquote>
<p>泳道图：一种UML活动图，能够清晰体现出某个动作发生在哪个部门。</p>
<p>泳道流程图（Swimlane Flowcharts）是一种反映商业流程中人与人之间关系的特殊图表。</p>
</blockquote>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynnh80dgtj30t50bm756.jpg" alt="Swimlane Workflow-SUM "></p>
<p>上图是对一个部门的所有业务逻辑的一个聚合的全集分析，在纵坐标界定了用户角色与职责，横坐标界定了业务流程步骤，而内容取的各个状态会对应清晰的分布在Role与Step间，指尖的箭头与说明界定了触发事件与下一步状态，当然横纵坐标可以互换。</p>
<p>这一步在构建业务数据逻辑LDM(logic data model)也是具有指导与明确目的的作用。</p>
<p>但是在具体分析中，多个分支逻辑糅合在一起会有一定的干扰影响，通常，人如果能将目标集中放在一处，就做的更专一更优秀，同样看业务处理的结果不同，可以进行定性划分了几种枝干业务流程，也就是将Sum中的一团麻拆分为一个个更容易理解的Sub支线。如下图：</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynni23nnwj30t40bmwf6.jpg" alt="Swimlane Workflow-SUB for Approved (detail for download"></p>
<p>上图分支流程图，按照业务处理性质与结果，划分的一种大的子类- Approved，即被通过的案例，图中只画出了Approved说需要的各个状态与步骤。</p>
<p>如果理清了各种子流程，结合构建共识的LDM后，可以更好的指导按照水平或者垂直的层次进行协同开发了。 附：</p>
<ul>
<li><strong>泳道图DEMO</strong>：(draw by visio) <a href="https://asset.vanjor.com/documents/2010/swimlane-bl-vanjor-demo.doc" target="_blank" rel="noopener">下载</a></li>
<li><strong>MBA智库百科</strong>：(泳道图) <a href="http://wiki.mbalib.com/wiki/泳道流程图" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/泳道流程图</a></li>
<li><strong>UML状态图</strong>：<a href="http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html" target="_blank" rel="noopener">http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Diagram</tag>
      </tags>
  </entry>
  <entry>
    <title>荷马史诗 -《奥德赛》</title>
    <url>/2010/08/the-odyssey/</url>
    <content><![CDATA[<p>依然是记得是小时候暑假的一天无意中在CCTV6看到这部电影，记忆犹新，无论是天马行空的神话旅途还是机智而又坚定男人气概的Odyssey，破费周折估计都快有十年之后再次找到重温一下，依然是那么的经典。</p>
<a id="more"></a>
<p>电影的故事背景是源自古希腊《荷马史诗》，传说中是由古希腊盲诗人荷马创作的，包含两部长篇史诗篇章：《伊利亚特》和《奥德赛》，也是荷马依据民间传说口口相传而凭借他个人天赋加工而成。</p>
<p>《奥德赛》这部97年的电影，主要两大线是洛伊木马和归家记，其中最经典的木马之战，死神和冥王，还有水妖siren都表现的活灵活现生动，在那些对抗各种各样妖怪的剧情中，其中很多让我记忆深刻，有滔滔海浪而形的泼赛冬，巨人独眼食人如草的泼吕婓摩斯，调皮嬉笑而又款解人意救人于危难之中的风之神，盘旋于洞穴顶端吞噬不眨眼的多嘴兽，及海洋之中巨大的血腥的大口。只有有很多电影业以此有所有借鉴。</p>
<p>个人的感悟有两点：</p>
<h1 id="人定胜天，还是天助我也"><a href="#人定胜天，还是天助我也" class="headerlink" title="人定胜天，还是天助我也"></a>人定胜天，还是天助我也</h1><p>电影在开头里，Odyssey机智的运用木马计战胜特洛伊，结束长达年之久的鏖战，此时的Odyssey拥有一股成功的傲气与霸气，Odyssey激动壮志满怀的面向大海呐喊：</p>
<blockquote>
<p>“看到了吗，天之神，海之神，我征服了特洛伊，我奥德修斯，一个有血有肉，有头脑的人，我不需要你们，任何事情都能做到。”</p>
</blockquote>
<p>而此在泼赛冬海神看来是傲慢与挑衅的，这也引发了长达17年的海神诅咒与报复的归家之旅。为什么Odyssey在成功之时要这样呐喊呢，因为在开始接到盟友要征战的这个请求时，他不太想出来征战，儿子刚刚出生，而敌人特洛伊又是个顽固艰险，在大海上，他内心还是有很多担忧与顾虑，因此当雅典娜出现在他的旁边，他也坦露自己的心声，不理解雅典娜为什么要这样安排，而雅典娜的</p>
<blockquote>
<p>“你的使命就是打仗，成就伟业，让你的名字永世流传给你的子孙们，我知道你的骄傲，你的虚荣”</p>
</blockquote>
<p>也点到了Odyssey内心的英雄气概，而当他坚定信心，而内心期盼对雅典娜言道“只要你伴随着我，我什么都不怕”，而雅典娜已消失的无影无踪。那么在他七年凭借自身去奋战而胜利时，那种呐喊也是发自内心的，万事凭借自身就可做到，人定胜天，似乎这种心声或多或少都会有每个人的影子。</p>
<p>而似乎有时候人在大自然面前显得那么猖狂，原有的一种对比中，人应该是显得弱小渺茫的，然而又有些地方，人凭借自身的力量和智慧战胜了他人，改变和战胜自然中的一点，会显得有些飘飘然，认为自己才是大自然万物的主宰，因而有些随心所欲，为所欲为。</p>
<p>这样也是要受到大自然的惩罚的，今天的社会中，这一点一直都在上演。而Odyssey仅仅是道出心中的那点傲气，就因此受到代表神于大自然的海神泼赛冬的长达十七年的惩罚，Odyssey在历经归家旅途旅途在历经千险后，从当初的热血青年到现在已经是脸上已勾起了岁月的棱角，在船上，彻夜未眠，深沉的许多，面向茫茫大海，他感叹到:</p>
<blockquote>
<p>“法伊阿基亚人送我踏上伊萨卡的归途，但却是泼赛冬让我继续我的航程，再三思考他的话，我明白了，我只是世间的一个凡人，不应自大，不必自卑。”</p>
</blockquote>
<p>我想此时Odyssey明白体悟到了之前的那点狂妄，现在归依然还能生着在归途中，还是是要感激泼塞冬给予的这种磨难，Odyssey已经领悟到了，作为世间的一个凡人，面对大自然，不应自大，也不必自卑。而此时的他不在有那种人定胜天的自大，而是在成功之处充满一种“天助我也”的由衷感激，这正是一种内心平衡良好的态度，也是每一个人应该去努力恪求的。</p>
<h1 id="做一个控制得了自己情绪欲望而又睿智成熟的男人"><a href="#做一个控制得了自己情绪欲望而又睿智成熟的男人" class="headerlink" title="做一个控制得了自己情绪欲望而又睿智成熟的男人"></a>做一个控制得了自己情绪欲望而又睿智成熟的男人</h1><p>就在Odyssey海上磨练17年后即将归家之时，心中早已是如此的思念家人，思念妻子，但却无论外在内在表现的异常平静，为什么呢，通过雅典娜口中道出的他的内心：</p>
<blockquote>
<p>“那正是我爱你的原因 我的奥德修斯,换成其他人 这么多年以后,都会迫切地跑回家拥抱他的妻子和孩子,缺乏耐心和莽撞,只会让他们被入侵者劈成两半。”</p>
</blockquote>
<p>此时此刻Odyssey是那么的智慧与成熟，不在是当初简简单单的热血青年，此时此刻的他，了解到并担忧自己的王国即将落入他人的危机，同时更担忧坚守十七年的，面临那么多求婚者，自己的妻子珀涅罗珀依然是否忠诚于自己，心是否依然归属自己。千头万绪的他依然是那么的冷静而智慧的思考着，并告诫自己的儿子：</p>
<blockquote>
<p>“现在还不是争斗的时候,你必须知道 愤怒很简单,但找到罪魁祸首 在适当的时间,以适当的理由发怒 ,那才是英雄。”</p>
</blockquote>
<p>他压制住愤怒而有担心牵挂的心情，跟随儿子蛰伏而归，在阴暗中默默关注了解全局，掌握主动，在儿子被敌人挑衅，正要中敌人圈套准备参加械斗之时，他的那声苍茫而用力的颤抖的吼叫 <strong>“NO·····，To be anger is easy”</strong> ，那是一种一种卧薪尝胆的忍默，拯救的他的沉浸在愤怒之中的儿子，也展现出他那种非凡的个人气质与魅力。</p>
<p>最终，不是在愤怒和浮躁于世，而是默默中掌握全局消灭了敌人，重新夺回自己的王国，让自己和家人又团聚在一起，这是一个男人的智慧，勇敢，与自负。 当然也难忘其中Odyssey对妻子的不渝挂念</p>
<blockquote>
<p>“我宁愿像个男人躺在我妻子的怀里,即使是片刻时光 也不愿离开她而永生不老”</p>
</blockquote>
<p>附:</p>
<ul>
<li><strong>IMDB</strong>:  <a href="http://www.imdb.com/title/tt0118414/" target="_blank" rel="noopener">http://www.imdb.com/title/tt0118414/</a></li>
<li><strong>Mtime</strong>: <a href="http://www.mtime.com/movie/31293/" target="_blank" rel="noopener">http://www.mtime.com/movie/31293/</a></li>
<li><strong>Douban</strong>:<a href="http://movie.douban.com/subject/1407148/" target="_blank" rel="noopener">http://movie.douban.com/subject/1407148/</a></li>
<li><strong>VeryCD</strong>: 奥德赛(《The  Odyssey》下载地址)：<a href="http://www.verycd.com/topics/88326/" target="_blank" rel="noopener">http://www.verycd.com/topics/88326/</a></li>
</ul>
]]></content>
      <categories>
        <category>电影观感</category>
      </categories>
      <tags>
        <tag>Odyssey</tag>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>八月拾荒</title>
    <url>/2010/08/august-rainse-desolation/</url>
    <content><![CDATA[<p>莞尔已月中，姗姗来迟，不是未曾挂念，却是一直牵盼。</p>
<p>依然记得7月底重返安徽时，拖着疲惫的身体，坐在车里，听着这首拯救，凝视着窗外一闪即逝而又绵延不断的风景，完全陌生而又不相关的一片树木一片砖瓦，激荡不起脑海中任何记忆涟漪的景象，却居然能让劳累的身心得到一种前所未有的消畅。仿佛已不再是是世间人，超脱之外的来访，无牵无挂。才回想起一位朋友所写到的，害怕在一个陌生的城市留下太多回忆，会勾起心中无限的惆怅。如今愈发真切。</p>
<a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynn0h8xdkj30hs0az0sp.jpg" alt="venus-planet with forward"></p>
<p>然而的的确确，真真凿凿的牵挂着什么，让我一直能够艰境中守护着，待得住云开，解得了思愁。</p>
<p>毅然的八月初为随守望而来，虽身已疲惫，却心早已矫捷于燕。很少有这样莫名难以言语的感受，就像是得到一个无名的种子，虽不知是什么，却凭借内在的一个真诚去对待，不怀任何私心与居心，去守护着，却能够让人惊喜万分的开花结果，不是苦涩的，而是大气恬然的，莞尔激荡的莞尔静雅。那种纯粹容纳不了一点点世尘与杂色。就像一部电影中所语：追求卓越，成功就会在不经意间追上你。探求内心去交换，才能收获真心。重返江城，追寻那些难忘的，流连的，和不曾走过的，最重要是那个一直挂念的，倘若大半生任由视而不见而错过的，如今才撑开朦胧双眼，更是倍加珍惜。</p>
<p>仲夏的人们依然各自散去忙碌着，平日的喧嚣早已不再，留下的是深邃的星空与闹的寂知了。每天忙完事情后，总能留下一片真空的世界，静僻的内心，不再有何畏惧纷繁的干扰。乘着忙碌中难得的间隙，释怀的休憩，拂去搬迁的尘土，抹平起脚的书籍，安放起凉挂杆，抚整起片片杂杂碎碎。似乎又是在收拾心情，摊开脚下的杂草，点亮前方的路途。</p>
<p>八月拾荒，其实并非荒芜，因为早已持握而怀望绿洲，因而抚遍荒芜之地，播撒绿洲的种子，学会起守望，沉着而又坚定，激荡而又不失恬然。</p>
<p>阳光总在风雨在，守护了风雨雾雪，才更能祈望曦阳。无论是游走灯火辉煌的街头，还是静卧夜深人静的时候，都会拥有一份天涯共此时，共享苦味甜酸的守望。</p>
<p>八月拾荒的寄语: 那遥远的金星，你懂得的，不会让你错过每一分每一秒。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>七月辰星</title>
    <url>/2010/07/july-cancer/</url>
    <content><![CDATA[<p>.</p>
<pre><code>别离六月

七月寻踪

不见繁星

静谧至极

一种伤感

一声叹息

招之不来

挥之不去
</code></pre><a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynmxiw1t5j30rk0hcaaz.jpg" alt="july-cancer out of 12 asterism"></p>
<p>最大的习惯就是习惯那些不变，一旦打破，将荡起内在的紊乱，一种激变，却又能更好的深度思考，那些曾今的习惯是些什么？</p>
<p>苦恼于一种不确定性，会让人不安，无所适从。却又惧怕一种确定性，一种盖棺定论，一种循规蹈矩，一种命由天生的感觉。</p>
<p>莫名的敲出两行话，找不出由来，获取皆游离态而生。</p>
<p>犹如大雪中行走，积雪覆膝，赶路中不免要回望来时之印，当一意行走过深，恍然回首，忽然找不到来时的脚印，便不会记起是如何一路走来，陷于积雪之中，何去何从。</p>
<p>纷呈繁杂的社会，风云转向的标杆，铺天盖地的信息冲撞，外壳安稳和谐的社会骨子里涌动着一股躁动与不安，若无内心的一种坚守，则很容易被随波逐流一波带走抑或被弄得得晕头转向。</p>
<p>理想很丰满，现实很骨感，站的太高，摔得会很惨，唯独勤奋而笨拙的搭台阶反而有可能触摸天边的月亮。</p>
<p>跳动的思想，压抑不住的惆怅，找不回的自我。</p>
<p>七月初晓，酷热难耐，纷呈盛夏，悄然静谧，看不清的纷繁的周遭，莞尔轮廓骤显。</p>
<p>恍然发现曾遗漏一种纵向串联分析思考，当目光停留在当前，便难得发现前因后果，更加欣赏人性美，即便是弱点-那些纷繁的弱点，倘若予以理解，那也是一种内在焕发的悲剧美。超越不了的一种自我局限性，却是做出的最大的挣扎，犹像项羽，至今思项羽，不肯过江东。</p>
<p>其实一切又似乎可以很简单，不必太多的重复，无绪的思考。</p>
<p>比如， 七月辰星的寄语：炯炯有神，欣欣向荣</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>《颐和园》</title>
    <url>/2010/06/summer-palace/</url>
    <content><![CDATA[<p>周末放纵一回，晚睡写写东西，让《颐和园》的原声曲循环响起在脑海里，低沉的而又节奏的拍子中，清脆的婉转钢琴声，揪人心结的弦指尖，思绪飘逸着，随着那每一阵节拍，每一个音符。 娄烨导演的《颐和园》已经紧紧被“被禁”、“政治”、“性”、”八·九学潮“绑连起来，但静心而欣赏，或许能够感受到阵阵难以言说的，莫名的怅然。</p>
<a id="more"></a>
<blockquote>
<p>“有一种东西，它会在某个夏天的夜晚象风一样突然袭来，让你措不及防，无法安宁，与你形硬相随，挥之不去，我不知道那是什么，只能称它为爱情。” —-余红日记</p>
</blockquote>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynmpexkj4j30dw097aab.jpg" alt="余红-剧照"></p>
<blockquote>
<p>为了欲望和浪漫的天性，我的确付出了代价，但是生活再艰难，我也不会失去活下去的勇气。</p>
</blockquote>
<p>主人公余红的日记的开篇，似乎就已奠定基调，在一种飘忽不定，言语不清的文字中，抹上一股沧桑，沉重基调。</p>
<p>对于爱情，余红看似大胆而主动，周伟犹豫未决。余红是爱情的信徒，但周伟不是，甚至对余红”疯狂行为“所不理解。只有分别之后，彼此才有清晰的觉察。暮色，黄昏，大风，黑发飘忽，余红说，她只是想活着更强烈一些。周伟、李缇去了德国柏林，余红去了深圳，然后去了武汉，对他们来说，</p>
<blockquote>
<p>记忆是汹涌而来又汹涌而去的大水，淹没了一切。爱情会变，人会变，不变的是日起日落。太过理想和任性，一般活得很落寞，如同写作的人，那是注定的一种孤寂，即使有过灿烂，但烟花过后，空无一人。 人的生活，总有自己无法掌控的东西。余红是那样的强烈和自我，注定她留下的只是烟火的痕迹。我们太多的人，在曾经，都做过无处诉说的事，但那是自己，真实的自己，确确凿凿。</p>
</blockquote>
<p>仍然有些难以理解余红、李缇、周伟、若谷之间纠结的关系，无法感受到他们之间的个人行为，但或许能够从他们冲动，彷徨，沉思中能启示点什么。</p>
<p>欣赏李缇，那种悉心，那种成熟，那种执着，但最终是悲剧性的结尾，她无法活着自我救赎，或许她无法把握好他人，抑或内心是在坚守着什么，让人看不透，在柏林楼上，微笑的坐在墙沿，<strong>那种诡异的让人不安，惶恐的微笑，是那么灿烂，又是那么凄凉；是那么充满希望，又是那么决绝</strong>。翻身仰面而跳的她，跟随这飞过的洁白的鸽子，在让人眩晕的呼噜噜噜声里，独自伤神，许久许久，那一种残缺的美，伤殇，久久难以忘怀之美。</p>
<p>难以言语的余红，那二十多年的前半生。余红是黑夜的女儿，她的<strong>大胆，细腻，脆弱，狂躁，痴情，还有无力，让人一时无法摆脱</strong>。那是一种凌乱的美，一种齐放的美，美得那么突兀，美得那么诡异。</p>
<p>时过境迁，十多年过去了，周伟和余虹又次相遇，他们再也迸发不出激情的火花。或许每个人都有几段刻骨铭心的际遇，物是人非事事休，虽然能抱在一起，但吻起来却不再甜蜜。从初恋的小军到后来的吴刚，一直身怀心事的余虹从来都是敢作敢为，可这次面对旧日的最爱，她却犹豫了。没有经历过那种场面的人很难参透这种感觉，当你和她相对无言泪千行，明知回到从前不过是又重复一番又一番的苦痛，脚步沉甸之下，有几人能说解脱?</p>
<blockquote>
<p>要不要?做不做?是我们人类一直在思考的话题，我们拘泥于形式，受观念的摆布，世俗眼光的控制，我们从来不敢提这些疑问句，因为我们内心都遭禁锢，我们都在乎那个戒律，那三个字是：“敢不敢?”</p>
</blockquote>
<p>同时感叹人都是处于一个特定历史时代，无法脱离，甚至于当抛开的所在背景，他将成为空壳，同时也十分赞许娄烨导演的一番话：</p>
<blockquote>
<p>打个比方，你在一部电影中用四分钟时间展现了一个人物的面孔，但是在这四分钟之外，这个人从哪里来，到哪里去，她会怎么行事，他想什么，这些并不是在这四分钟里形成的，而是四分钟之外一个更大范畴、时空之间的事情。于是你要跟踪她，到四分钟之外的地方去。我的主人公也是这么形成的。某个更大范畴那是她生活成长的一个重要阶段，是她的某些出发点，这就不能回避了。从她的性格来说，她对于性爱是直接的，那么，她对于其他现实也是直接的和不回避的。</p>
</blockquote>
<p>然而个人与时代又是经常交织的，当个人揉入时光长河，在那段长长的走廊里，我们都拥有属于自己的一段，而当回翻起来，又能找到什么，想到什么？在《颐和园》里：</p>
<blockquote>
<p>从广场，到89年秋季学军运动。1989，柏林。1991，莫斯科。1992，深圳。1997，香港。历史被人们提起的时候，不如象余红与周伟重逢的那样，上车，无言；上酒，无言；上床，无言。</p>
</blockquote>
<p>对于其中的八·九学潮，之前也看过香港的纪录片，十分触动，能够感受到那个时代政府的无奈和坚守最后的原则，学生的热血沸腾，而又充满着盲目，冲动，与不安分的躁动，那是一个时代的躁动，而那个时代是一种显示的躁动，如今我们又身处在各种隐式躁动的暗流中，独善其身还是随波逐流？ 娄烨导演这样评论：</p>
<blockquote>
<p>我们是站在个人的角度。从个人角度去对待这种历史事件。这不单单是对于当时爆发的事件而言，事后来说也是这样。89年之后，中国实际用了一年就解决了，就回到秩序了。表面的秩序混乱是容易回到秩序的，内在的、内心中的东西是不容易回去的。这就是个人角度。我们关注的就是这个。内在秩序的混乱的恢复是需要时间的，它需要很长时间才能趋于平静。这个是个人角度，不是一个社会角度。</p>
<p>一旦你尝到了自由的那种尺度，那很可能你就很难回去。这是整个九十年代所面临的一个困惑。就是说这从广场上回来的这批人他曾经一度超越了一种控制，然后你又让他们回到控制，这是非常困难的。对于社会来说，恢复秩序和常态是困难的，对于每个人的内在也许是更困难的。那实际上是太困难了。谁来管这些？当时秩序恢复以后谁来管人的内在变化？这是没有人负责的。</p>
</blockquote>
<p>崔未平也曾针对性谈到：</p>
<blockquote>
<p>这是一个非常经典的话题，就是自由过后怎么样？高潮过后怎么样？最早是鲁迅提出“娜拉走后怎么样”，临时冲动迈出脚步离开家门非常是容易的，但是承担自由所带来的各种各样的结果，尤其是灰暗的结果，就不轻松了。你说得非常有意思，经历过自由的人怎么再回到那个看起来正常的轨道？他释放过那样的能量后，他被外在的或者自己体内的巨大能量灼伤也好，之后他怎么生活下去？</p>
</blockquote>
<p>我们很多时候看电影，并没有特别的目的，那是别人的一生，那是别人的故事。我们无权去说，也无权去批判，但我们可以叹息，可以觉得遗憾，以及以此带来对自身的观照和比划。人会苍老，会无声地逝去，告别无处安放的青春和无处安放的肉体。抒情的电影，可以颓废，可以混乱，可以反复，但一定要精致，包括精致的人和精致的画面。 同样让人难以言语，耐人思绪的对白：</p>
<blockquote>
<p>“我要跟你分手”</p>
<p>“为什么”</p>
<p>“因为我离不开你”</p>
</blockquote>
<p>以及那感性而温雅的内心独白：</p>
<blockquote>
<p>这不是最不幸的事.最不幸的.是我知道这种事以后还会在我身上发生.我诅咒我自己.愚蠢.茫然.心里总是出现这样的幻觉.在我这样如饥似渴.急不可待地.想见到他的时刻.其实我已经跑过了头.我以为你在远处.而你.静静地从旁边.抓住了我的手。</p>
</blockquote>
<p>按影片结尾，谨以结束此文 -- 李缇碑墓上未署名留言</p>
<blockquote>
<p>无论自由相爱与否，人人死而平等，希望死亡不是你的终结，憧憬光明，就不会惧怕黑暗。</p>
</blockquote>
<p>附1：参考扩展</p>
<ul>
<li>关于《颐和园》：崔卫平访谈娄烨、梅峰：<a href="http://group.mtime.com/quote/discussion/149946/" target="_blank" rel="noopener">http://group.mtime.com/quote/discussion/149946/</a></li>
<li>电影资源：<a href="http://www.waynecn.com/2008/03/21/276.html" target="_blank" rel="noopener">http://www.waynecn.com/2008/03/21/276.html</a></li>
<li>台词：<a href="http://www.douban.com/group/topic/3581014/" target="_blank" rel="noopener">http://www.douban.com/group/topic/3581014/</a></li>
<li>豆瓣:<a href="http://www.douban.com/group/topic/2769234/" target="_blank" rel="noopener">http://www.douban.com/group/topic/2769234/</a></li>
<li>红豆：<a href="http://hongdou.gxnews.com.cn/printthread.php?t=4642741" target="_blank" rel="noopener">http://hongdou.gxnews.com.cn/printthread.php?t=4642741</a></li>
</ul>
<p>附2：影片下载地址</p>
<ul>
<li><a href="ed2k://%7Cfile%7C%5B%E9%A2%90%E5%92%8C%E5%9B%AD%5D.Summer.Palace.2006.DVDRip.XviD-MOC-cd1.avi%7C733126656%7C0bac6a286ba32fe6d0f23522c9c1f965%7Ch=UJKKGX7KVPMGBU5F2F76NTRCLZRVKLHE%7C/" target="_blank" rel="noopener">[颐和园].Summer.Palace.2006.DVDRip.XviD-MOC-cd1.avi</a></li>
<li><a href="ed2k://%7Cfile%7C%5B%E9%A2%90%E5%92%8C%E5%9B%AD%5D.Summer.Palace.2006.DVDRip.XviD-MOC-cd2.avi%7C733804544%7Cd7b4b8fdb28e2c36a21d4cf8967f0123%7Ch=YRHSQISNH7GH3QZMMUYWBWZCSRBWRKIY%7C/" target="_blank" rel="noopener">[颐和园].Summer.Palace.2006.DVDRip.XviD-MOC-cd2.avi</a></li>
<li><a href="ed2k://%7Cfile%7C%5B%E9%A2%90%E5%92%8C%E5%9B%AD%5D.Summer.Palace.2006.DVDRip.XviD-MOC-subs.rar%7C2017438%7C66a3f4addd66267a89fdeca366d2b6b4%7Ch=ZFXDRUSRW2AI5VHLSL4MUKHSDS3G4KW3%7C/" target="_blank" rel="noopener">[颐和园].Summer.Palace.2006.DVDRip.XviD-MOC-subs.rar</a></li>
</ul>
<p>附3: 相关影视</p>
<ul>
<li>娄烨电影：《苏州河》</li>
<li>沈严导演电视剧：《我们无处安放的青春》</li>
</ul>
]]></content>
      <categories>
        <category>电影观感</category>
      </categories>
      <tags>
        <tag>Summer Palace</tag>
        <tag>Lou Ye</tag>
      </tags>
  </entry>
  <entry>
    <title>初到淮北</title>
    <url>/2010/06/essay-at-huaibei/</url>
    <content><![CDATA[<p>又一次有机会可以出来走走，而这次是安徽，虽然小时候曾去上海路过安徽，但是这次是真正的要停驻安徽几天。清晨抵达酒店，查完邮件，看完文章，突发的冲动，想写点什么。</p>
<a id="more"></a>
<p>来时火车上，感受到许些惬意，这次终于没有碰到带着孩子出行的邻居，显得颇为宁静，期间路过曾经去过的天津，再一次看到海河，与之上的绚丽吊桥，在济南停驻少许，特地下车走了两下，也算是到济南一走了，忍住了给在济南的朋友一份“到此一游”的短信，看着一片黝黑的站台之外那明亮的塔楼，似乎想嗅寻着老舍笔下的那份济南的气息与味道。一番整理后随性躺在床上，抱着刚买来的《算法导论》看了起来，对床的一位同龄人也在安详看书，相映之下感觉仿佛置身于图书馆。喜欢旅行，喜欢沉醉在通往目的地旅逼近目标的那种感觉中，在那种伴随着轻微摇曳中，听着轮子，铁轨交接节奏感中，在那怀揣着一丝不安分里却又恬然安逸的时光里，尽情享受着，读书，听音乐。</p>
<p>当凌晨到站时，对床的同龄人还在安睡中，相信是在一个甜美的梦想里，而我们已经结结束旅途，一如既往的车站前是宽阔的广场，不一样的是回望车站上所竖二字却是陌生而充满新鲜感，夹带着一丝兴奋，那种感觉就像是数年来一直是那种千里之外薄着雾纱的朦胧美，而今将置身其中，终于要亲手掀起她的盖头。</p>
<p>下车后在麦记喝了杯奶茶，同行之伴说，他下车就感觉到了那种湿润的空气，不同于北方的干燥，而我却丝毫豪没有察觉，是因为这相对南方的气息就是家的气息么？即使多年在外，纵使早已适应了外面那迥异的气候坏境，归来之后仍然感觉到的是那份温馨的气息。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>六月童境</title>
    <url>/2010/06/june/</url>
    <content><![CDATA[<p>渐渐淡出了May，一个May every dreams possible的月份，鲜花也在伏瓣积蓄以酝酿来时之秋了。六月已经是年中，June，July恰在一年的中间，前后挨不着，心若无些期盼，则容易变得彷徨，而这六一儿童节的开端似乎纷纷唤起了大家沉睡的孩童时代，对于那些儿童来说，6月开启了童年一个最欢快的阶段-期待那梦幻的暑期，而以长大的我们显然不能太多祈求什么，更多可能是在自身人生计划下做好了各自安排，但是是否那排了一个小假期呢，不用太长，但确能像《菊次郎的夏天》那样梦幻，令人难忘。以此期盼做为一种积极前行的动力呢。</p>
<a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynll6b7irj30go0c1jsl.jpg" alt="童趣生活 - 源"></p>
<p>回望五月，领悟到看起来遥远的事情，其实做起来就不会那么远了。每天繁杂中都几乎会花将近1+小时的时间阅读Reader上订阅的海量文章，五谷杂粮，久之而陈。在左岸<a href="http://www.zreading.cn/archives/1616.html" target="_blank" rel="noopener">《从拖延者到行动派的10个秘诀》</a>中恍然更加明白终日忙忙碌碌其实需要自我反省，是否在被2/8法则所窒息，是否在懈怠自己，拿无限的理由借口和琐事在填充挤压有限的时间，是否总是在放过自己，将当前事务的时间快不断的后拖。让自己在看似自我掌控中却无法揣息和丧失自由。</p>
<blockquote>
<p>在心理学角度上讲，拖延的很大一个来源是“恐惧”。人们因为恐惧失败，害怕自己不能成功，所以会无意识地把失败拖到“明天”。或许明天、下星 期或是下个月，事情就会有转机，或许那时候一切都会不同，自己就会如有神助般地把所有的事情都做好。当然，他们也很想发挥自己的才能，但他们却害怕自己在 真正操作时根本做不到。<br>此外，拖延的另一个来源是“完美主义”。那些渴望完美的人拒绝失败，甚至拒绝瑕疵。但他们无法把未知的事情做得更 好，所以他们会直到最后一分钟才开始大张旗鼓地工作。“时间不够了”，是他们所能想到最放松自己的借口。它意味着：在这么短的时间内，这是我能够做到的最好成果了。</p>
</blockquote>
<p>也同时有幸通过<a href="http://blog.sina.com.cn/liuxuanwalking" target="_blank" rel="noopener">青遥</a>的文章中看到<a href="http://www.zreading.cn/archives/1791.html" target="_blank" rel="noopener">《优雅地表达你的欲求》</a>一文，文章一开端就提出了生活中急需要把握好的一点：</p>
<blockquote>
<p>为什么本来希望事件好好的，说着说着便吵起来，甚至大打出手呢？很多情况是因为人们的表达方式出了偏差，而只有善于表达的人才能化解矛盾，产生良好的沟通。</p>
</blockquote>
<p>沟通是一门深奥的哲学，越加注重它，就越能享受其中的乐趣，否则就会因为无法掌控自我，而以一种极端方式来表达，沟通是一种自我诉求。 同时，</p>
<blockquote>
<p>每个人的人心恰如一张太极图，有黑有白，而且黑白分量相当。只是，我们意识上常常会判定某一方面的内容为“好”，而判定另一方面的内容为 “坏”，然后意识上执著于“好”，但“坏”并未消失，它只是被压抑到潜意识中而已。</p>
</blockquote>
<p>这句话也唤醒了一种沉睡的自我认知，就像从小看电视的时候，会焦急的询问大人们电视中的人物是好人还是坏人，虽然现在不再那样幼稚，能以辩证观点看待事物，能够分析人物内心性格的复杂性。但是却似乎忽视了对自身的评判，或者说一种辩证思维。上周有机会和一位朋友谈天，朋友谈到，觉得有时候真是长大了，因为曾今的，小时候的极端或者是偏执的想法，我一定会什么什么的，我一定不要什么什么的，最后突然有了一种新的看法，或者是几乎相反的看法，发现原来并不是那样，相反的一面也欣然接受了。月亮向着太阳一面与背对太阳一面温差可达300度，但却轮流交替并存丝毫不相互影响。</p>
<p>六月，是童境的一月，不因成长而殇叹此去经年，岁月会磨去外表的菱角，但依然需要珍藏那份淳朴的心，现代人有时生活在过多的无边无际幻想与期望的痛苦中，并且会有所怀记琐事与计较得失，不像小孩哭闹之后边痛快的忘怀，少了许多直率，身藏在各式面具下生活。童时却能在十分有限的环境与权责下充分享受时光，而那成长的压力还应是借口么？</p>
<p>六月童境的寄语：坦然心态，那每天起床的闹钟，不是定在钟上，而是刻在心里。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily life using Google&#39;s</title>
    <url>/2010/06/daily-life-using-googles/</url>
    <content><![CDATA[<p>搞IT的基本每天都要趴在PC前，需要将电脑驯化为我们舒适实用的工具，分享下自己的基于Google全站式服务www daily life style 套餐：<br><strong>Gmail</strong> + <strong>Reader</strong> + <strong>Gtalk</strong> + <strong>Calendar</strong> + <strong>Chrome</strong>  </p>
<a id="more"></a>
<h1 id="邮件-Gmail"><a href="#邮件-Gmail" class="headerlink" title="邮件-Gmail"></a>邮件-Gmail</h1><p>早上起来，睁开朦胧双眼，新的一天开始了，打开电脑，第一件事情当然是check邮箱了，随着开机自动启动的Gtalk会检查是否有新邮件</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynl7pp72qj308e03wglw.jpg" alt="Gtalk check mail in time for Gmail"></p>
<p>配套Google日历，每天定时收到当天的行程安排与提醒，如同贴身秘书</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynl65sp34j30hl0famxi.jpg" alt="每天在Google日历上的安排提醒会在早上发到"></p>
<p>内置Buzz，让查看邮件时，也能动态及时的看到朋友动态和分享，并可基于评论相互交换意见</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynl8jnwvvj30pd0ehgp9.jpg" alt="Buzz in Gmail connect with Friends"></p>
<p>Tips:</p>
<ul>
<li>在Gmail里面设置随机背景，每一次打开邮箱，都会是不一样的风景。</li>
<li>将Gmail设置主账户，接收几个其他邮箱账户，一个邮箱基本可以掌管一切</li>
<li>配置秘密转发邮箱，所有接受到的邮件都会秘密转发到自己另一个不公开的邮箱账户上，方式误删，安全后盾，一切有备可查。</li>
</ul>
<h1 id="早读-Google-Reader"><a href="#早读-Google-Reader" class="headerlink" title="早读-Google Reader"></a>早读-Google Reader</h1><p>处理完了邮件后自然得放松一下，俗话说新闻早知道，还不赶紧看看晚上睡大觉的时候，世界都发生了什么吧。不用一个个打开门户站点，可以在Google Reader中一站收看所定制的个性化新闻-最新的新闻，业界动态和社论。</p>
<p>当看到什么文章值得写下自己的思考或问题时，随时标记下来吧。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynld3hy9fj30j908ftah.jpg" alt="Google reader内置的笔记本"></p>
<p>查看朋友的分享和动态</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynldjd3qcj30j908qgon.jpg" alt="Connect to Friends"></p>
<p>Tips about Google Reader的信息类别</p>
<ul>
<li><strong>Starred items:</strong> 加星号的文章，Reader中好文随时随地加星号，做标记，不共享</li>
<li><strong>Shared items:</strong> 共享信息，可以通过每篇文章的share按钮随时随地分享趣文，可以设计share级别，只朋友见，全球可见</li>
<li><strong>Notes:</strong> 笔记，可以标注文章的特定信息，和自己的新的保存到改类别下，另一最大用途是在通过浏览器查看任意网页时，都可以将对应网页保存note类别，做到比浏览器书签更持久化存储</li>
<li><strong>people you follow:</strong> 关注的朋友分享的文章和最新动态</li>
</ul>
<h1 id="沟通-Gtalk"><a href="#沟通-Gtalk" class="headerlink" title="沟通-Gtalk"></a>沟通-Gtalk</h1><p>接下来可以开始淡定的工作了，打开IDE，浏览器查资料时，还有个重点就是与fellow沟通了</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynleogvdnj304v09hjsj.jpg" alt="Gtalk主界面简约明朗"></p>
<p>Gtalk界面处处简洁明了，信息突出，没有多余视觉干扰。多聊天窗口自动停靠，随意分拆，随意悬浮</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynlf115pwj308m080wfg.jpg" alt="Gtalk聊天界面"></p>
<p>Tips</p>
<ul>
<li>Gtalk 不仅支持传统的文件&amp;文件夹传送，语音聊天，还具有特色语音信箱，聊天语音记录自动保存到邮箱中，随时备忘。同时还可以与Google voice绑定，实现自动转呼。</li>
<li>Gtalk还有对应的一个lab实验室版本，可以实现群组聊天，<a href="http://www.google.com/talk/labsedition/index.html" target="_blank" rel="noopener">详见</a></li>
</ul>
<h1 id="安排-amp-提醒-Google-Calender"><a href="#安排-amp-提醒-Google-Calender" class="headerlink" title="安排&amp;提醒 - Google Calender"></a>安排&amp;提醒 - Google Calender</h1><p>相当实用的Calender可以作为计划安排，任务提醒，日期查询等等种种功能。与他人分享日历计划。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynlg5w26tj30he0bc449.jpg" alt="随时记录计划，安排，查看提醒"></p>
<p>Tips</p>
<ul>
<li>可以在other calendars中添加其他第三方的日历，可以是其他人共享的日历，也可以是系统提供的中国或国际节日，每天日出日落时间，周数，Gmail中联系人的生日提醒日历等等。</li>
<li>与他人分享日历，可以让双方随时了解相互动态，而不必是事事轻口通告，同时可以相互协调时间，在团队开发中，可以采用Calendar辅助团队进展计划掌控。</li>
<li>重要事件计划可以设置为三种提醒方式，短信，邮件，弹窗提醒，其中短信最值得一提，可以自定义设置提前任意时间以短信的方式通知自己，好记性不如烂笔头，不用因为焦头烂额忙碌中忘记其他的重要事情。</li>
</ul>
<h1 id="冲浪-chrome"><a href="#冲浪-chrome" class="headerlink" title="冲浪-chrome"></a>冲浪-chrome</h1><p>上网冲浪离不开浏览器，chrome也是核心，用Google的chrome可以极大提高前几个web服务的用户体验度。</p>
<p>Tips</p>
<ul>
<li>chrome书签可以通过Google账户实现同步，数据保存在Google doc中。</li>
<li>通过chrome创建本地快捷程序，可以将网页服务创建为本地的一种应用服务，并发送到桌面一个图标，这样也就实现了一键直接进入邮箱，不必输入网址和认证信息。</li>
<li>Gmail，等服务有离线模式，可以通过启用这些加速Gmail的历史查看和运行速度。</li>
<li>S一点通，当访问Google这些服务有障碍时，可以尝试改http为https访问方式。</li>
<li>Google这些服务均有对应的快捷键，熟悉基本的快捷键，可以大大提高使用效率。</li>
</ul>
<h1 id="Google产品快捷键大全"><a href="#Google产品快捷键大全" class="headerlink" title="Google产品快捷键大全"></a>Google产品快捷键大全</h1><ul>
<li><strong>Gmail</strong>: <a href="http://mail.google.com/support/bin/answer.py?answer=6594" target="_blank" rel="noopener">http://mail.google.com/support/bin/answer.py?answer=6594</a></li>
<li><strong>Reader</strong>: <a href="http://www.google.com/support/reader/bin/answer.py?hl=cn&amp;answer=69973" target="_blank" rel="noopener">http://www.google.com/support/reader/bin/answer.py?hl=cn&amp;answer=69973</a></li>
<li><strong>Calendar</strong>: <a href="http://www.google.com/support/calendar/bin/answer.py?hl=cn&amp;answer=37034" target="_blank" rel="noopener">http://www.google.com/support/calendar/bin/answer.py?hl=cn&amp;answer=37034</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Some basic details in Java</title>
    <url>/2010/06/some-basic-details-in-java/</url>
    <content><![CDATA[<p>乘着微风徐来总结思考最近做的题目中关于java的的一些细节,也是笔试中java基础考核点</p>
<a id="more"></a>
<h1 id="java访问权限"><a href="#java访问权限" class="headerlink" title="java访问权限"></a>java访问权限</h1><p>Java 类访问权限修饰符表</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类(Self)</th>
<th>同一个包(packages)</th>
<th>不同包的子类(subclass)</th>
<th>不同包的非子类(project or world)</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>default</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>protected</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>public</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<ul>
<li>default又称无修饰符访问权限 或 friendly</li>
<li>访问权限修饰符权限从高到低排列是public ,protected ,friendly, private。</li>
</ul>
<p>类所具有访问修饰符表</p>
<table>
<thead>
<tr>
<th>类</th>
<th>访问修饰符</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>外部类</td>
<td>单独类</td>
<td>public,default,abstract,final (final,abstract 不能并存)</td>
<td></td>
</tr>
<tr>
<td>内部类</td>
<td>普通内部类</td>
<td>四种权限修饰符，final,abstract,static(即成为嵌套类)</td>
<td></td>
</tr>
<tr>
<td>内部类</td>
<td>匿名内部类</td>
<td>无修饰符</td>
<td></td>
</tr>
<tr>
<td>内部类</td>
<td>嵌套类</td>
<td>必含有static修饰符，可另有四种权限修饰符,final,abstract</td>
<td></td>
</tr>
<tr>
<td>内部类</td>
<td>局部内部类</td>
<td>final,abstract</td>
</tr>
</tbody>
</table>
<p>内部类说明</p>
<ul>
<li><strong>普通内部类</strong>: 对象内隐式保存了一个指向外围类对象的引用</li>
<li><strong>匿名内部类</strong>: 在方法或作用域内的内部类，申明时刻同时创建类实例，用在只需要一个临时的实例，常见线程创建，监听器创建。</li>
<li><strong>嵌套类</strong>: 直接申明普通内部类为static ，不需要内部类对象与外围类对象之间有关联。内部类不能访问外部类非static字段和方法。</li>
<li><strong>局部内部类</strong>: 在方法或作用域内的内部类，在块内声明，在块内可以通过其构造函数创建多个类实例。</li>
</ul>
<p>参考</p>
<ul>
<li>详细说明：<a href="http://malipei.javaeye.com/blog/151135" target="_blank" rel="noopener">http://malipei.javaeye.com/blog/151135</a></li>
<li>表格：<a href="http://www.cnitblog.com/dickznew/archive/2007/03/09/23779.html" target="_blank" rel="noopener">http://www.cnitblog.com/dickznew/archive/2007/03/09/23779.html</a></li>
</ul>
<h1 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h1><p>Java八大基本类型表：另特殊void，参考java编程思想中）</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>基本型别</th>
<th>封装装类</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>整形</td>
<td>char</td>
<td>Character</td>
<td>16-bit (2B)</td>
<td>Unicode 0</td>
<td>Unicode 2^16-1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整形</td>
<td>byte</td>
<td>Byte</td>
<td>8-bit (1B)</td>
<td>-128</td>
<td>+127</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整形</td>
<td>short</td>
<td>Short</td>
<td>16-bit (2B)</td>
<td>-2^15</td>
<td>+2^15-1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整形</td>
<td>int</td>
<td>Integer</td>
<td>32-bit (4B)</td>
<td>-2^31</td>
<td>+2^31-1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整形</td>
<td>long</td>
<td>Long</td>
<td>64-bit (8B)</td>
<td>-2^63</td>
<td>+2^63-1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
<td>Float</td>
<td>32-bit (4B)</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td></td>
<td></td>
</tr>
<tr>
<td>浮点型</td>
<td>double</td>
<td>Double</td>
<td>64-bit (8B)</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td></td>
<td></td>
</tr>
<tr>
<td>布尔类型</td>
<td>boolean</td>
<td>Boolean</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td></td>
<td></td>
</tr>
<tr>
<td>特殊</td>
<td>void</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td></td>
</tr>
</tbody>
</table>
<p>补充</p>
<ul>
<li>另两个高精度计算类：BigInteger与BigDecimal，支持任意精度的整数和定点数</li>
<li>java基本数据类型是存储在堆栈中，而大多数对象的实例中内容是分配存储在堆中。</li>
<li>java中没有sizeof()方法，基本类型长度都一定，并封装在封装类中，如java.lang.Integer.SIZE，java.lang.Integer.MAX_VALUE</li>
</ul>
<h1 id="万类超类-Object"><a href="#万类超类-Object" class="headerlink" title="万类超类-Object"></a>万类超类-Object</h1><p>概述</p>
<ul>
<li>Object类是所有类的基类。在不明确给出超类的情况下，java会自动把object作为要定义类的超类。</li>
<li>可以使用类型为object的变量指向任意类型的对象。Object obj=new String(“abc”);当然，Object类型的变量只能用作各种值得通用持有者，要对他们进行任何专门的操作，都需要知道他们的原始类型并进行类型转换。String e=(String)obj;</li>
</ul>
<p>Object的常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>定义作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean equals()</td>
<td>比较对象是否相等，Object内部通过==判断实现，如果两个对象指向同一内存区域，则返回真，否则返回false。经常会被子类覆盖，自定义成判断两对象内容是否对应相等。</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回表示当前对象值的字符串</td>
</tr>
<tr>
<td>Class  getClass()</td>
<td>返回类定义的类对象。该对象含有关于当前对象的信息</td>
</tr>
<tr>
<td>Object clone()</td>
<td>创建对象的副本，java为新实例分配内存，并且将当前类所占内存中的内容拷贝到新实例的内存中</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>返回对象的hash码，Object中是native实现，方便 java.util.Hashtable中使用</td>
</tr>
</tbody>
</table>
<p>equals()和 hashCode()用法</p>
<p>Java API中定义equal()覆盖规则</p>
<ul>
<li>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</li>
<li>反射性：x.equals(x)必须返回是“true”。</li>
<li>类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</li>
<li>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不重复x.equals(y)多少次，返回都是“true”。</li>
<li>其他：x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。</li>
</ul>
<p>Java API中定义hashCode()覆盖规范</p>
<ul>
<li>如果两个对象相同(<strong>运用equals方法比较</strong>)，那么它们的hashCode值一定要相同(如：new String(“abc”).hashCode()==new String(“abc”).hashCode()为真)；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同 。</li>
</ul>
<p><strong>组队使用场景</strong><br>在自定义类，并运用容器处理时，需要子重写hashCode与equals,在HashMap内部实现中，如 public V put(K key, V value) ;判断是否已存在键是通过 ( e.hash == hash  &amp;&amp;  ( (k = e.key) == key || key.equals(k) ) ) 判断的，也就可以看出是要同时判断hashCode与equals，此处有疑问，个人认为可以这样写 ((k = e.key) == key)||e.hash == hash &amp;&amp; key.equals(k)),如果引用都一样，那么就直接可以判等了。</p>
<p>样例：适HashMap装填自定义类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyData</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> MyData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.a == ((MyData) obj).a) &amp;&amp; (<span class="keyword">this</span>.b == ((MyData) obj).b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考</p>
<ul>
<li>Java面试基本类型：<a href="http://hi.baidu.com/setcc/blog/item/f1346cfacbd481106d22ebf5.html" target="_blank" rel="noopener">http://hi.baidu.com/setcc/blog/item/f1346cfacbd481106d22ebf5.html</a></li>
<li>Java基本类型：<a href="http://tech.e800.com.cn/articles/2009/916/1253068489832_1.html" target="_blank" rel="noopener">http://tech.e800.com.cn/articles/2009/916/1253068489832_1.html</a></li>
<li>equals和hashCode的API分析：<a href="http://lionheart.javaeye.com/blog/135077" target="_blank" rel="noopener">http://lionheart.javaeye.com/blog/135077</a></li>
<li>equals和hashCode使用说明：<a href="http://blog.csdn.net/RichardSundusky/archive/2007/02/12/1508028.aspx" target="_blank" rel="noopener">http://blog.csdn.net/RichardSundusky/archive/2007/02/12/1508028.aspx</a></li>
</ul>
<h1 id="java-lang-String类"><a href="#java-lang-String类" class="headerlink" title="java.lang.String类"></a>java.lang.String类</h1><p><strong>API解析</strong><br>String类是final类型，不可被继承, String类是的本质是字符数组char[], 并且其值不可改变。String内部字段private final char value[];</p>
<p><strong>String池</strong><br>Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区，当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。</p>
<p><strong>String两种创建方式</strong>:</p>
<ul>
<li>使用new关键字创建字符串，比如String s1 = new String(“abc”);只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。</li>
<li>直接指定。比如String s2 = “abc”;使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则指向池内对应的地址。</li>
</ul>
<p><strong>intern()方法</strong><br>String的intern()方法就是扩充常量池的一个方法（字符串常量，可以通过String.intern()方法来实现共享一个单独的String实例的目的）；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。</p>
<p><strong>判断String相等</strong>:</p>
<ul>
<li>==判断，是判断两String引用是否指向同一存储地址</li>
<li>equals();先判断是否同为String对象，然后判断对应值是否相等</li>
</ul>
<p><strong>String运算效率</strong><br>String值操作 a+b; a.concat();new StringBuffer().append();在大量连续操作中，效率由低到高。</p>
<p><strong>考察题目</strong> String s = new String(“xyz”);创建了两个String Object，一个在String池中，一个在堆中。</p>
<p>代码样例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String c = b.intern();</span><br><span class="line">System.out.println(a == b); <span class="comment">//false,地址比较</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">//true，值比较</span></span><br><span class="line">System.out.println(a==<span class="string">"abcc"</span>.substring(<span class="number">0</span>, <span class="number">3</span>)); <span class="comment">//substring返回内部是用new String()实现！</span></span><br><span class="line">System.out.println(a==<span class="string">"abc"</span>+<span class="string">""</span>);<span class="comment">//+运算，并且两端都为直接量，都是在String池中存储</span></span><br><span class="line">System.out.println(a==c); <span class="comment">//intern();返回String池常驻引用</span></span><br><span class="line">b=b+<span class="string">"c"</span>;</span><br><span class="line">a=a+<span class="string">"c"</span>;</span><br><span class="line">System.out.println(b==<span class="string">"abcc"</span>);  <span class="comment">//false,当+两段有引用量，则内部new String()并栈独立存储</span></span><br><span class="line">System.out.println(a==<span class="string">"abcc"</span>);  <span class="comment">//false,同上</span></span><br></pre></td></tr></table></figure>
<p>参考</p>
<ul>
<li>Sun邮件String讨论：<a href="http://dlstone.bokee.com/185678.html" target="_blank" rel="noopener">http://dlstone.bokee.com/185678.html</a></li>
<li>Java String分析：<a href="http://laiseeme.javaeye.com/blog/102442" target="_blank" rel="noopener">http://laiseeme.javaeye.com/blog/102442</a></li>
<li>java Native方法：<a href="http://www.javaeye.com/topic/72543" target="_blank" rel="noopener">http://www.javaeye.com/topic/72543</a></li>
</ul>
<p>** Java操作符instanceof</p>
<p><strong>概述：</strong> instanceof运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof 通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。 原理：利用<strong>RTTI</strong>:运行时类型识别（run-time type identification,RTTI）,可以实现多态，向上转型，类型检查。 不同于<strong>反射</strong>，在反射里：.class在编译时不可获得，是在运行时，打开检查.class文件，并构建类对象。</p>
<p><strong>用法：</strong> boolean result = object instanceof class 参数：result：object 任意对象；class：任意已定义的对象类,即类名 说明：如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。如果 object 不是指定类的一个实例，或者 object 是 null，则返回 false。</p>
<p>样列</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> System.out.println(<span class="keyword">new</span> Thread() <span class="keyword">instanceof</span> Runnable); <span class="comment">//true 接口适用，</span></span><br><span class="line"> System.out.println(<span class="string">"abc"</span> <span class="keyword">instanceof</span> String); <span class="comment">//true本类适用，特许类枚举类也适用</span></span><br><span class="line"> System.out.println(<span class="string">"abc"</span> <span class="keyword">instanceof</span> Object); <span class="comment">//true超类适用</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*以下为其他几种方式判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">""</span>.getClass()==String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(<span class="string">""</span>.getClass().equals(String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">System.out.println(String.class.isInstance(""));</span><br></pre></td></tr></table></figure>
<h1 id="Java超类子类关系"><a href="#Java超类子类关系" class="headerlink" title="Java超类子类关系"></a>Java超类子类关系</h1><p>总结</p>
<ul>
<li>main入口类首先编译，如果所在类继承其他类，其他类先于main当前类编译。</li>
<li>超类先于子类编译，构造初始化，初始化子类是先初始化超类</li>
</ul>
<p><strong>样列</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//基类Base</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> local=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base static print"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base non-static print"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base  initial"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(local);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"base static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类Sub</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> local = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sub initial"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sub static print"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sub non-static print"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(local);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"sub static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\[\] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0***********"</span>);</span><br><span class="line">        Base s;</span><br><span class="line">        System.out.println(<span class="string">"1***********"</span>);</span><br><span class="line">        s = <span class="keyword">new</span> Sub();</span><br><span class="line">        System.out.println(<span class="string">"2***********"</span>);</span><br><span class="line">        s.staticPrint(); <span class="comment">// 直接调用Base的静态输出</span></span><br><span class="line">        System.out.println(<span class="string">"3***********"</span>);</span><br><span class="line">        s.print(); <span class="comment">// 最终对象sub中覆盖了此方法，执行子类中方法</span></span><br><span class="line">        System.out.println(<span class="string">"4***********"</span>);</span><br><span class="line">        s.pLocal(); <span class="comment">// 同3,执行sub类中的方法</span></span><br><span class="line">        System.out.println(<span class="string">"5***********"</span>);</span><br><span class="line">        System.out.println(s.local); <span class="comment">// 找字段，直接找当前应用类型字段，此处为Base基类对应字段，</span></span><br><span class="line">        System.out.println(<span class="string">"6***********"</span>);</span><br><span class="line">        System.out.println(((Sub) s).local);<span class="comment">// 强制恢复转型为Sub后，获取的是Sub的字段值</span></span><br><span class="line">        System.out.println(<span class="string">"7***********"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">test static</span><br><span class="line">0***********</span><br><span class="line">1***********</span><br><span class="line">base static</span><br><span class="line">sub static</span><br><span class="line">base  initial</span><br><span class="line">sub initial</span><br><span class="line">2***********</span><br><span class="line">base static print</span><br><span class="line">3***********</span><br><span class="line">sub non-static print</span><br><span class="line">4***********</span><br><span class="line">1</span><br><span class="line">5***********</span><br><span class="line">0</span><br><span class="line">6***********</span><br><span class="line">1</span><br><span class="line">7***********</span><br></pre></td></tr></table></figure>
<h1 id="Java修饰符final，static"><a href="#Java修饰符final，static" class="headerlink" title="Java修饰符final，static"></a>Java修饰符final，static</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><strong>final 数据</strong>:</p>
<ul>
<li>场景：1永不改变的编译时常量，2对象不可改变应用（对象内部可以改变）</li>
<li>final数据：final是数据值不变，即是final又是static的字段只占据一段不能改变的存储空间</li>
</ul>
<p><strong>final 参数</strong><br>Java允许在参数列表中以声明的方式将参数值为final，使得在方法的内部无法更改参数引用所指向的对象的引用，但可改变对象内部属性。</p>
<p><strong>final 方法</strong>:</p>
<ul>
<li>把方法锁定，在继承中不能被覆盖，保证方法行为不变；</li>
<li>方法指定为final，就是同意编译器将针对该方法的所有调用转为内嵌调用（类似编译时宏迭代而非运行时方法调用），可以消除方法调用压栈出栈等开销。（适用于方法体较小的方法）</li>
</ul>
<p><strong>final类</strong><br>被声明为final的类不允许被继承，并且所有类方法都对应隐式声明为final</p>
<p>附注</p>
<ul>
<li>类中的所有private方法都隐式指定为final，由于类中的private方法不能被覆盖，因此子类中同名方法即使创建新方法，不存在覆盖概念。</li>
<li>接口字段隐式自动声明为static和final，所有的方法自动是public，（显示声明public与否都不影响）</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大）。 <strong>static:</strong> static在Java语言中的使用有四种：(变量、方法、代码块、内部类)</p>
<p><strong>static变量</strong> 按照是否静态的对类成员变量进行分类可分两种：</p>
<ul>
<li>一种是被static修饰的变量，叫静态变量或类变量</li>
<li>另一种是没有被static修饰的变量，叫实例变量。</li>
</ul>
<p>两者的区别是：</p>
<ul>
<li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。</li>
<li>对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</li>
</ul>
<p><strong>静态方法</strong> 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。 因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p><strong>static代码块</strong> static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<p><strong>静态内部类-即为嵌套类</strong>:</p>
<ul>
<li>为创建一个static内部类的对象，我们不需要一个外部类对象。  </li>
<li>不能从static内部类的一个对象中访问一个外部类对象。</li>
</ul>
<p>参考：</p>
<ul>
<li>Java中static详解：<a href="http://jeelee.javaeye.com/blog/528508" target="_blank" rel="noopener">http://jeelee.javaeye.com/blog/528508</a></li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2010/05/singleton/</url>
    <content><![CDATA[<p><strong>Java Design Pattern - Singleton（单例模式）</strong>:</p>
<a id="more"></a>
<h1 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h1><ul>
<li>归类：责任型模式</li>
<li>目标：将责任集中到某个类的单个实例上，确保某个类只有一个实例，并且为其提供一个全局访问点</li>
<li>实现方法：通过隐藏构造器和提供对创建对象的单个访问点，将类的职责集中于类的某单个实例中</li>
</ul>
<p>样列：UdpPortManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpPortManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UdpPortManager udpPortManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器私有化，对外不可见</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UdpPortManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 提供同步，线程安全的全局访问点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> UdpPortManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(udpPortManager==<span class="keyword">null</span>)&#123;</span><br><span class="line">            udpPortManager=<span class="keyword">new</span> UdpPortManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> udpPortManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>所包含实例变量应该是静态的私有的</li>
<li>外部调用该实例时，不是通过类的构造方法，而是通过一个getInstance()这样的静态方法来创建并获取该类的唯一实例。</li>
<li>默认的构造方法应该是私有的，这样保证了无法从外界创建该类的新实例</li>
<li>单例模式并不是线程安全的，同步关键字synchronized应用在getInstance保证只实例化一个</li>
</ul>
<h1 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h1><p>单列模式细分可以分为：懒汉式单例、饿汉式单例、登记式单例三种。参考：<a href="http://franksinger.javaeye.com/blog/531658" target="_blank" rel="noopener">franksinger</a></p>
<ul>
<li>懒汉单列：第一次调用getInstance()方法才初始化实例，一章节中的样列属于此种情形。</li>
<li>饿汉单列：静态直接初始化，private static UdpPortManager udpPortManager = new UdpPortManager();及在类被JVM加载时就初始化单列实例，而不必等调用getInstance()方法。</li>
<li>登记式单列：实际上接近多列模式了，就是类内部维护多个实例，外部调用共享改类所持有的实例。样列详见上述所给链接。Java中的Enum类实际上就是单列模式的一种扩展，Enum类中持有多个实例。</li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Desgin Pattern</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat核心server.xml配置</title>
    <url>/2010/05/tomcat-server-xml-config/</url>
    <content><![CDATA[<p>默认安装好Tomcat后，通过IP+端口访问到的是Tomcat的管理页面，其他常规部署到Tomcat的webapps目录下的项目都会是默认二级站点结构，下面总结通过配置server.xml更改Tomcat默认访问项目以及部署多个虚拟主机.</p>
<a id="more"></a>
<h1 id="Tomcat配置文件解读"><a href="#Tomcat配置文件解读" class="headerlink" title="Tomcat配置文件解读"></a>Tomcat配置文件解读</h1><p>以6.0版本为列，主要有在conf目录下，主要context.xml,server.xml,web.xml,tomcat.users.xml</p>
<ul>
<li>context.xml,web.xml是tomcat为每个部署其中的项目一个默认配置，所有其他项目的配置无非是基于之上的添加修改</li>
<li>server.xml是tomcat的核心配置文件，通过配置server.xml可以灵活设置虚拟主机</li>
<li>tomcat.users.xml配置tomcat管理员账户等</li>
</ul>
<p>server.xml个元素属性详参照<a href="https://www.cnblogs.com/starhu/p/5599773.html" target="_blank" rel="noopener">https://www.cnblogs.com/starhu/p/5599773.html</a></p>
<p>** Tomcat虚拟目录配置</p>
<p>默认安装好Tomcat后，通过IP+port访问到的是Tomcat的管理页面，其他常规部署到Tomcat的webapps目录下的项目都会是默认二级站点结构，以下为默认的主机配置信息Host：</p>
<p>默认的访问目录为ROOT，Context值如下：（注：Context属性归属与某Host属性内）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"ROOT"</span> <span class="attr">debug</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>表示默认访问Tomcat开启服务的IP：Port访问将是tomcat目录下ROOT对应的项目</p>
<p>可以通过更改docBase的值，配置为本地任何一个目录下的项目，以下给出一个较复杂的样列：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/informanager"</span> <span class="attr">docBase</span>=<span class="string">"D:\\informanager\\WebRoot"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">reloadable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"jdbc_mysql"</span> <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">url</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/informanagerautoReconnect=true<span class="symbol">&amp;amp;</span></span></span></span><br><span class="line"><span class="tag"><span class="string">    URIEncoding=UTF-8<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">maxActive</span>=<span class="string">"20"</span> <span class="attr">maxIdle</span>=<span class="string">"10"</span> <span class="attr">maxWait</span>=<span class="string">"5000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Tomcat虚拟主机配置"><a href="#Tomcat虚拟主机配置" class="headerlink" title="Tomcat虚拟主机配置"></a>Tomcat虚拟主机配置</h1><p>现在很多WWW上多个站点同时部署在一个IP服务器上，也可多个IP服务器对应一个站点，Tomcat也可通过配置server.xml来达到配置虚拟主机以下为默认最简化server.xml中的虚拟主机条目配置Host在很多WWW上多个站点同时部署在一个IP服务器上，也可多个IP服务器对应一个站点。</p>
<p>原理：HTTP/1.1协议中请求头域Host的值决定可以向同一IP发送请求，但是Host值不同，即请求的站点不同.</p>
<p>Tomcat同一IP多个虚拟主机配置可以通过可以通过基于主机名配置，也可通过基于端口号配置。</p>
<h2 id="基于主机名配置"><a href="#基于主机名配置" class="headerlink" title="基于主机名配置"></a>基于主机名配置</h2><p>Tomcat的server.xml文件，在初始状态下，只包括一个虚拟主机，但是它容易被扩充到支持多个虚拟主机。增加虚拟主机只要增加完整Host标签即可。每一个Host元素必须包括一个或多个context元素，所包含的context元素中必须有一个是默认的context，这个默认的context的显示路径应该为空（例如，path=””）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span></span></span><br><span class="line"><span class="tag"><span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">"google.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Alias</span>&gt;</span>www.google.org<span class="tag">&lt;/<span class="name">Alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Alias</span>&gt;</span>google.google.org<span class="tag">&lt;/<span class="name">Alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Alias</span>&gt;</span>bluepure.google.org<span class="tag">&lt;/<span class="name">Alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">docBase</span>=<span class="string">"vanjor"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里通过设置Alias别名，可以将多个域名host映射到同一个站点项目，这个需要配置DNS解析信息，本地可以通过更改Hosts文件</p>
<p>（windows系统Windows\System32\drivers\etc目录下），添加“127.0.0.1  google.com”等，可以模拟访问效果.</p>
<h2 id="基于端口号配置"><a href="#基于端口号配置" class="headerlink" title="基于端口号配置"></a>基于端口号配置</h2><p>可以通过server.xml中增加一对Service属性信息，如下：更换端口为8088</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina-2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8088"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina-2"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost-2"</span> <span class="attr">appBase</span>=<span class="string">"webapps-2"</span></span></span><br><span class="line"><span class="tag"><span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlValidation</span>=<span class="string">"false"</span> <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"."</span> <span class="attr">debug</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Webservice</tag>
      </tags>
  </entry>
  <entry>
    <title>vanjor almost</title>
    <url>/2010/05/vanjor-almost/</url>
    <content><![CDATA[<p>北京的五月依然春意未尽，上周的雨欲下而止，今天终于表现出了应该有的样子。而回忆家乡，相对算是南方，则印象中是那么的豪爽，早在二月份的时候，正午狂风大作，乌云蔽日，白天如黑夜，酣畅淋漓的瓢泼而泄，一切洗刷而尽，洗礼万物，在傍晚复现的晚霞中焕然一新，全然不曾知觉到刚经历过的狂风暴雨。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynkus6j1pj30g5089jre.jpg" alt="the cat - alice in wonderland"></p>
<a id="more"></a>
<p>而这首alice almost-爱丽丝梦游奇境片尾曲似乎作为那狂风暴雨中的插曲。</p>
<p>在故事情节进展极为类似《纳尼亚传奇》的《爱丽丝梦游奇境》，弥补了很久未曾看一部魔幻童话片的遗憾，女主角不算十分的漂亮，首尾的剧情安排感觉有些生硬的强加之上。</p>
<p>但仍然记忆犹新，在alice的无数次的nightmare后，都会有他父亲的安慰：it just a dream，nothing can hurt u when u wake up。这是一个多么大的鼓励，当在梦中，遇到险境，不去畏惧的面对，而是迎面而上，将不再会有nightmare，当在现实中，拥有一份勇气，面对一切难关，一切都会过去的，将不会被阻击在某一处。而《alice in wonderland》中alice在梦与真实处境虚虚实实中，凭借那份勇气成功的走到最后，最终alice almost将还是alice。</p>
<p>那个会消失的猫依然跃入眼前，尤其是幻化做天边的月亮笑脸，这个与宫崎骏《龙猫》有些类似的角色实际上又是童年的一份精神寄托。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynkvh8iu8j30m80g3jsy.jpg" alt="宫崎骏-龙猫-孩时的寄托"></p>
<p>这两周有许些插曲，本科导师 <a href="http://www.dian.org.cn" target="_blank" rel="noopener">Prof. Liu</a>来校访问，欣然全程陪同，并无意中当了一回会议秘书。当然收获也很多，通过Prof. Liu了解了两位仰慕前辈们的事情，惊讶于<a href="http://www.realdodo.com/" target="_blank" rel="noopener">realdodo</a>与<a href="http://www.awflasher.com" target="_blank" rel="noopener">aw</a>最终走到一起，赞aw的创业精神和敏锐的眼光，也同赞realdodo的执着技术追求与对知识渴求，技术上已近是万人之上的他每晚不看一小时书坚决不睡觉。同时也了解作为团队中的leader需要的协作能力，积极的交流，让队员们每天能够有一个明确的可以达到的目标，一点一点的积累，成就感也将无形的转化为动力。</p>
<p>同时一周的忙碌，终于组织并完成了实验室的出游活动，当天晚上大家happy的各自归途中，一个人静静的走在后面，独自享受那一份释放的月光。</p>
<p>听听推荐的歌，看看推荐的电影，吃着跳跳糖，生活·学习·工作中有些暂不能改变，但是有些值得去发现与享受，不去抱怨环境，当目标专一明确时，完全可以笑迎面之，但倘若若思绪不坚定，则小困难也能幻化出拦路猛虎。不要忘记上上周重写cv时的一种全然的否定。人不能过分自卑也不能过分自傲，当觉得什么都有的时候，其实什么都没有，当觉得什么都没有的时候，其实你至少还拥有自己。人应该让每天生活的“艰难”点为好！</p>
<p>Following the song: Alice in wonderland</p>
<pre><code>Tripping out
Spinning around
I＇m underground
I fell down
yeah, I fell down
I＇m freaking out
So, where am I now?
Upside down
And I can＇t stop it now
It can＇t stop me now
oooh Oooooh Oooohhh
I - I＇ll get by
I - I＇ll survive
When the world＇s crushing down
When I fall and hit the ground
I will turn myself around
Don＇t you try to stop me
I - I won＇t cry
I found myself
In Wonderland
Get back on
My feet again
Is this real?
Is this pretend?
I＇ll take a stand
Until the end
I - I＇ll get by
I - I＇ll survive
When the world＇s crushing down
When I fall and hit the ground
I will turn myself around
Don＇t you try to stop me
I - I won＇t cry
I - I＇ll get by
I - I＇ll survive
When the world＇s crushing down
When I fall and hit the ground
I will turn myself around
Don＇t you try to stop me
I - And I won＇t cry
</code></pre>]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>五月鲜花</title>
    <url>/2010/05/may-flowers/</url>
    <content><![CDATA[<p>继上月初的<a href="/2010/04/april-beginning/">四月新番</a>，早已在心里埋下伏笔，待五月之初写一篇五月月首寄语，名为五月鲜花。一来是纪念着北京晚来的春天，二来承接着那份希望与景愿。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynkbtk8vlj30go0b5q3h.jpg" alt="五月鲜花"></p>
<a id="more"></a>
<p>渐渐相信遇事多思考一步便是不一样的境地，对待一个问题，你所想到的第一个答案是大街上随便抓一个人就能想到的，第二个答案则是百分之二三十的人能够想到的，那么第三个第四个..最后则是你和及少数人才能想到的，而那正是思考所拥有的价值。从而抛弃掉茫然的冲动，成为一个智慧的行者。</p>
<p>四月：发现，思考，教训，收获，太多太多，混合交织。隐忍着很多想写的事情与发现，欣然找到<a href="http://mindhacks.cn" target="_blank" rel="noopener">刘未鹏 | Mind Hacks</a>，当只是书写些流水账时，就应该知道：<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）写博客</a>，以及<a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" target="_blank" rel="noopener">书写是为了更好的思考</a>。当发现为什么明明时间是连续的，拿在手中却是被分割成的片段与碎片，在对时间掌管失控时，为什么有时终日忙碌却无所事成，就应该知道：<a href="http://mindhacks.cn/2009/12/20/dark-time/" target="_blank" rel="noopener">暗时间</a>,以及<a href="http://www.zluyuer.com/blog/2009/11/practical-time-management/" target="_blank" rel="noopener">实用时间管理方法论</a>。</p>
<p>经验与教训同在，良好的景愿与现实是有差距，需要铭记最初方向，应对差距和各种突如其来的变化冲击，始终能够坚定的锁定目标，一次只做一件事，做到对自己有自知之明，对万物有自己的一份洞察力。</p>
<p>时间管理四象限法则：重要且紧急，重要非紧急，紧急非重要，非紧急非重要。有时候可以以一句话说来：聪明的人是在正确的时间做了正确的事情。然后有时候的确难以做到，从而疲于奔波于事务之间，让一项 重要非紧急，乃至 非紧急非重要的事务 演变成 重要且紧急，最后让自己为之十分被动，于事无成。让你疲惫不堪的，往往不是眼前的一座山，而是你鞋里的一粒沙。如何排开干扰，果然解决琐事，认准关注点，让自己充分主动，做时间的掌控者，做未来的主动者。</p>
<p>博弈·决策·执行力，其实执行力应该是一种高效而决绝的执行，破茧成蝶是的，但是倘若过多徘徊在安于现状与仅停留于设想间，拖延缓慢会让一切沦为失败，最终不能破茧而出，幻化成蝶，要么是慢慢被消磨在那个过程中，要么是错过了那个季节。当一幅画勾勒第一笔之前，心里已经预想全篇，走出那一步是重要的，而用尽全力，努力的勾勒好每一笔也是画中灵魂所在。</p>
<p>五月鲜花的寄语：正值挥洒汗水耕耘时，即是希望花开来。</p>
<p>以自勉</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>SIP协议相关链接库</title>
    <url>/2010/05/sip-relate-collection/</url>
    <content><![CDATA[<h1 id="SIP协议标准"><a href="#SIP协议标准" class="headerlink" title="SIP协议标准"></a>SIP协议标准</h1><p>SIP最基本标准：<a href="http://www.ietf.org/rfc/rfc3261.txt" target="_blank" rel="noopener">RFC3261</a></p>
<p>SIP其他及扩展：<a href="http://www.ietf.org/rfc/rfc3261.txt" target="_blank" rel="noopener">http://datatracker.ietf.org/wg/sip/</a></p>
<p>所有IETF标准：<a href="http://tools.ietf.org/" target="_blank" rel="noopener">http://tools.ietf.org/</a></p>
<a id="more"></a>
<h1 id="SIP学习教程"><a href="#SIP学习教程" class="headerlink" title="SIP学习教程"></a>SIP学习教程</h1><p>互联网电信标准教程：<a href="http://www.tech-invite.com/" target="_blank" rel="noopener">http://www.tech-invite.com/</a>  </p>
<h1 id="SIP协议栈开源项目"><a href="#SIP协议栈开源项目" class="headerlink" title="SIP协议栈开源项目"></a>SIP协议栈开源项目</h1><ul>
<li>Jain-SIP：<a href="http://snad.ncsl.nist.gov/proj/iptel/" target="_blank" rel="noopener">http://snad.ncsl.nist.gov/proj/iptel/</a>, 目前最新版本： <a href="http://snad.ncsl.nist.gov/proj/iptel/jain-sip-1.2/" target="_blank" rel="noopener">jain-sip-1.2源码库</a></li>
<li>oSIP： <a href="http://www.gnu.org/software/osip/" target="_blank" rel="noopener">http://www.gnu.org/software/osip/</a></li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>开源测试工具</p>
<ul>
<li>Sipp: <a href="http://sipp.sourceforge.net/" target="_blank" rel="noopener">http://sipp.sourceforge.net/</a>  </li>
</ul>
<p>SIP客户端：  </p>
<ul>
<li>xlite: <a href="http://www.counterpath.com/x-lite.html" target="_blank" rel="noopener">http://www.counterpath.com/x-lite.html</a>  </li>
<li>eyebeam: <a href="http://www.counterpath.com/eyebeam.html" target="_blank" rel="noopener">http://www.counterpath.com/eyebeam.html</a></li>
<li>Peers-sip：<a href="http://peers.sourceforge.net/" target="_blank" rel="noopener">http://peers.sourceforge.net/</a>  </li>
</ul>
<p>抓包工具  </p>
<ul>
<li>wireshark<ul>
<li>主页：<a href="http://www.wireshark.org/" target="_blank" rel="noopener">http://www.wireshark.org/</a>  </li>
<li>下载：<a href="http://www.wireshark.org/download.html" target="_blank" rel="noopener">http://www.wireshark.org/download.html</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>SIP</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>生命之殇</title>
    <url>/2010/04/life-shang/</url>
    <content><![CDATA[<p>序：谨以此文悼念已逝的班友</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynj0jrmkhj30d108amxj.jpg" alt="life grows, though tough"></p>
<blockquote>
<p>生命诚可贵，人生中还有什么比活着更幸福的呢？然而，与我擦身而过的那位研究生就在我踏进电梯的那一刹那决绝的从我们13楼迈向窗外。是的，他到达楼下的时间是比我短，但人世间的一切也许永远与他无关了。<br><a href="http://mapeiftian.blog.163.com/blog/static/13313026920103250315392/" target="_blank" rel="noopener">选自博客</a></p>
</blockquote>
<a id="more"></a>
<p>世间万物，当摆在生命的角度面前，似乎又都会变得如此渺小，又有什么比生命更为珍贵的东西呢，因为那是一切的一切的基础。</p>
<p>在班级会议上，当班长哽咽之中将责任归咎到她身上，当辅导员在给我们辅导的时候，安慰我们，大家一个集体，需要相互关怀互助，如发现他人有任何异样，应该及时的汇报，这一切的一切又显得于事无补。</p>
<p>责任，是一个什么东西的，多少的次事发之后，沉痛的归咎给自己的责任，有有多少次逃避摆脱责任呢。或许当自己还是活蹦乱跳，而他人早已云烟消逝，这种反差即便可以是自己的一种责任，或许，每个人需要看好自己，有些事情是他人无法挽救和实现预测的，明明前几天还是好好的，又有谁能知道呢，而似乎这些又可归为一种责任的规避。</p>
<p>当水滴闯入平静的湖面，波纹将会依次散开，由近及远。不想过多说，那因自杀而导致的波浪震动到的每个波动到的人，他们又都将是自杀间接受害者，而最靠近中心的，毫无疑问将是自杀者的家人，这会让他们陷于无尽的深渊，自责，困惑，悲痛，绝望，阴影，痛不欲生。更不想说，这到底是谁的责任，自身，他人，还是社会。也不想过多说，压力，他人，社会环境造成悲剧，在这个世上谁没有压力呢？</p>
<p>交流是交互，沟通也是相互的，没有绝对而纯粹的单向的沟通与交流，因而当一个人选择了封闭内心，那么也就关闭了内心与外界沟通的通道，这种将难以为外人所查。这也正像峡谷里的回音，找不到出路，震荡越来越大，也正像一个炮竹，内心的易爆的火药外围被包裹的紧紧的，哪怕一件小小的外围事件—很小的火星，通过引信这个导火索，封闭的爆竹将会爆炸，倘若能够切开爆竹，流出一道缝，纵使被点燃，也不会爆炸。</p>
<p>小时候看过安全手册，各种各样自救的信息，但却很少有关于自杀方面的自救心理指导，与其说心理介于与辅导，不如说自我救赎更为重要，因为那何尝不是人的一种最基本的生存技能呢？就像睡眠吃饭一样。每个人在人生长河中都会遇到挫折，大大小小，纵使有那些谚语：<em>没有跨不过去</em>的沟，迈<em>不过去的坎。车到山前必有路，天无绝人之路__，</em> 但是在某些情景下，的确会产生幻想，感觉到那是个跨不过去的坎，天要亡我，或多或少因为我们具有人性通有的一些缺点，或者其子集：固执，偏激，自闭，沉默等等，或多或少，在心理出现了一些假象，陷入一种内心思维的迷宫闭室。绝大多数时候，我们可以在萌芽前就很好的消灭掉，或者陷入后自己走出来，或者选择开放让人领着走出来，或者被人发现给拎出来，或者仍深陷其中。而那绝少数的则是最终找不到出路，选择了自我毁灭。</p>
<p>深恶痛疾这种话：“愿死者在另一个世界也过得美好，没有痛苦，在天堂安息。 ” 这不是一个善意的谎言！这是一种最大的欺骗! 对生命，对自我的一种极端藐视的欺骗！因为没有另外一个世界，没有天堂和地狱，只有逝去与消失，那些选择自杀的人真是想摆脱当前的痛苦，绝望而选择逃离现实，自我认为选择一种解脱的方式，认为自杀将会是他们感受到最后的解脱，而事实上，自杀让他们一无所得，他们将不会感受到任何解脱，因为他们已不再具有这资格，反而他们会让亲人好友陷于无尽的困境而得不到解脱。</p>
<p>之前一次无意中发现Google搜索I want to die，结果的头两条会有一条：<a href="http://www.metanoia.org/suicide/" target="_blank" rel="noopener">Suicide: Read This First</a>，写的很好。</p>
<p>  Suicide is not chosen; it happens when pain exceeds resources for coping with pain.</p>
<p>  but</p>
<p>  People often turn to suicide because they are seeking relief from pain. Remember that relief is a feeling. And you have to be alive to feel it. You will not feel the relief you so desperately seek, if you are dead.</p>
<p>生命是父母赋予的，个人是没有权利去剥夺它。逃避他那是人性最大的弱点。中国的传统是忌讳任何死亡相关，却又在各种口语中便用死字：都快热死了；都想死你了等。死暗藏一种极端。很多时候人们选择逃避，不愿去过多的思考它，当不得不面对他，也是闭口不谈，拐弯抹角。</p>
<p>“未经检讨的生活，活得不值”（苏格拉底），同样，“未经检讨的死亡，死得不值”（罗伯特·卡瓦诺），已逝的同学用生命的代价做出牺牲，让我们得到再一次的反省，就像在前进的道路上，从跌倒的战友旁爬起来，继续前行。</p>
<p>直面死亡，就是直面人生。而每一次的沐浴阳光，都是那么的充满感激，因为这是生的赐予。</p>
<p>原死者安息，生者坚强！</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>四月新番</title>
    <url>/2010/04/april-beginning/</url>
    <content><![CDATA[<p>又是一年清明节，没曾祈望北方能带来“清明时节雨纷纷”的景象，却在晚上意外接受到这份惊喜，莫非这是多少份对祖先思念而凝聚的泪水，难以抑制的迸发。空气也因此变得滋润起来，俗话说：清明前后，种瓜种豆，北方春天来的晚，但这些阵子，光俏的枝头也都发芽了，一派生命的气息。</p>
<a id="more"></a>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynirpypqoj30qm0e875s.jpg" alt="来自Bing的一张追忆图：胡同里奔跑的风筝与女孩"></p>
<p>晚上几乎又是赶上末班车，随同上车也才3，4人，车内熄着灯，显得格外安宁，习惯直奔最后一排，当售票员带着老北京的吆喝问我们到哪，十分的爽快喊道：终点。随着班车不停站的狂奔，心也因此而飞扬。</p>
<p>其实四月乍到就想写点什么，但中间一直在耽搁，不曾数过这期间有多少事。相比外界的热闹非凡，心里却始终是一种异常的宁静，还记得去年是一位朋友的签名-四月新番，曾不知还是一部漫画电影，但这四个字所含之意十分恰当，惹人喜爱，如果说北方三月还有些严寒，万物冷寂，那么四月绝对是全面复苏的时候了，值万物的新的轮回的之时，人也不禁融入其中，或许当那绿芽还在朦胧之际就知道它注定要成为一片绿叶，以期时而吸收光和热。人也会在这个季节中被触动着，多少会有些新的感触，新的期盼。而四月新番，正式一切尽在不言中。</p>
<p>当才得知朋友来恰逢假期来北京却隐瞒未说，惊讶之余，也很快释然，一直年少轻狂走来，回首惭愧太浅薄。不久前一位好友日志感叹：成长的变化是成熟还是悲哀，遂以成熟胜过无奈安慰回应之，其实也是在缅怀曾经的自己。</p>
<p>愈发觉得读的书太少了，叹息曾经荒废多少了时间，现已经习惯图书馆借的书超半数非技术方面了，因为知道缺的太多，逐渐喜欢上那种调味与弥补。然总让被迫因公事而终日停驻在电脑前，甘有眼巴巴望着停放颇久于书架的书籍。遂趁着这个假期好好享受一番，钦佩胡雪岩的待人诚挚，以真心交朋友，不因一时得失喜怒哀乐行事，眼光长远，广交能人，珍视人情交际大过其他，赢得起也输得的起，言必行，行必果，承诺千金。同时也颇受李敖传记的触动，虽然在个人生活态度方面颇不赞同李敖的作风，但是在执学方面，李敖的那种极为苛刻的惜时如金态度，时刻自我检审，孜孜不倦，勤奋学习，能忍受常人所难，行动主义派作风。令我实为敬佩，所谓成人，成为成功之人，不是每天空想想到的，而是以实际行动来实现了，不吃苦中苦，处处攀比安逸，满足于现状也是自己最大的一弱点。</p>
<p>由此自我反省，不仅未能惜时如金，反而时常做事效率低下，是把事情稀释放大扩充填塞时间，反而要自怨自艾因忙而无暇他事，时为 不该。</p>
<p>四月新番的寄语：言必行，行必果，埋头做事，抬头看人。</p>
<p>以自勉</p>
<p>后记：前日无意翻看Bing首页，放风筝小女孩的图片，甚好，遂放之于首页，做四月新番之景。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>沟通的互联网</title>
    <url>/2010/04/communicate-on-internet/</url>
    <content><![CDATA[<p>最近在比较分析Google wave与Google  buzz这两大服务特点，从一年天热火朝天的Google wave到现在比较低调推出的Google buzz，Google在技术上始终处于领先创新的位置，但是wave明显并不受许多用户的喜爱，而buzz尚在观察。</p>
<p>从而对比分析比较现在比较火热的Facebook，人人，开心，豆瓣，以及微博，QQ，至此根据自己6年来互联网的实际体验谈谈自己的看法。</p>
<a id="more"></a>
<h1 id="初期互联网沟通交流"><a href="#初期互联网沟通交流" class="headerlink" title="初期互联网沟通交流"></a>初期互联网沟通交流</h1><p>早期互联网大众所用到的信息传递主要有：</p>
<ul>
<li>FTP：(file transfer protocol) 文件传输协议。  </li>
<li>Telnet：(telecom munication net work protocol) 一种远程登录。  </li>
<li>BBS： (Bulletin Bard System) 电子公告牌系统。  </li>
<li>E-mail：(Electronic mail) 电子邮件</li>
</ul>
<p>在信息沟通上,以BBS和E-mail为主: BBS通常是以主题贴为核心，大家围绕主题讨论。而E-mail多以一对一的方式私密进行交流。但是随着互联网的发展，以及人们对沟通的细化需求，以上两种沟通方式已不能满足人们的需要，体现在BBS虽然具有比较良好的用户间交互性，但是很明显有如下不足：</p>
<ul>
<li>以内容-主题贴为中心，而非以人为中心：无法提供较好个性化展示的平台，也缺乏人际间一个稳定的纽带。</li>
<li>信息传播载体贫乏：主要的信息载体为文字，在早期只有telenet登录发展到web界面是，虽然有些加入了图片视频，但对于日益丰富的多媒体信息形势表现匮乏。</li>
<li>信息资源的掌控力：BBS上对信息掌控的是站长和版主们，个人在BBS上的权利十分有限，甚至对自己所创造的内容也只能任由他人掌控，同时信息大多数只能被动接受，不能改变结构和形式。</li>
</ul>
<h1 id="Web-1-0带领的发展改变"><a href="#Web-1-0带领的发展改变" class="headerlink" title="Web 1.0带领的发展改变"></a>Web 1.0带领的发展改变</h1><p>随着1999年：Peter Merholz以缩略词“blog”来命名博客，成为今天最常用的术语，以个性化展示为主的沟通方式逐渐走入人们的视野，并被大家所接受，从此，相关的播客，闪客等也借此走入人们的视线。</p>
<p>博客，又译为网络日志、部落格或部落阁等，不同于新闻组，BBS，它是一种通常由个人管理、不定期张贴新的文章的网站，也正是满足的人们个性化展示需求。从而在古时只有出书集会演讲才能展示自己的观点，很轻松的在自己的博客平台上实现了。</p>
<p>但是，博客拥有BBS等没有的功能特点，满足了大家需求的同时，也日益表现了某些方便不足，或者说是较难达到的需求：</p>
<ul>
<li>交互性短缺：<ul>
<li>博客主要以评论留言为主的交互，很容易让交流内容限制于文章的内容。</li>
</ul>
</li>
<li>缺乏稳定纽带：<ul>
<li>博客作为个人独立平台，需要他人主动关注，而从才能有比较有效沟通，这样不能有效扩大朋友交际圈，而现行大型的博客服务商提供了比较好的互动平台，以及博客间的友情链接，渐渐能够达到一种比较即时的沟通交流，前提也仅是在朋友们使用相同的博客SP提供的服务。</li>
</ul>
</li>
</ul>
<p>博客-网络日志，随着时代的发展，生活节奏的提高，人们缺乏足够的时间去写一些长篇日志，而不会去选择经常去写只有几句话的日志，因为这样将使得博客不伦不类，往往很多时候希望能用几句话来展示自己最近的喜怒哀乐（也是是后来微博客所跟进的一点），从而由于这些原因以及博客缺乏关注度等等，全球平均博客存活率始终保持在一个比较低的水平。</p>
<p>而另一方面以即时交流通讯ICO开始渐渐的广泛普及，最终在中国大陆的QQ，以及世界范围的MSN为成功典范，表现在：</p>
<ul>
<li>即时交流通信，OICU-oh i seek you，当对方在线，只用点击图标就可以开展一对一的交流，这一即时交流特性极度弥补了人们物理上的隔阂，从而带来了一种方便、快捷、高效而且基本免费的沟通方式。从这里也可以进一步看出从E-mail继承而演进的模型，早期的E-mail由于服务器网关间原因，并不能达到即时收发，有时国内国外间的邮件可能需要一天的时间。而即时聊天的这种特点也是从人们早期E-mail需求上进一步分离细化而来。</li>
<li>群组讨论，无论是QQ，还是MSN等都提供群组讨论功能，用户主要由社会上的实际组织归类，共同兴趣爱好为纽带各种关系而建立的交流群组从而维持一个长期的多人群组交流模式，这一特点也是从BBS的需求特性细化分离出来，即时通信的群组交流相比下BBS的交流更为随意轻松，纽带更为紧密，同时即时性远高于BBS.</li>
</ul>
<p>即时通讯同样也存在一些问题：</p>
<ul>
<li>信息的持久化、结构化：<ul>
<li>现在QQ，MSN的沟通信息目前只能是本地存储（QQ会员除外），不能实现一种持久化的存储，而且对于信息的结构组织基本是完全基于时间线，为于历史信息缺乏可维护性。也也是为什么QQ推出了群聊天精华的原因之一。</li>
</ul>
</li>
<li>缺乏个人展示：<ul>
<li>像QQ大多数交流只算是私下交流，非当事人无法共享，有很多时候非极为私密的聊天，某种程度上用户是希望能够能所共享的。</li>
</ul>
</li>
<li>沟通方式上的不足：<ul>
<li>QQ，MSN这种即时沟通方式，一度程度上满足了人们即时通讯，维护人际关系，但前提是在想与对方沟通下，主动点击对方，才能进行下去，很多时候，在一些非紧密的人，很长时间都不能通过QQ沟通上一次，这也就造成了QQ上比较经典的长时间不联系后的交流语：好长时间没见啊，最近怎么样啊。对于非紧密的人不能很好的维护自己的人际间的交往，同时需要展现自己的最近境况的时候，广播传递方式，需要亲自一对一传播，而QQ，MSN签名档一定程度上缓解，仍然十分不够。</li>
</ul>
</li>
</ul>
<h1 id="Web-2-0深化改变"><a href="#Web-2-0深化改变" class="headerlink" title="Web 2.0深化改变"></a>Web 2.0深化改变</h1><p>IBM的社区网络分析师，Dario de Judicibus，提出：</p>
<blockquote>
<p>Web 2.0 是一个架构在知识上的环境，人与人之间交互而产生出的内容，经由在服务导向的架构中的程序，在这个环境被发布，管理和使用。</p>
</blockquote>
<p><strong>社交网络</strong>：随着fackbook，人人（原校内），开心网这种基于社区性交流网站的出现，在沟通方式上进一步的满足的人们细化需求，表现在：</p>
<ul>
<li>人际纽带的建立上<ul>
<li>QQ主要基于亲友朋友间，而这些社交性网站从多方面出发，企业，学校，地区，建立大大小圈子，将人们无形划分在圈子中，而不会感觉到孤独，同时这些基于用户间这些共同点点建立长期纽带，不仅是日常分享交流平台，同时也是很好的一个新朋友认识的平台，很多情况下，现实中的阻隔，到了互联网上，社区网站上就不是了。很多情况下可能在现实中见过一面后，回去留心在社交站点查找到并加上好友，就可一回生二回熟了。</li>
</ul>
</li>
<li>信息传播方式的改革<ul>
<li>鉴于即时通信这种，与所有朋友联系人定时沟通是困难的，很多时候难以找上话题，而社交性网站似乎是在每个人的各自页面上建立一个BBS公告板，个人可以基于自己的近状喜怒哀乐或所见所得在自己的页面上张贴出来，系统将会按照人际关系维度的规则，将消息分发给亲朋好友。作为信息的发送方，同时也是信息的接受方，也会在最近动态页面上收到朋友的最近动态，这样满足了人际间交流了解的需求，同时每个人都是完全主动的有选择对感兴趣的消息进行回复交流。</li>
</ul>
</li>
</ul>
<p><strong>微博客</strong>是在博客的发展中，经一步细化发展而来，随着生活节奏的提高，日常沟通中，简短的消息具有更高效快捷传播力和影响力，微博客，特别是结合日益成熟的掌上移动通信平台，成为很多人离不开的一部分，当随时遇到一条消息想分享的时候，不是一个个QQ消息发送，一个短消息发送，而是更新到微博客上。</p>
<p>同时微博客的交互方式完全是以关注和被关注的中心的，而facebook，人人这种则是以朋友维度之间区分建立的。因为微博客在信息传播分享上比facebook这种更为速度广泛，迅速，人与人间的关系变得更透明简单，便于处理。</p>
<h1 id="Google对未来发展的尝试"><a href="#Google对未来发展的尝试" class="headerlink" title="Google对未来发展的尝试"></a>Google对未来发展的尝试</h1><p>Google 技术创新的领航者，在未来的沟通模式上已近做出了许多尝试，Google wave 以及 Google buzz 这也是其中的两种尝试。</p>
<ul>
<li><strong>Google Wave</strong>: 按照Google 2009年5月27日在Google I/O上的说法是“一种个人通信和协作工具”。它是一个Web服务、计算平台和通信协议，旨在合并电子邮件、即时通信、wiki和社交网络。</li>
<li><strong>Google Buzz</strong>: 是由Google开发的社会化消息工具，集成于该公司的邮件服务Gmail中。朋友分享的链接与信息会显示在Gmail界面中。Buzz中融合了照片、视频、链接等多种元素，形成了Gmail会话的重要组成部分。</li>
</ul>
<p>用户在发布Buzz时可以选择将其分享给全世界或是有限人群。目前Buzz已支持Picasa、Flickr、Google Reader、YouTube、Blogger和Twitter。</p>
<p>关于目前不是十分成功的原因，个人认为一方面是Google所提出的沟通概念目前超出了很多用户的接受范围，不同与Facebook，人人，这种社交模式，界面设计大家已经基本都熟悉，概念上深入人心，并且容易引起误解和恐惧感，像Buzz的隐私安全管理。同时在产品宣传上，对概念推广，界面设计及使用未很好的说明和解释，加上本身使用设计的并不是很周全，导致具有比较大学习成本，也就在尝鲜后未能挽留住用户。用户使用一项产品需要良好主导权和控制权，而以上两点是Google目前这两项服务还有所欠缺。</p>
<p>总之，通过个人体验使用感觉来看，Google是期望通过统一整合服务带来一种新思路，由质变到量变。应该更多的不是关注技术，而是深入体验挖掘细化用户需求，期待Google的这些举动最终能够获得良好的成功。</p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Internet</tag>
      </tags>
  </entry>
  <entry>
    <title>一碗油泼面的周末</title>
    <url>/2010/03/a-weekend-with-youpomian/</url>
    <content><![CDATA[<p>光阴冉冉，很快一周又过去了，忙忙碌碌，平淡中有许分凄然，终日闷在实验室，每晚11点回到宿舍，一天也就剩的不多了，“今天”（打上引号因为其实已近是过去的一天了）难的因为没吃晚饭才早些回，路上还惦记着那山西面馆还是否在营业，却不经意间抬头望了望天，一勾弯月柔柔的挂在天边一角，这才想起来有多久没曾注意到你，曾经何时每月的关注着你的阴晴圆缺，如今看到你，你似乎是那么凄美孤独的守在天边。</p>
<a id="more"></a>
<p>幸好那家山西面馆还是开着的，老板娘正洗碗收拾，因为不想再重复吃那刀削面，所以看了下菜单，在众多陌生的面食中隐约发现<a href="http://baike.baidu.com/view/138501.htm" target="_blank" rel="noopener">油泼面</a>看似是那么面熟，却又一时想不起来，当即点下油泼面，许久，当端上来时，看着金灿的油淋在面上，方才想起这不是晚上看《三枪拍案惊奇》中的招牌菜么，不禁有些惊喜，想起当时看的时候，光凭那面的异常精彩做法，就早已直流口水，现在这么快就可第一次尝试了~</p>
<p>虽说是今天算是北京乃至北方第一次大的沙尘暴，晚上还有比较大的风，鉴于过去的一周如此沉闷，以及那荒废许久的溜冰鞋，更有那同学喊了许久溜冰邀请，已经全然不再顾忌感冒还没好，回到宿舍就喊上同学-原还是本科同学，一起穿上溜冰鞋夹道来到北航，因为同学是新手，所以不能随意刷路，只能路上小心看着。一路上却让我想起本科时常的在晚上刷路逛学校的场景，在那些日子里，闷得时候，高兴的时候，不高兴的时候能出来围绕学校转一圈，听听歌，呼吸下新鲜空气，透透风。虽然对北航已经是十分熟悉了，但是仍然感觉是那么陌生，远没有在本科学校时候么亲切。是因为原来学校有异常僻静的小路，熟悉的教学楼，上坡的绝望下坡的舒爽的绝望坡，还是那个永远不缺活力的爱广呢（爱因斯坦广场），虽不从得知，但是的确是那种感觉已经找不回来了。当然在北航这里也能找些欣慰，体育场南边的時光奶茶店还不错，回来的时候买了两杯原味奶茶品尝品尝。</p>
<p>这周尝试做的事情比较多，终日带病待在实验室，也感悟人生最稀缺的是时间,想做的事太多,时间又是不允许.或者来说停止挥霍,提高效益,做相对更有意义的事情，很多时候还是需要把握分寸，有所自控有所舍弃，从而有的放矢，就像这周看的<a href="http://www.douban.com/subject/3196528/" target="_blank" rel="noopener">《刀锋上的舞蹈》</a>中再一次提到了，需要集中关注，专注于核心点：</p>
<blockquote>
<p><strong>在你年轻冲动的时候，任何事情看起来都是可能的，即便是同时做所有事情也吓不倒你。但是经验告诉我们，贪多嚼不烂。如果同时面对太多的选择，你要么会原地打转，要么就会陷入瘫痪。</strong></p>
</blockquote>
<p>或许我本就不应该被困难压倒，就想导师这周两次循循教导给我提到一点：<strong>世上有两种做不到，一种是的确比较困难暂时你做不到，别人也还没能做到；另一种则是你不能做到，别人却能做到</strong>。</p>
<p>俨然在现实中的重重困难面前，我可能是，首先的，最需要冲破心理上这层阴影，其实也正是如师兄所说那样：<strong>你需要改变心态，现在做的不因是为别人所做，为老师所做，甚至是看老师脸色行事，更应该作为自己的一个兴趣，来自内心的动力去做</strong>。</p>
<p>正向许许多多工作再各自岗位上的人们难免会对自己所做的事有所抱怨，但那些成功的人，优秀的人会看清这一点，欣然去接受，而不是当做一个负担。有时候该“笨”点就改笨点。</p>
<p>恩，忘说了，油泼面真的名不符其实，好吃，很好吃！~</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>“园丁”的这几天</title>
    <url>/2010/03/those-days-with-garden/</url>
    <content><![CDATA[<p>之前就比喻过摆弄着自己的个人网站空间更像是看护着个人的一片后方花园，然而这几天看来却是很不太平..</p>
<a id="more"></a>
<h1 id="贼贼的百度"><a href="#贼贼的百度" class="headerlink" title="贼贼的百度"></a>贼贼的百度</h1><p>上午打开邮件，收到一封个人网站单月流量已达17G的警告通知，而前天查看也只有200M流量，顿时吓得去后台看下，还以为是服务商突然敲诈，联系服务商，这查看详细分析记录发现原来是一个MP3歌曲惹得祸，其实也是百度惹得祸。</p>
<p>第一幅为昨天访问URL排行，第一个为之前一篇日志中上传的一首王菲唱的传奇，换算下来用了17.05G的流量，这首歌曲3.4M大小，时常4分钟，访问39546次，平均每个访问耐心听了31秒。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fynik7dw1uj30hb0403yf.jpg" alt="top10"></p>
<p>第二幅为引用来源：看到排第一第二的合计起来三万七千多的应用如第一幅的三万九千多的引用基本吻合，直接访问估计是被百度MP3给发现了，然后成为大家下载的一个默默的种子，第二个URL就是百度目前还在测试的<a href="http://box.zhangmen.baidu.com/" title="百度掌门人音乐盒" target="_blank" rel="noopener">百度掌门人音乐盒</a>，音乐来源都是从自家百度MP3中获得的音乐源，真是盗之于民，用之于民啊。</p>
<p><img src="https://asset.vanjor.com/images/006tNbRwly1fyniklozu0j30kz06fmx6.jpg" alt="top30"></p>
<p>托百度的福，将两MP3给撤了。</p>
<h1 id="万恶的DNS缓存"><a href="#万恶的DNS缓存" class="headerlink" title="万恶的DNS缓存"></a>万恶的DNS缓存</h1><p>每个英文域名访问都是要被DNS解析，除了十三个独立IP根域名解析，其他分布在各个国家大大小的子域名解析或映像域名解析服务器，以及众多网关布置的DNS服务器的缓存及控制规则导致各个节点之间的分布式协作极为混乱不规则，在前天不知道是什么原因还是无意改动了域名的DNS解析，导致域名不能正常解析，后来虽改正过来，仍然不能访问，打电话给服务商，发现对方能够访问，还给截图过来的囧事。</p>
<p>四处打听武汉的同学也能打得开，我这边却只能望梅止渴了，推测是所在地区网关的DNS缓存在保存了错误的DNS缓存后还没更新出来，就这样直到第二天我这边才能正常访问。</p>
<h1 id="天朝的GFW"><a href="#天朝的GFW" class="headerlink" title="天朝的GFW"></a>天朝的GFW</h1><p>为什么要用个人博客空间写，可能有些人没注意到，用现有的大型博客提供商百度，新浪写文章会出现如下如此河蟹的事情：</p>
<pre><code>某个空间提供商为了不让敏感信息在其服务器上保存，设置了如下审查机制：
（1）假设你输入了10000字，其中第100、101两字是敏感词。你点击了发布。
（2）然后你发现自己只发布了99个字，第100个字和后面9900个字都不见了。
（3）你在任何地方都找不到这丢失的9900个字，你需要重新敲打一次。
（4）你意识到第100、101个字是敏感词，于是你替换成其它字了，接着你重新发布一次。
（5）然后你又发现，发布出去后只剩下200个字，因为第201个字又是敏感词。
</code></pre><p>片段引用自 <a href="http://www.kenengba.com" target="_blank" rel="noopener">可能吧</a> 的一篇文章<a href="http://www.kenengba.com/post/2812.html" target="_blank" rel="noopener">《审查机器》</a>。</p>
<p>出现这种类似”二十四口交换机”事情会让你痛心棘手，很多情况下基本上时找不到任何有嫌疑的词仍然不能发表，从而写文章时候得惴惴不安的考虑这次有没有运气能够发表出去。所以这样不如多费些周折，自建站点。</p>
<h1 id="依然是天朝的GFW"><a href="#依然是天朝的GFW" class="headerlink" title="依然是天朝的GFW"></a>依然是天朝的GFW</h1><p>之前一直爱用饭否的微博客，但是随后不久不到一年就神秘被维护了，据说是因为这种草根性的网站没有新浪微博那样的实力：拥有千人河蟹审查团，所以导致大量不河蟹信息泛滥而被<a href="http://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E" target="_blank" rel="noopener">GFW</a>河蟹了。</p>
<p>虽说学校校长方滨兴院士是外界称之为中国GFW之父，从个人感情角度来说实在不想他被扣上这顶帽子。想到在二月份网站的空间提供商九州未来突然就挂了，所有之下的客户服务全挂了，之后才被通知说提供商的机房给直接拔线了，对于我这种不能烧钱租专用IP服务器的，一群网站共享一个IP的很容易其中某个站点的不河蟹行为遭受到GFW的株连九族。所以不得不定时做下备份，以备之需。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>熬得住互联网上腥风云雨，但愿能守得住这边花园静土~</p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>GFW</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN服务器相关深入配置</title>
    <url>/2010/03/svn-setup-detail/</url>
    <content><![CDATA[<p>针对<strong>Subversion</strong> 的配置，在上一文中简要的说明最快捷的配置与使用，今天尝试进行权限配置时，发现了不少问题，现总结如下:</p>
<a id="more"></a>
<h1 id="版本库及服务创建之一"><a href="#版本库及服务创建之一" class="headerlink" title="版本库及服务创建之一"></a>版本库及服务创建之一</h1><p>通过subversion的svnserve启动apache服务：</p>
<h2 id="Subversion-的版本库（repository"><a href="#Subversion-的版本库（repository" class="headerlink" title="Subversion 的版本库（repository)"></a>Subversion 的版本库（repository)</h2><p>位于服务器端，统一管理和储存数据的地方。介绍在服务器端配置和管理 Subversion 版本库的基本方法，Linux 与Windows中的配置差别不大。</p>
<h2 id="版本库数据存储方式"><a href="#版本库数据存储方式" class="headerlink" title="版本库数据存储方式"></a>版本库数据存储方式</h2><p>在 Subversion 中，版本库的数据存储有两种方式，一种是在 Berkeley DB 数据库中存放数据；另一种是使用普通文件，采用自定义的格式来储存，称为 FSFS。（两种存放方式各有优缺点，参考 <a href="http://svnbook.org/" target="_blank" rel="noopener">svnbook</a> 上面的文档来了解两者详细的比较和区别）</p>
<h2 id="版本库服务启动"><a href="#版本库服务启动" class="headerlink" title="版本库服务启动"></a>版本库服务启动</h2><p>Subversion 设计了一个抽象的网络层，版本库建立完毕之后，可以通过各种服务器向外公布。svnserve 是 Subversion 自带的一个小型的服务器，它使用独立的协议与客户端。我们可以通过 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svnserve –i #作为 inetd 启动</span><br><span class="line">svnserve –d #作为守护进程启动一个服务。</span><br></pre></td></tr></table></figure>
<p>同时可以指定一些选项，常用的如 -r，用来指定版本库的根路径，例如假设版本库位于 E:/svn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svnserve –d -r E:/svn #即创建了以E:/svn为根目录的SVN版本库服务。</span><br></pre></td></tr></table></figure>
<h2 id="设置为系统服务并自动启动"><a href="#设置为系统服务并自动启动" class="headerlink" title="设置为系统服务并自动启动"></a>设置为系统服务并自动启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svnserve --daemon --root E:\\svn\\repository</span><br></pre></td></tr></table></figure>
<p>服务启动–daemon可简写为-d、–root可简写为-r可以建立个批处理文件并放在windows启动组中便于开机 就运行SVN服务或者在这个<a href="http://clanlib.org/~mbn/svnservice/" target="_blank" rel="noopener">地址</a>下载那个svnservice.exe文件拷贝到 命令行下执行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svnservice -install --daemon --root "D:\\svn\\Repository"</span><br><span class="line">sc config svnservice start= auto</span><br><span class="line">net start svnservice</span><br></pre></td></tr></table></figure>
<h2 id="创建子版本库（或版本库）"><a href="#创建子版本库（或版本库）" class="headerlink" title="创建子版本库（或版本库）"></a>创建子版本库（或版本库）</h2><p>假设以以上”E:/svn”为根目录，并启动svn服务器，那么创建子版本库有两种方式：</p>
<ul>
<li>通过TortoiseSVN等svn客户端工具创建版本库：在E:/svn中新建子目录project1，并进入E：/svn/project1 中通过TortoiseSVN菜单创建版本库，则这个版本库可以通过svn://服务器IP/project1”访问,以此类推可建立project2等等，并且这样各个子项目库相关权限配置保持独立。</li>
<li>通过subSVN服务器命令创建版本库, 创建版本库的命令，指定数据存储为 FSFS，如果要指定为 Berkeley DB，则将 fsfs 改为 bdb</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svnadmin create --fs-type fsfs /etc/svn/repos</span><br></pre></td></tr></table></figure>
<h2 id="版本库下目录文件说明"><a href="#版本库下目录文件说明" class="headerlink" title="版本库下目录文件说明"></a>版本库下目录文件说明</h2><ul>
<li>conf 目录：存放了版本库的配置文件，包括用户访问控制和权限控制等内容，文件本身的注释说明十分详细，读者可以根据注释自行配置；</li>
<li>dav 目录：是提供给 Apache 相关模块的目录，目前为空；</li>
<li>db 目录：存放着 Subversion 所要管理的所有受版本控制的数据，不同的存储方式（Berkeley DB 或者 FSFS）下有着不同的目录结构，不过我们一般不用直接修改和查看这个目录下的内容，Subversion 的命令可以安全的操作这个目录；</li>
<li>hooks 目录：存放着钩子脚本及其模版（一种版本库事件触发程序）</li>
<li>locks 目录：存放着 Subversion 版本库锁定数据，format 文件记录了版本库的布局版本号。</li>
</ul>
<h2 id="推荐项目程序目录结构如下"><a href="#推荐项目程序目录结构如下" class="headerlink" title="推荐项目程序目录结构如下"></a>推荐项目程序目录结构如下</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|――project_A  </span><br><span class="line">| ――――branches</span><br><span class="line">| ――――tags</span><br><span class="line">| ――――trunk</span><br></pre></td></tr></table></figure>
<p>可以通过客户端建立好相关目录，然后提交到版本库或子版本库中。</p>
<h1 id="版本库及服务创建之二"><a href="#版本库及服务创建之二" class="headerlink" title="版本库及服务创建之二"></a>版本库及服务创建之二</h1><p>通过Apache Http Server服务启动svnserve服务：</p>
<h2 id="特点说明"><a href="#特点说明" class="headerlink" title="特点说明"></a>特点说明</h2><p>区别于第一种：svnserve 只能对全局提供简单的访问控制，如果想要更加灵活的方式，可以使用 Apache Http Server 作为向外公布版本库的方式，同时可以通过HTTP访问。</p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ul>
<li>安装 mod_dav_svn 插件：用途使 Subversion 与 dav 模块通信，需要安装 mod_dav_svn 插件，可以在 Subversion 的安装目录中找到。将其拷贝到 Apache 安装目录的 modules 文件夹下。（由于 Subversion 需要版本化的控制，因此标准的 Http 协议不能满足需求。要让 Apache 与 Subversion 协同工作，需要使用 WebDAV（Web 分布式创作和版本控制）。WebDAV 是 HTTP 1.1 的扩展，关于 WebDAV 的规范和工作原理，可以参考 IETF RFC 2518。）</li>
<li><p>并配置 Apache 的 httpd.conf 文件，让 Apache 在启动的时候加载上述模块。需要添加的内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LoadModule dav\_module modules/mod\_dav.so</span><br><span class="line">LoadModule dav\_svn\_module modules/mod\_dav\_svn.so</span><br><span class="line"><span class="meta">#</span>首先需要启用 dav\_module，然后加载 dav\_svn_module</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="版本库建立"><a href="#版本库建立" class="headerlink" title="版本库建立"></a>版本库建立</h2><p>在Apache的httpd.conf文件中末尾加入如下配置信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DAV svn</span><br><span class="line">SVNPath /etc/svn/repos</span><br></pre></td></tr></table></figure>
<p>Location 标签指出访问的 URL 以及在服务器上的实际位置。配置完毕后重新启动 Apache，打开浏览器，输入 <a href="http://服务器IP/repos" target="_blank" rel="noopener">http://服务器IP/repos</a></p>
<h2 id="子版本库建立"><a href="#子版本库建立" class="headerlink" title="子版本库建立"></a>子版本库建立</h2><p>如果想要指定多个版本库，可以用多个 Location 标签，也可以使用 SVNParentPath 代替 SVNPath，例如在 /etc/svn 下有多个版本库 repos1，repos2 等等，用如下方式指定：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  DAV svn</span><br><span class="line">  SVNParentPath /etc/svn</span><br></pre></td></tr></table></figure>
<p>“SVNParentPath /etc/svn” 表示 /etc/svn 下的每个子目录都是一个版本库。可以通过 <a href="http://服务器IP/repos/repos1" target="_blank" rel="noopener">http://服务器IP/repos/repos1</a>，<a href="http://服务器IP/repos/repos2" target="_blank" rel="noopener">http://服务器IP/repos/repos2</a> 来访问。</p>
<h2 id="版本库目录权限配置"><a href="#版本库目录权限配置" class="headerlink" title="版本库目录权限配置"></a>版本库目录权限配置</h2><h3 id="相关配置文件说明"><a href="#相关配置文件说明" class="headerlink" title="相关配置文件说明"></a>相关配置文件说明</h3><p>svn版本库下的子目录conf下初始会有三个文件：</p>
<ul>
<li>svnserve.conf</li>
<li>passwd</li>
<li>authz</li>
</ul>
<h3 id="svnserve-conf文件配置"><a href="#svnserve-conf文件配置" class="headerlink" title="svnserve.conf文件配置"></a>svnserve.conf文件配置</h3><p>被用来配置来进行一些简单的访问权限控制。文件的初始内容大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[general]</span><br><span class="line"># anon-access = read</span><br><span class="line"># auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line"># authz-db = authz</span><br><span class="line"># realm = My First Repository</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li><code>anon-access</code> 表示匿名用户的权限</li>
<li><code>auth-access</code> 表示认证用户的权限设置</li>
<li><code>password-db</code> 指向保存用户帐号密码的文件的位置,可以使用相对路径。</li>
</ul>
<p>去掉#即可开启对应配置功能</p>
<h3 id="passwd文件配置"><a href="#passwd文件配置" class="headerlink" title="passwd文件配置"></a>passwd文件配置</h3><p>需让svnsere.conf中开启password-db = passwd，可让以配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">user1 = password1</span><br><span class="line">user2 = password2</span><br><span class="line"># 格式为：“用户名 = 密码”注意前后不要有空格，中间要有空格</span><br></pre></td></tr></table></figure>
<h3 id="authz文件配置"><a href="#authz文件配置" class="headerlink" title="authz文件配置"></a>authz文件配置</h3><p>需让svnsere.conf中开启authz-db = authz，可以配置如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>两个分组：committers，developers</span><br><span class="line">[groups]</span><br><span class="line">committers = paulex,richard</span><br><span class="line">developers = jimmy,michel,spark,sean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[/]</span><br><span class="line"><span class="meta">#</span>在根目录下指定所有的用户有读权限</span><br><span class="line">* = r</span><br><span class="line"><span class="meta">#</span>追加 committers 组用户有读写权限</span><br><span class="line">@committers = rw</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在 branches/dev 目录下指定 developers 组的用户有读写权限</span><br><span class="line">[/branches/dev]</span><br><span class="line">@developers = rw</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在 /tags 组下给予用户 tony 读写权限</span><br><span class="line">[/tags]</span><br><span class="line">tony = rw</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>禁止所有用户访问 /private 目录</span><br><span class="line">[/private]</span><br><span class="line">* =</span><br></pre></td></tr></table></figure>
<p>以上对于1章节中的以svnserve启动svn服务直接有效。</p>
<h2 id="Apache-Http-Server服务启动svnserve模块权限配置说明"><a href="#Apache-Http-Server服务启动svnserve模块权限配置说明" class="headerlink" title="Apache Http Server服务启动svnserve模块权限配置说明"></a>Apache Http Server服务启动svnserve模块权限配置说明</h2><h3 id="Apache-提供了基本的全局粒度权限设置"><a href="#Apache-提供了基本的全局粒度权限设置" class="headerlink" title="Apache 提供了基本的全局粒度权限设置"></a>Apache 提供了基本的全局粒度权限设置</h3><ul>
<li>首先需要创建一个用户文件。Apache 提供了一个工具 htpasswd，用于生成用户文件，可以在 Apache 的安装目录下找到。具体使用方法如下： htpasswd etc/svn/passwordfile username 如果 passwordfile 不存在，可以加上 -c 选项让 htpasswd 新建一个。创建好的文件内容是用户名加上密码的 MD5 密文。</li>
<li><p>接下来修改 httpd.conf，在 Location 标签中加入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AuthType Basic</span><br><span class="line">AuthName &quot;svn repos&quot;</span><br><span class="line">AuthUserFile /etc/svn/passwordfile</span><br><span class="line">Require valid-user</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>重新启动 Apache， 打开浏览器访问版本库。Apache 会提示你输入用户名和密码来认证登陆了。 现在只有 passwordfile 文件中设定的用户才可以访问版本库。也可以配置只有特定用户可以访问，替换上述 “Require valid-user” 为 “Require user tony robert” 将只有 tony 和 robert 可以访问该版本库。 有的时候也许不需要这样严格的访问控制，例如大多数开源项目允许匿名的读取操作，而只有认证用户才允许写操作。为了实现更为细致的权限认证，可以使用 Limit 和 LimitExcept 标签。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require valid-user</span><br></pre></td></tr></table></figure>
<p>如上配置将使匿名用户有读取权限，而限制只有 passwordfile 中配置的用户可以使用写操作。</p>
<h3 id="目录粒度权限访问设置"><a href="#目录粒度权限访问设置" class="headerlink" title="目录粒度权限访问设置"></a>目录粒度权限访问设置</h3><p>使用 Apache 的 mod_authz_svn 模块对每个目录进行认证操作。</p>
<p>首先需要让 Apache 将 mod_authz_svn 模块加载进来。在 Subversion 的安装目录中找到 mod_auth_svn 模块，将其拷贝到 Apache 安装目录的 modules 子目录下。修改 httpd.conf 文件，找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule dav\_svn\_module modules/mod\_dav\_svn.so</span><br></pre></td></tr></table></figure>
<p>在其后面加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule authz\_svn\_module modules/mod\_authz\_svn.so</span><br></pre></td></tr></table></figure>
<p>现在可以在 Location 标签中使用 authz 的功能了。一个基本的 authz 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  DAV svn</span><br><span class="line">  SVNPath /etc/svn/repos</span><br><span class="line">  AuthType Basic</span><br><span class="line">  AuthName &quot;svn repos&quot;</span><br><span class="line">  AuthUserFile /etc/svn/passwd</span><br><span class="line">  AuthzSVNAccessFile /etc/svn/accesspolicy</span><br><span class="line">  Satisfy Any</span><br><span class="line">  Require valid-user</span><br></pre></td></tr></table></figure>
<p>其中AuthUserFile和AuthzSVNAccessFile两个文件就是指向3章节中的 passwd和authz策略文件 指向的是 authz 的策略文件</p>
<p>使用 SVNParentPath 代替 SVNPath 来指定多个版本库的父目录时，其中所有的版本库都将按照这个策略文件配置。例如上例中 tony 将对所有版本库里的 /tags 目录具有读写权限。如果要对具体每个版本库配置，用如下的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[groups]</span><br><span class="line">project1_committers = paulex richard</span><br><span class="line">project2_committers = jimmy michel spark sean \</span><br><span class="line">           steven tony robert</span><br><span class="line">[repos1:/]</span><br><span class="line">* = r</span><br><span class="line">@ project1_committer = rw</span><br><span class="line">[repos2:/]</span><br><span class="line">* = r</span><br><span class="line">@ project2_committer = rw</span><br></pre></td></tr></table></figure>
<p>这样项目1的 committer 组只能对 repos1 版本库下的文件具有写权限而不能修改版本库 repos2，同样项目2的 commiter 也不能修改 repos1 版本库的文件。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="MySQL用户认证信息保护"><a href="#MySQL用户认证信息保护" class="headerlink" title="MySQL用户认证信息保护"></a>MySQL用户认证信息保护</h3><p>到目前为止我们的用户名密码文件还是以文本文件形式存放在文件系统中的，出于安全性的需要或者单点登陆等可扩展性的考虑，文本文件的管理方式都不能满足需求了。通过 Apache 的 module_auth_mysql 模块，我们可以用 MySQL 来保存用户信息。该模块的主页在 <a href="http://modauthmysql.sourceforge.net/" target="_blank" rel="noopener">Sourceforge</a>，你也可以在 <a href="http://modules.apache.org/" target="_blank" rel="noopener">Apache</a> 找到它的发行版本。安装方法同上述 Apache 的模块一样，拷贝至 modules 目录并在 httpd.conf 文件中添加如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mysql\_auth\_module modules/mod\_auth\_mysql.so</span><br></pre></td></tr></table></figure>
<p>相应的 Location 区域改写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  AuthName &quot;MySQL auth&quot;</span><br><span class="line">  AuthType Basic</span><br><span class="line">  AuthMySQLHost localhost</span><br><span class="line">  AuthMySQLCryptedPasswords Off</span><br><span class="line">  AuthMySQLUser root</span><br><span class="line">  AuthMySQLDB svn</span><br><span class="line">  AuthMySQLUserTable users</span><br><span class="line">  require valid-user</span><br></pre></td></tr></table></figure>
<p>然后在 mysql 中添加名为 svn 的数据库，并建立 users 数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> svn;</span><br><span class="line"><span class="keyword">use</span> svn;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> (</span><br><span class="line">user_name <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">user_passwd <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">user_group <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (user_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在 users 表中插入用户信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span>(<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'group'</span>);</span><br></pre></td></tr></table></figure>
<p>重新启动 Apache，在访问版本库的时候 Apache 就会用 mysql 数据表中的用户信息来验证了。</p>
<h3 id="SSL实现加密连接"><a href="#SSL实现加密连接" class="headerlink" title="SSL实现加密连接"></a>SSL实现加密连接</h3><p>通过 Apache 的网络链接，版本库中的代码和数据可以在互联网上传输，为了避免数据的明文传输，实现安全的版本控制，需要对数据的传输进行加密。Apache 提供了基于 SSL 的数据传输加密模块 mod_ssl，有了它，用户就可以用 https 协议访问版本库，从而实现数据的加密传输了。SSL 协议及其实现方式，是一个非常复杂的话题，本文只是介绍 Apache 提供的最基本的SSL配置方法，更加详细的介绍内容，请参考 <a href="http://httpd.apache.org/docs-2.0/ssl/" target="_blank" rel="noopener">Apache</a> 上的文档。</p>
<p>开始配置前，我们需要一个实现 Apache 中 SSL 模块的动态程序库，通常名为 mod_ssl.so，及其配置文件，通常名为 ssl.conf。这个实现是跟 Apache 的版本相关的，不匹配的版本是不能用的；而且，并不是每一个 Apache 的版本都自带了相关实现文件，很多情况下，我们需要自己去搜寻相关文件。另外，我们还需要 OpenSSL 软件及其配置文件，来生成加密密钥和数字证书。这里，我们可以使用一些免费网站，如 <a href="http://hunter.campbus.com/" target="_blank" rel="noopener">campbus</a> 上提供的集成版本的 Apache。</p>
<p>有了相关的工具和文件，我们就可以开始生成 SSL 的证书和密钥了。首先，我们需要找到 openssl 程序及其配置文件 openssl.cnf，运行如下命令来生成 128 位的 RSA 私有密钥文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-server.key：</span><br><span class="line">openssl genrsa -des3 -out my-server.key 1024</span><br><span class="line">Loading &apos;screen&apos; into random state - done</span><br><span class="line">Generating RSA private key, 1024 bit long modulus</span><br><span class="line">.....++++++</span><br><span class="line">........++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">Enter pass phrase for server.key:********</span><br><span class="line">Verifying - Enter pass phrase for server.key:********</span><br></pre></td></tr></table></figure>
<p>命令运行期间需要用户输入并确认自己的密码。</p>
<p>现在，我们需要 SSL 的认证证书，证书是由 CA（certificate authority） 发放并且认证的。为此，我们可以用如下命令生成一个 CSR(Certificate Signing Request) 文件发给 CA，从而得到 CA 的认证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -key my-server.key -out my-s erver.csr -config openssl.cnf</span><br></pre></td></tr></table></figure>
<p>当然，一般情况下，如果 Subversion 的用户不是太多，安全情况不是很复杂，我们也可以生成一个自签名的认证证书，从而省去了向 CA 申请认证的麻烦。如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -key my-server.key -x509 -out my-server.crt -config openssl.cnf</span><br></pre></td></tr></table></figure>
<p>以上两个命令都需要用户输入那个 key 文件的密码，以及一些网络设置信息，如域名，邮箱等等，这里输入的服务器域名应该与 Apache 配置文件当中的一致。现在，我们可以在 Apache 的 conf 目录下新建一个 ssl 目录，将 my-server.key 和 my-server.crt 文件都移动到 ssl 目录里面。然后修改 ssl.conf 文件，将 SSLCertificateKeyFile 和 SSLCertificateFile 项指向这两个文件。</p>
<p>如果 Apache 的 module 目录里面没有 mod_ssl.so 文件，可以将事先准备好的文件拷贝过去。然后，我们可以设置 Apache 的配置文件 httpd.conf，将 ssl 模块加入其中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule ssl\_module modules/mod\_ssl.so</span><br></pre></td></tr></table></figure>
<p>然后，在配置文件的最后，加上如下 SSL 相关配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSLMutex default</span><br><span class="line">SSLRandomSeed startup builtin</span><br><span class="line">SSLSessionCache none</span><br><span class="line">ErrorLog logs/SSL.log</span><br><span class="line">LogLevel info</span><br><span class="line"></span><br><span class="line">SSLEngine On</span><br><span class="line">SSLCertificateFile conf/ssl/my-server.crt</span><br><span class="line">SSLCertificateKeyFile conf/ssl/my-server.key</span><br></pre></td></tr></table></figure>
<p>这样，基本的设置工作就完成了。重新启动 Apache 服务器，现在可以用 https 协议代替 http 协议来访问版本库了。如果要限定版本库只能用 https 访问，我们可以在 Apache 配置文件当中 Subversion 部分加上 “SSLRequireSSL”。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DAV svn</span><br><span class="line">SVNPath /etc/svn/repos</span><br><span class="line">#other items</span><br><span class="line">SSLRequireSSL</span><br></pre></td></tr></table></figure>
<h1 id="文章结"><a href="#文章结" class="headerlink" title="文章结"></a>文章结</h1><p>目前除了第5章和apache server启动服务没有亲自测试实现，其他均尝试成功，全文参考资料<a href="http://www.ibm.com/developerworks/cn/java/j-lo-apache-subversion/" title="用 Apache 和 Subversion 搭建安全的版本控制环境" target="_blank" rel="noopener">《用 Apache 和 Subversion 搭建安全的版本控制环境》</a>，以及其他资料，并根据个人实验理解，重新整理。</p>
<p>版本控制相关概念详见 <a href="http://betterexplained.com/articles/a-visual-guide-to-version-control/" title="A Visual Guide to Version Control" target="_blank" rel="noopener">A Visual Guide to Version Control</a></p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>读《谁说大象不能跳舞》</title>
    <url>/2010/03/who-says-elepahants-cant-dance/</url>
    <content><![CDATA[<p>这周五在图书馆看到这本书，其中两个关键点吸引了我，IBM和CEO，之前对于IBM的了解也只是零碎的片段，也是在一次IBM的活动演讲迟迟才知道IBM是每年发明获取专利最多的企业， 这本书《谁说大象不能跳舞》是由IBM董事长-郭士纳(原CEO)写的，书中讲述作为93到03年十年内，将IBM从濒临危机边缘带领起死回生。个人最为欣赏感悟有三点：</p>
<a id="more"></a>
<h1 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h1><p>在人际关系的把握，多方面的与各种目标群体沟通，在管理中发现挖掘人才，同时遇到问题，沟通分析能够直击要害。</p>
<h1 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h1><p>郭士纳认为，关注点对于一个机构的成功来说是一个关键性的因素。如果一个管理团队没有搞清楚公司的关注点，就很有可能误入歧途；缺乏关注点是平庸的公司中最常见的现象；找到了关注点，就等于为公司确立了方向感。关注点能迫使公司限制其野心，避免“<strong>这山望着那山高</strong>”，使管理者能够集中资源，搞好经营管理。</p>
<p>初到IBM, 郭士纳为了找到蓝色巨人的关注点，为自己定下了“<strong>90天内不做决策</strong>”的规定。同时这里也体现了他作为一个资深管理者的个人魅力，能够顶住巨大的压力，拥有自己的信念和原则，风云不惊，冷静的分析抓住要害，弄清关注点，避免东打一枪，西打一枪。</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>在《执行力》一书中，执行被认为是“一套系统化的流程。包括对方法和目标的严密讨论、质疑、坚持不懈地跟进。”这是理论化的执行。在郭士纳看来，执行就是把战略转化为行动，并对其结果进行测量，是促成一个战略获得成功的真正关键因素。在执行方面犯下的最大的错误，就是把期望和检查混为一谈。超级的战略执行并不仅仅是做正确的事，而是必须是比竞争对手更快、更经常和更有效地去做正确的事。《谁说大象不能跳舞》处处闪烁着郭士纳高超的执行力和对执行在企业管理中所起作用的真知灼见。</p>
<p>重点关键语“<strong>在执行方面犯下的最大的错误，就是把期望和检查混为一谈，因为太多的主管并不知道：员工只会做你检查的事情,而不会去做你期望的事</strong>”意思在于,要想让员工很好的完成任务就要对其工作不断督促、检查。所以作为上级主管就要主动走出办公室,主动找员工了解情况,给予员工工作所需的支持,并把握工作的进度；每一位员工在工作中,也应树立工作第一、效率第一的意识,学会“主动反馈”,上级是你工作可利用的资源,同时注意不仅仅在有问题的时候主动寻求上级的帮助,在工作开展的过程中也要向上级主动汇报进展情况,因为上级最担心的事情就是不知道你在忙什么,不知道你的工作到底做得怎么样了；</p>
<p>跨部门工作协调时,要主动告诉别人自己的职责和担负的责任,让别人充分理解你的工作,而寻求帮助的人,要不断督促给你办事的人,由于各个部门都很忙,所以往往也是“只会做你追地紧的事,而不做你期望的事”。所以不管是上下级之间,还是平级部门之间,主动沟通,执行力自然会得到提升。</p>
<p>从而避免以下的事情发生:在工作中,我们经常会遇到下面一种情况：有些主管,在给下属员工分配完任务后,就开始做起了“甩手掌柜”,只是坐等任务的完成了。一般情况下,下属接到任务后,就开始思考任务如何完成并形成自己对任务的理解,由于没有得到及时的指导并充分沟通以获得相关信息的支持,最终导致任务往往完不成,或者完成的结果与上级设想的有差距。差距的责任,肯定最终也会落在这位不幸的员工头上,而很少有主管会认为自己有错。</p>
<p>员工在执行任务过程中,常常会遇到许许多多不确定的问题,但是很多人认为求助是自己无能的表现,所以在遇到一些问题时,不愿意主动去寻求上级的帮助,怕上级嘲笑；另外还有些人认为上级太忙,自己的事情“小”又不是非常非常的着急,怕麻烦上级,给上级留下不好的印象！</p>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>以上关注点和执行也是郭世达在IBM改革的九大原则”<strong>关注点、现金流、原则性领导、以客户为导向、从现实出发、注重营销 绩效工资、执行、激情</strong>“中的两条。</p>
<p>同时网上也进一步了解IBM公司历程，发现《<strong>浪潮之巅</strong>》这本书中的第二章节”<a href="http://www.googlechinablog.com/2007/08/ibm.html" target="_blank" rel="noopener">蓝色巨人IBM</a>“讲的蛮不错，推荐看看。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Management</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN版本控制开发规范化</title>
    <url>/2010/03/svn-version-control/</url>
    <content><![CDATA[<p>终于忍受不了项目文档QQ传来传去的痛苦，决定在让SVN介入进来，进行版本控制，这才捡起荒废半年多的SVN。整理下Windows下SVN 服务器，客户端基本的安装配置，及常用操作命令。</p>
<a id="more"></a>
<h1 id="客户端-TortoiseSVN"><a href="#客户端-TortoiseSVN" class="headerlink" title="客户端-TortoiseSVN"></a>客户端-TortoiseSVN</h1><ul>
<li>官方下载地址：<a href="http://tortoisesvn.net/downloads" target="_blank" rel="noopener">http://tortoisesvn.net/downloads</a></li>
<li>比如下好TortoiseSVN-1.6.7.18415-win32-svn-1.6.9.msi 并安装</li>
</ul>
<h1 id="服务器端-Subversion"><a href="#服务器端-Subversion" class="headerlink" title="服务器端-Subversion"></a>服务器端-Subversion</h1><ul>
<li>官方网址：<a href="http://subversion.apache.org/" target="_blank" rel="noopener">http://subversion.apache.org/</a></li>
<li>下载安装后，需重启。(如没有安装Apache HTTP Server，请先安装 )</li>
</ul>
<h1 id="服务器端创建版本库"><a href="#服务器端创建版本库" class="headerlink" title="服务器端创建版本库"></a>服务器端创建版本库</h1><p>有两种方式创建版本库-Repository：</p>
<ul>
<li>通过控制台运行 “svnadmin create F:\svndir” 就会在目录F:\svndir 创建好版本库</li>
<li>通过客户端TortoiseSVN菜单工具在目录F:\svndir下”右键-&gt;TortoiseSVN-&gt;Create Repository here</li>
</ul>
<h1 id="配置服务器权限"><a href="#配置服务器权限" class="headerlink" title="配置服务器权限"></a>配置服务器权限</h1><p>主要为用户名密码设置，其他有用户权限控制等等：</p>
<ul>
<li>转到 F:\svndir\conf目录，修改svnserve.conf：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># password-db = passwd</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">password-db = passwd</span><br></pre></td></tr></table></figure>
<ul>
<li>修改同目录的passwd文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[users]</span><br><span class="line"># harry = harryssecret</span><br><span class="line"># sally = sallyssecret</span><br></pre></td></tr></table></figure>
<p>底下增加一行，格式为：用户名=密码，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username = password</span><br></pre></td></tr></table></figure>
<h1 id="运行版本库服务器"><a href="#运行版本库服务器" class="headerlink" title="运行版本库服务器"></a>运行版本库服务器</h1><p>运行服务器同样也有两种方式：</p>
<ul>
<li>通过每次启动后控制台运行“svnserve -d -r F:\svndir”</li>
<li><p>通过配置系统服务，控制台运行一下设置:</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc create svnserve binPath= "\\"C:\\Program Files\\Subversion\\bin\\svnserve.exe\\" --service --root F:\\svndir" displayname= "Subversion Repository" depend= Tcpip start= auto</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：sc是windows自带的服务配置程序，参数binPath表示svnserve可执行文件的安装路径，由于路径中的”Program Files”带有空格，因此整个路径需要用双引号引起来。而双引号本身是个特殊字符，需要进行转移，因此在路径前后的两个双引号都需要写成\“，–service参数表示以windows服务的形式运行，–root指明svn repository的位置，service参数与root参数都作为binPath的一部分，因此与svnserve.exe的路径一起被包含在一对双引号当中，而这对双引号不需要进行转义。displayname表示在windows服务列表中显示的名字， depend =Tcpip 表示svnserve服务的运行需要tcpip服务，start=auto表示开机后自动运行。</p>
<p>若要卸载服务：执行”sc delete svnserve”</p>
<h1 id="初始化导入"><a href="#初始化导入" class="headerlink" title="初始化导入"></a>初始化导入</h1><p>来到我们想要导入的项目根目录，F:\workspace\svnproject：右键-&gt;TortoiseSVN-&gt;Import… URL of repository（版本库URL）输入“svn://localhost/svnproject”</p>
<p>完成之后目录没有任何变化，如果没有报错，数据就已经全部导入到了我们刚才定义的版本库中。非本机访问网络URL格式为：“svn://xxx.xxx.xxx.xxx/svnproject”。</p>
<h1 id="客户端-TortoiseSVN常用操作说明"><a href="#客户端-TortoiseSVN常用操作说明" class="headerlink" title="客户端-TortoiseSVN常用操作说明"></a>客户端-TortoiseSVN常用操作说明</h1><ul>
<li>SVN Commit：在你做了修改之后，你可以在项目文件夹下点击右键或者你修改的文件下点击右键，选择 SVN Commit…，这两者的区别在于，第一个可以一次提交你所做所有文件的修改，而第二个只是提交你所选的文件。</li>
<li>Import：如果翻译插件或者写了插件，想提交到远程服务器，选择该文件夹，点击右键，选择 TortoiseSVN =&gt; Import…</li>
<li>SVN Update：与服务器版本对比，进行更新</li>
<li>Revert：取消上一次的操作（只针对客户端，服务端不做改动）</li>
<li>Add：增加新目录或新文件至项目</li>
<li>Revision Graph：版本示意图</li>
<li>Show log：查看版本日志及不同版本间相互比较</li>
<li>Check for modifications：同服务器上的项目版本进行比较，并可做相应的修改。</li>
</ul>
<p>更详细使用说明：<a href="http://www.subversion.org.cn/tsvndoc/" target="_blank" rel="noopener">TortoiseSVN中文手册</a></p>
<p>更详细安装文档：<a href="http://wenku.baidu.com/view/09e5a417866fb84ae45c8d95.html" target="_blank" rel="noopener">SVN服务器端安装配置</a></p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>Subversion</tag>
      </tags>
  </entry>
  <entry>
    <title>人生如传奇</title>
    <url>/2010/03/life-as-legend/</url>
    <content><![CDATA[<p>虽然之前听过一些李健的歌曲，但在春晚还是第一次听到王菲翻唱的这首歌《传奇》，不愧为歌后，用她那空灵的嗓音阐释了这首作词作曲都十分优雅的歌曲，另一方面，作为词本身所讲述的可能是每一个人生活中或多或少所遇到过的，但是又有谁会为了这个多看一眼，甚至一面之交都不算，而难以释怀呢，或许大概因此而取名为传奇。想想，大致是因为人的那份特殊第六感，从而在那短短的时刻里，产生获取难以估量的情感。</p>
<a id="more"></a>
<p>同时也正是这个多看了一眼，第一次的刹那接触，给予的一种前所未有的新鲜感与完美感，而这种之前连想象中都未必曾有的感受必然是带来极大的吸引力，人生做过许多事情，但是会记住很多个第一次，为什么？其实并不是所有第一次都是美好的，但是，可以肯定的是第一次是觉得具有新鲜感的，真是在一种新鲜感所笼罩下，有限的信息获取内，会或多或少的淡化那些不好不愉快，留下的是忘怀的新鲜感和满足感。</p>
<p>感情是脆弱的，而越发现感情是需要维持的，用心去经营，当拨开朦胧装饰下的面纱后，更加真实的互现，那第一眼的魅力还能保存多久？或许是个未知数，更多的需要去珍惜，理解与包容。同样，因为人无完人，所以才坦然处世，淡然看待周遭的一切，忘记曾经的得得失失，不为不曾拥有，但为今天努力与付出，耕耘着一份理想，还不曾去压力重重的等待开花结果。</p>
<p>常云遗憾也是种美，那么不遗憾呢？不遗憾那就是完美了。能记得过多少的完美，又能记得多少的遗憾，大概是我们已经淡然的面对遗憾，内心已释然，否则无法感受到遗憾中的那份美罢了。如果没有这份遗憾的美，人生就不会那么传奇了。</p>
<pre><code>只因为在人群中多看了你一眼  
再也没能忘掉你的容颜  
梦想着偶然能有一天再相见  
从此我开始孤单地思念

想你时你在天边  
想你时你在眼前  
想你时你在脑海  
想你时你在心田

宁愿相信我们前世有约  
今生的爱情故事不会再改变  
宁愿用这一生等你发现  
我一直在你身边  
从未走远
</code></pre>]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈·决策·执行力</title>
    <url>/2010/03/game-decision-execute/</url>
    <content><![CDATA[<p>终于，重新回归于这片天地，荒废的许多，因为许许多多的原因，正如同决定与我当前所有IM同步签名为主题-博弈·决策·执行力，一样，几乎是在一种冲动的回归下，历经近两天的整改，终于将博客打造到我满意的状态下，正由个性所致，追求极致，在这个基于WP的开源博客中，调试其中代码几乎到了每一个角落，熟悉了点PHP，了解到了wp的设计思维和灵活性，也很不好意思，原来回复等数据都因故障不好恢复，如今在一种把几乎冲动作为最大权重的博弈下的决策，执行的很彻底。</p>
<a id="more"></a>
<p>转而回顾承接到上篇文章，发现得跨度长达三个月之久，什么都没写下留下，不免给自己留下一种空白错觉，但是，我仍然是记得起这几月的珠珠粒粒。对于早已逝去的2009年，及时相对农历来说也有半月，过去的一年，是一个长的跨度，然而当梦想步入现实，不能像温水中的青蛙，浑然不知，需要一个长效的博弈决策，从而恒久的去执行。</p>
<p>生活如同一桶盛装在木桶中的水，需要把握周边-桶沿的一些平衡，每一个面，不能任意放纵一方，否则犹如一片低矮缺口，从而一泻千里。</p>
<p>对于今后一阶段明确好各阶段改做什么，有条不紊，善始善终。保持淡然的心，每天坚持着一些，每周坚持着一些，而步入自然的自我发展。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>一些思考</title>
    <url>/2009/12/some-thoughts/</url>
    <content><![CDATA[<p>掐指一算，有快一个月没有更新文章了，不代表一直是那么忙碌着，反而是有些混乱。 从昨天白天起大雾到今天整天的大风，天气似乎不给任何好眼色，而心情更是压抑的起不来，忙完学科的事情，忙完跟进好老师的要求，内心此时已近折腾的疲惫不堪，混乱，爆炸，却翻不到一个裂口。通俗来讲预想打喷嚏却又不能。</p>
<a id="more"></a>
<p>时间在一周周的逝去，事情似乎也在按步就班的推进着，但是一次“意外”的交谈让我不禁再次打开尘封已久的担忧，以目前的状况会找到光明的之路么，自己到底要承受多少压力，目前已近认识到，并扛在肩上的又有多少。</p>
<p>同时与日俱增的是害怕孤独，从本校一起来的虽然有二十来人，但是全都不是本院的，生活学习上基本没交集，原还指望这些，现在看来是免了，一个月也见不了一次。 想起做英语presentation的时候，偷懒，错误的将主题由economic in life 改为life，而life中的分析仍然完全按照economic角度分析，导致了一种完全偏盖全的错误思维，最后老师找我谈说中，耐心的教诲，谈话中再次提到那个笑话:”眼一闭一睁，一天过去了，眼一闭不睁，一辈子过去了”，生活中的事物不能完全按economic来讲道理的，似乎有很多事讲不出什么道理的，而我似乎对于每一个问题都要翻来覆去想个究竟，想个为什么，明明自己是感性的，却总是此时不知欺骗内心还是怎样去故装理性去分析。</p>
<p>同时更让我惧怕着眼一闭一睁，与其实害怕眼一闭一睁而最后积累成了一闭不睁，实质上是害怕每次的一闭一睁是否是充实的，人生享受的是这一个过程，而不是开始和结局，享受的同时不得不忍受各种压力，煎熬。人生中的每个阶段似乎都有一个固定模式的任务要去做，阶段性的压力会因此自然地摆在面前，但确又能让人压抑的踹不过起来，源自放不下过去，未来又似乎充满着无数个不确定，所以只能将重量压在肩上。 错误的认识，错误的思考方式，错误想法，到最后错误的做法， 不禁让我还是在想究竟是错在什么地方。人生究竟有对错么，对错又是谁来定的，与其说世界是混沌的，任何事情事物都是没有明确的界限的，而辨证思维方式却总是教诲人们事物都是有两面性，从而又将这种模糊的混沌一下子撇开为两面，那么究竟哪些应该归类在那一边呢，界限又会在哪里，多一点少一点，又将何妨呢。</p>
<p>同时当自己傻乎乎的按照自己想法做好计划时候，突然来了一句计划赶不上变化，一下子会经常不知所措起来，但一想那计划又可以跟着变化而重新调整啊，而不就是这样么，计划，变化不断的迭代的交替演进着。谁能说人生不去做些计划，但是当踌躇满志的计划面对变化又将何处何从。</p>
<p>常说，放眼于四海，内心方能开阔，但究竟这个四海怎么定呢，为什么有时候抬头看一眼反而是觉得更加的烦躁踌躇呢。还是应该少发牢骚，把头埋起来，耐心做事，抑或是浮躁太久。</p>
<p>婴儿喜欢发点脾气，因为那样基本上可以有很大的概率有人来关注，to be continue.</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>西红柿鸡蛋面</title>
    <url>/2009/11/tomato-eggs-noodles/</url>
    <content><![CDATA[<p>上午起来，等着烧水泡豆浆，拾起久违的魔方摆弄起来，翻腾一阵，当魔方到了完全复原的最后一步，竟然没有勇气去完成那一步，而是顺势变换方式重新打乱，心安理得的放在架子上。终点的喜悦是微不足道的，更欣赏喜欢的是沉浸那一步步的过程，不适于终点的茫然与无措，恬然于过程的踏实与希望。</p>
<a id="more"></a>
<p>出门之前，踏上木梯，折好被子，习惯使然，没有外在的强迫约束。似乎那摊开的被子承载了太多太多，而叠起被子正是叠起昨天昨夜的心情，如此，才背起行囊，踏实的开始今天的事情。而那折好的被子还会等待我为我装载今天我所做的一切。</p>
<p>中午，照例来到兰州拉面馆，桌子已经不同于昨天，全整齐的换上了火锅桌，在询问下，店主热情的介绍其他们的招牌火锅菜。端来一大碗我点的西红柿鸡蛋面，家常面，听着来自厨师厨房的声音，判断鸡蛋是先煎好的，随后是直接加热水下面。所以这样鸡蛋吃起来融合了炒鸡蛋和面汤的味道。当然还有里面的各种作料，葱叶，蒜末，小姜片。就是这些看似不起眼的作料，确在一起酝酿出一种合而不杂的味道，让人难以抗拒，特别是在寒冷的天气里。西红柿鸡蛋面，上次有印象的还是在焦作云台山风景区吃的，如此家常，不用过多修饰，确总能让人难以忘怀。</p>
<p>来到公交车站，不再向以前那样焦急等待。因为渐渐的已经习惯了开车的钟点，看看表，看看车站的车辆，再看看等待的人群，便约莫知道，还有多长时间启程。如今每次坐上车不在是一种抱怨，而是一种成功博弈的喜悦感。原来焦急不是因为已知，而是因为未知，更是因为缺乏信心。</p>
<p>一天的开始，不用承载太多过去和将来，就如同看过许多性格诊断一样，深信自己是一个喜欢跟着计划走的人，与其是追寻梦想的结果，不如说是享受在过程之中。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>忙</title>
    <url>/2009/10/busy/</url>
    <content><![CDATA[<p>和久违的朋友聊天，谈到最近过的怎么样，当朋友谈到忙，又婉言是觉得瞎忙，突想到自己不能说是瞎忙，可的确感觉到某种程度上是否有些盲目呢。联想到曾与一个公司的部门经理聊天，他谈到忙是毫不避讳的，但能十分的坦然的近乎自豪的谈到他觉得最重要的是他认为他有效率，虽深知当今忙是主题曲，当自己天天看似忙得不亦乐乎，却是否要审时度势下不能让那种被动的忙充塞着自己的每一天呢，或许还有许多可以改进，看到awflasher更新久违的博客，同样谈到忙，忙得都没时间更新博客，但当回顾一下，欣然充满着充实感。漠然回首，权衡三分，是否虚度。</p>
<a id="more"></a>
<p>自认为喜欢经常记下自己每时每刻的感想，但之前有时候越发过多空洞，抑或是过多消极无用的反思，但愿在如今的所有都不是，自诩经常写点记点总是好的，但是突然来了一条科学新闻，说爱写日记的人更容易得思想精神上的问题，不禁闻风而立，虽没有过多考究，但联想到最经看到的一本书《你错，我对》谈到人们总是喜欢主观的建立一种思想判断，接下来的任何事情无非都是加深这种判断或臆想。似乎是有道理的，如同小时候看到电视上的一个人出场，总喜欢立马焦急的问大人们，这个人是好人还是坏人。喜欢了两性极端的分割的思维，在今天虽然是提倡正反两方面来辨证看待，但是或许我们仍然实际中被迫面临一种尴尬而难以逃避的二选一问题。所作的事情不应是为了去强化之前的印象，不应以一种滚雪球似的叠加。而正想写东西，写到快乐的时候，写到不快乐的时候，都不能不应该自无意之中让其充当一种放大效应，而应是单纯的去写，单纯的去思考，脱离定性，才能保证风欲动而叶却止。</p>
<p>上周看China Daily手机报，最后以模块介绍一个词组-insanely busy，忙的发疯，心领神会，几乎是为自己准备打的，因为当时几乎就是陷入那种境地，一件事情没做好，转而叠加上其他的，深刻体会到时间对于人来说绝非是线性的，当不忙的时候，或许登高远眺一下，未雨绸缪，早做计划；当忙的时候不妨定下心来一个一个击破，而那击破的冲劲可以带来极大激励效应，这样只有一个一个的清空当前的事务队列，才能有精神，有计划，有安排的体会品味人生。</p>
<p>旧的解决了，新的事务也到来，insanely busy是自己造成的，平衡最终还是源靠自己，电池充满了，也该休息了。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>来帝都的这些日子</title>
    <url>/2009/10/this-days-in/</url>
    <content><![CDATA[<p>在京的天气也一天比一天冷了，作为一个相对南方人的我，竟然还受得了，不时还会被关怀一下：穿的这么少冷不冷。欣欣然的已近完全适应了这边的天气，就连这相对如此干燥的天气。</p>
<a id="more"></a>
<p>每天似乎也就是在几点之间来回跑，固定的节奏中也充满着变化。脑海里也渐渐添加了不少熟悉的场景，声音和味道。每每走进地铁，匆匆的人群中，也闻到了一股气息，那气息之中也包含了自己-忙碌的穿梭。每每跑到西单，也能在各种地点找到和朋友的曾经身影。同样的，学校周边，大运村周边，更不例外，积极的以欣赏发现的态度去尝遍周边的小吃，与朋友分享着。</p>
<p>慢慢的，陌生的不再陌生，曾经没来之前几乎不愿去想在北京怎么过，到京之初，茫茫然不知所措，脑海中的既定生活资料随着全新的位置大部分失效，再到现在，努力的去发现探索，渐渐建立了自己的模式。这才唏嘘到，之前刚到之时，那么留恋武汉，那么留恋<a href="http://baike.baidu.com/view/709356.htm?fr=ala0" target="_blank" rel="noopener">光谷步行街</a>，其实在京我完全可以发现更多的“光谷步行街”，并且不会像原先那个一样，将我们无形截留在学校周边。但我仍然铭记着武汉，学校，步行街，因为那边有我们曾今难忘的身影。</p>
<p>仍然记得，如同世界新闻产生传播的最多的是美国，那么在中国，则对应的是北京，曾今听那些新闻似乎从来没有如临其境的感受，而现在，虽然看起来的确身临其境，但是并没有多大的在意，并没有因为什么而过多兴奋，失落，恐慌，似乎生活的调节是如此微妙，一致让每个人具有非凡适应性。</p>
<p>渐渐的，去观察，了解，品味这个城市，可以说是全国名族省份融合最多的城市，在这里，你可以遇到许多天南地北的人们，当然不乏地球上来自许许多多经度、维度的人们。因此已经是完全打开了一个面向世界的窗户。透过这里去了解人们，了解世界。</p>
<p>还记得满载着行李来京时的不安与茫然；还记得第一次到奥体中心，无意抬头看到鸟巢的兴奋；还记得到护国寺吃完小吃后，领着满月的月光，沿着什刹海，西海，长达五个小时的步行重回寝室；还记得在还记得陪着朋友逛着西单，吃着甜筒加水果冰激凌；还记得去朝阳CBD，看着裤衩楼、SOHO、SK、双子塔，摸索着新式电梯的用法，<a href="http://baike.baidu.com/view/306518.htm" target="_blank" rel="noopener">世贸天阶</a>里头，同学发了一条“北邮北邮我爱你！”的顶壁液晶显示短信，而我则莫名的冲动发了一条“因为有梦，因为有爱，因为彼此，所以永远~”的傻痴短信，我更愿意解释的是但愿普天的人们都能为理想而永远奋斗，恰好那天不是周末，没多少人发，那条短信直到我离开的时候仍然亮闪闪在那里。</p>
<p>北京的节奏是如此之快，似乎就连一个甲型流感都可以通过观察人们带口罩的情况当做一个晴雨表，如今因为甲型流感形势严峻化，坐车归来途中看到越来越多的人们带上五颜六色的口罩，无形中就能体验到一种气势笼罩，不过这又何妨，因为当抬头环视，餐厅酒店依然人流如织，似乎没有什么比这更加豁达释然了，城市的生命力是不能不会被那些疫情所摧残的，特别在是如今的科技社会里。</p>
<p>思绪依然是许多，但或许整理下才有可能更好的前行，深夜的闲暇，舞动下指尖，品味过去的两个月，留下许分零零碎碎。</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>指尖中的舞蹈</title>
    <url>/2009/10/dance-in-fingers/</url>
    <content><![CDATA[<p>一直以为着，在生命的节律中的人们，总在经营着什么，虽不能像新巴比伦国王那样经营者空中花园，但是，至少可以有一个藏于心中的后花园，能够让人们一直去经营呵护着。</p>
<a id="more"></a>
<p>常常觉得自己比较健忘，对于时光异彩的阶段固然能够充满着回忆，但是对于那些看似平淡无奇的时刻，则常常感叹捡不起完整的片段，从而心生顿疑，是时间偷走了记忆，还是记忆早已吞噬掉时间。但又不相信时间是非线性的对待生活，所以琢磨着应该是生活非线性的对待了时间。</p>
<p>似乎这两条思绪可以概括开篇思绪，因为坚信生命中的每一刻都值得回味，因为心中一直拥有一个后花园，所以找到了这里。从纸介质记录，到网易，到百度，最后到这里，先后经历了三载之久，逃离了社区般的铜锣湾，来到一座岛屿，支起了自己的帐篷。</p>
<p>书信与电子邮件，传统与现代。当取而代之的是指尖在键盘上的舞蹈的作品，我们缺少更多了机会去张写的墨彩淋漓，潇洒奔放，笔力遒劲，倘若想一想，或许通过指尖中的舞蹈也不放是一种气息的展现，亦或许这两者可以归结到一个完美平衡点，乃至由这个极小的比对，在大千世界里，何处不能达到平衡呢？</p>
]]></content>
      <categories>
        <category>指尖舞蹈</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
</search>
